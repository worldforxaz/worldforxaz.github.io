<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xaz的花花世界</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-05-26T05:03:22.910Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>xaz</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>windows使用技巧</title>
    <link href="http://example.com/2024/05/26/windows%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>http://example.com/2024/05/26/windows%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</id>
    <published>2024-05-26T04:59:08.000Z</published>
    <updated>2024-05-26T05:03:22.910Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="1-善用多桌面功能"><a href="#1-善用多桌面功能" class="headerlink" title="1.善用多桌面功能"></a>1.善用多桌面功能</h1><p>ctrl + win + D 新建桌面</p><p>ctrl + win + 左右方向键 切换桌面</p><ul><li>可以在新桌面跑一些需要挂在后台的任务</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;1-善用多桌面功能&quot;&gt;&lt;a href=&quot;#1-善用多桌面功能&quot; class=&quot;headerlink&quot; title=&quot;1.善用多桌面功能&quot;&gt;&lt;/a&gt;1.善用多桌面功能&lt;/h1&gt;&lt;p&gt;ctrl + win + D 新建桌面&lt;/p&gt;
&lt;p&gt;ct</summary>
      
    
    
    
    <category term="软件安装与使用" scheme="http://example.com/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>高通量筛选结构</title>
    <link href="http://example.com/2024/05/25/%E9%AB%98%E9%80%9A%E9%87%8F%E7%AD%9B%E9%80%89%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2024/05/25/%E9%AB%98%E9%80%9A%E9%87%8F%E7%AD%9B%E9%80%89%E7%BB%93%E6%9E%84/</id>
    <published>2024-05-25T14:01:20.386Z</published>
    <updated>2024-05-25T11:59:51.971Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><pre><code class="python">from pymatgen.ext.matproj import MPRestera = MPRester(&#39;1agzMpqyTNkIiTUX&#39;)structure = a.get_structure_by_material_id(&quot;mp-1234&quot;)print(structure)a.get_database_version()#data = a.query(criteria=&#123;&quot;pretty_formula&quot;: &quot;Li2O&quot;&#125;, properties=[&quot;spacegroup.symbol&quot;])#data = a.query(criteria=&#123;&quot;pretty_formula&quot;: &quot;Li2O&quot;&#125;, properties=[&quot;icsd_ids&quot;])data = a.query(criteria=&#123;&quot;pretty_formula&quot;: &quot;Li2O&quot;&#125;, properties=[&quot;material_id&quot;])data = a.query(criteria=&#123;&quot;pretty_formula&quot;: &quot;Li2O&quot;&#125;, properties=[&quot;band_gap&quot;,&quot;structure&quot;])data = a.query(&#39;Li-O&#39;,properties=[&quot;band_gap&quot;,&quot;material_id&quot;&quot;cif&quot;])) #获取Li-O体系所有化合物和iddata = a.query(&#39;Li-O-*-*&#39;,properties=[&quot;formula&quot;,&quot;material_id&quot;,&quot;band_gap&quot;])#获取所有四元Li-O化合物data = a.query(&#123;&quot;elements&quot;:&#123;&quot;$in&quot;:[&quot;Na&quot;], &quot;$all&quot;: [&quot;O&quot;]&#125;, &quot;nelements&quot;:4, &quot;band_gap&quot;: &#123;&quot;$gt&quot;: 2&#125;, &quot;e_above_hull&quot;: &#123;&quot;$lt&quot;: 0.1&#125;&#125;,properties=[&quot;formula&quot;,&quot;material_id&quot;,])#带隙&gt;2的所有Na-O四元素化合物print(len(data))#data = &#123;     &#39;criteria&#39;: &#123;          &#39;elements&#39;: &#123;&#39;$in&#39;: [&#39;Li&#39;], &#39;$all&#39;: [&#39;O&#39;]&#125;,          &#39;nelements&#39;: 4,      &#125;,      &#39;properties&#39;: [        &#39;formula&#39;,        &#39;material_id&#39;,      ]   &#125;#r = requests.post(&#39;https://materialsproject.org/rest/v2/query&#39;,#   headers=&#123;&#39;X-API-KEY&#39;: &#39;1agzMpqyTNkIiTUX&#39;&#125;,#   data=&#123;k: json.dumps(v) for k,v in data.items()&#125;)#response_content = r.json()#print(response_content[&#39;num_results&#39;])#stable_mpids = [doc.material_id for doc in docs]print(m.get_data(&quot;Li2O&quot;, prop=&quot;structure&quot;))for abc in data:    print(abc.values())#    print(abc[&#39;formula&#39;])valulist=[abc.values() for abc in data]valulist = [abc[&#39;material_id&#39;] for abc in data]valulist = [abc[&#39;formula&#39;].keys() for abc in data]#列表每个元素是一个字典，包含两个键，第一个键的值又是一个字典，包含四个键 #把第一个键的值的键作为列表peibi = [list(abc[&#39;formula&#39;].keys()) for abc in data] #把第一个键的值的键作为列表id  = [abc[&#39;material_id&#39;] for abc in data] pidic = dict(zip(id,peibi))#new1pidic=&#123;ka : va for ka, va in pidic.items() if &#39;H&#39; not in va&#125;#new1pidic2=&#123;ka : va for ka, va in pidic.items() if &#39;H&#39; in va&#125;nothopeelement=[&#39;V&#39;, &#39;Cr&#39;, &#39;Mn&#39;, &#39;Fe&#39;, &#39;Co&#39;, &#39;Ni&#39;, &#39;Cu&#39;, &#39;H&#39;, &#39;S&#39;,&#39;F&#39;,&#39;Cl&#39;,&#39;Br&#39;,&#39;I&#39;,&#39;N&#39;, &#39;Li&#39;, &#39;K&#39;, &#39;Ac&#39;, &#39;Th&#39;, &#39;U&#39;,&#39;Pa&#39;, &#39;Np&#39;, &#39;Pu&#39;, &#39;Am&#39;, &#39;Cm&#39;, &#39;Bk&#39;, &#39;Cf&#39;, &#39;Es&#39;, &#39;Fm&#39;, &#39;Md&#39;, &#39;No&#39;, &#39;Lr&#39;, &#39;Fr&#39;, &#39;Po&#39;, &#39;At&#39;, &#39;Rn&#39;, &#39;Tc&#39;,&#39;Ra&#39;,&#39;As&#39;,&#39;Hg&#39;,&#39;Be&#39;,&#39;Tl&#39;]newpidic=&#123;ka : va for ka, va in pidic.items() if not any (ha in va for ha in nothopeelement)&#125;#newpidic2=&#123;ka : va for ka, va in pidic.items() if any (ha in va for ha in nothopeelement)&#125;print(newpidic.values())id2=list(newpidic.keys())for ha in id2:    print(ha)    structure = a.get_structure_by_material_id(ha)    speciesna=[Element(&#39;Na&#39;)]    stripped = structure.copy()    stripped.remove_species(speciesna)    stripped = stripped.get_sorted_structure(reverse=True)    Vasp_Str = Poscar(stripped)    Vasp_Str.write_file(&#39;%s.vasp&#39;%ha)     #去除结构中的某一元素structure = a.get_structure_by_material_id(&quot;mp-6150&quot;)speciesna=[Element(&#39;Na&#39;)]stripped = struct.copy()stripped.remove_species(speciesna)stripped = stripped.get_sorted_structure(reverse=True)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;from pymatgen.ext.matproj import MPRester
a = MPRester(&amp;#39;1agzMpqyTNkIiTUX&amp;#39;)
structure = a.get_</summary>
      
    
    
    
    <category term="模拟方法" scheme="http://example.com/categories/%E6%A8%A1%E6%8B%9F%E6%96%B9%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>网易公开课_氢原子波函数</title>
    <link href="http://example.com/2024/05/25/%E7%BD%91%E6%98%93%E5%85%AC%E5%BC%80%E8%AF%BE_%E6%B0%A2%E5%8E%9F%E5%AD%90%E6%B3%A2%E5%87%BD%E6%95%B0/"/>
    <id>http://example.com/2024/05/25/%E7%BD%91%E6%98%93%E5%85%AC%E5%BC%80%E8%AF%BE_%E6%B0%A2%E5%8E%9F%E5%AD%90%E6%B3%A2%E5%87%BD%E6%95%B0/</id>
    <published>2024-05-25T14:01:20.383Z</published>
    <updated>2024-05-25T11:59:59.051Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="1-氢原子能级"><a href="#1-氢原子能级" class="headerlink" title="1.氢原子能级"></a>1.氢原子能级</h1><h1 id="2-氢原子波函数"><a href="#2-氢原子波函数" class="headerlink" title="2.氢原子波函数"></a>2.氢原子波函数</h1><p>单个单电子原子的轨道 单个多电子原子的轨道 多个多电子原子的轨道</p><p>Ha&#x3D;Ea  薛定谔方程   </p><p>哈密顿量是电子与原子的动能、势能、的总和。对于氢原子，能级就是单个电子和原子核的结合能</p><p>密度泛函理论就是用多个多电子原子的哈密顿量来解能量，没有波函数，因为波函数等价于电子密度。</p><p>三个主量子数 n l m   极坐标系中的量子数，和波函数的公式相关</p><p>n 能级 </p><p>l角量子数 l&#x3D;0 - n-1</p><p>m 磁量子数  m&#x3D; -l -  +l</p><p>s轨道  l&#x3D;0</p><p>p轨道  l&#x3D;1   pz l&#x3D;1 m&#x3D;0  px&#x2F;py  l&#x3D;1 m&#x3D;1&#x2F;-1</p><p>波函数a100   -   n&#x3D;1 l&#x3D;0  1s</p><p>a200   2s</p><p>波函数a210  - n&#x3D;2 l&#x3D;1  2pz</p><p>a211 -   2px&#x2F;2py</p><p>a21-1 &#x3D; a211</p><p>3dxy 3dyz 3dz2 3dxz 3dx2-y2</p><p>在氢原子中，s和p轨道的能量都是兼并的</p><p>一个电子和一个原子核的解都是类似氢原子的，加一个Z个电荷</p><p>三个主量子数的原因是描述一个三维的轨道（为什么是三维的）</p><p>对主量子数n，有$n^2$个简并的轨道（对单个氢原子而言）</p><h2 id="波函数的样子（主要是s轨道的径向分布）"><a href="#波函数的样子（主要是s轨道的径向分布）" class="headerlink" title="波函数的样子（主要是s轨道的径向分布）"></a>波函数的样子（主要是s轨道的径向分布）</h2><p>波函数的样子和平方的样子是一个意思，只不过做一个平方而已，对于特定的r，大的更大，小的比较小，对特定的角度也是这样</p><p>s  球 靠近核的地方密度大，概率大 </p><p>波函数分为两个可分离的部分，径向波函数和角向波函数。径向波函数是和原子核距离R的函数，角向是相对原子核角度的波函数</p><p>a&#x3D;R(r)*Y()</p><p>a100的解角度为固定值</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20240108205858532.png" alt="image-20240108205858532"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20240108185410853.png" alt="image-20240108185410853"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20240108185530558.png" alt="image-20240108185530558"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20240108190136321.png" alt="image-20240108190136321"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20240108190200050.png" alt="image-20240108190200050"></p><p><strong>1s轨道</strong><br>$$<br>\Psi_{100}&#x3D;2{a_0}^{\frac{-3}2}e^{\frac{-r}{a_0}}*\sqrt{\pi&#x2F;4}<br>$$<br><strong>2s轨道</strong><br>$$<br>\Psi_{2 00}&#x3D;\frac1{\sqrt2}{a_0}^{\frac{-3}2}(1-\frac{r}{2a_0})e^{\frac{-r}{2a_0}}*\sqrt{\frac{\pi}4}<br>$$<br><img src="/./../../%E5%9B%BE%E7%89%87/media/7c6/7c6fd243-cfcb-4c04-a037-1e3686cd6db1/image.png" alt="student submitted image, transcription available below"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20240108192204474.png" alt="image-20240108192204474"></p><p>Z:核电荷数</p><p>s轨道的波函数都是球，因为l&#x3D;0 m&#x3D;0对应一个常数</p><p>pz是一个球   l&#x3D;1 m&#x3D;0</p><p>px和py是椭球 l&#x3D;1 m&#x3D;+-1</p><p><strong>对于不同主量子数的p轨道，其角向分布函数分别是相同的，区别是径向分布函数，但是径向分布函数是只与R相关的函数，也就是径向分布函数只随着距离的变化而变化，和角度无关。也就是随着半径增加疏密程度的变化，决定形状的是角向分布函数</strong></p><p><strong>也就是说对于不同的主量子数，其相同类型的轨道具有相同的角度形状</strong></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20240108194619494.png" alt="image-20240108194619494"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20240108204551488.png" alt="image-20240108204551488"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20240108204604028.png" alt="image-20240108204604028"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20240108204703292.png" alt="image-20240108204703292"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20240108204943757.png" alt="image-20240108204943757"></p><p>波函数本身可以是负的，但是负号没有值的含义，平方还是正的</p><p>下图是波函数平方，也就是概率密度，和波函数形状一致<strong>波函数形状和概率密度形状一致，通过波函数就能看到电子概率的分布情况</strong></p><p>径向的分布情况</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20240108201150694.png" alt="image-20240108201150694"></p><p>1s 2s 3s </p><p><strong>对于电子分布，波函数正负的意义不大，但是对于成键比较重要。成键是电子云的叠加</strong></p><p>能量-概率密度（轨道比较形象，就是电子的运动空间）</p><p><strong>把氢原子所有轨道叠加起来就是它的整体的电子云，当然是一个球形了，因为所有轨道的能量是简并的。如果能量不简并，那它就只能在特定的轨道上运动了，也就有特定的轨迹，对氢原子，相当于是给区域分了类</strong></p><p><strong>当然，如果被激发后，能量就不同了，但是还是可以在s或者p或者d轨道上，主量子数变化但是轨迹分布还是可以随意走的</strong></p><p><strong>径向节点数量</strong>：主量子数-1-L  </p><p>1s 0 2s 1 3s 2  4p 2 </p><p>同一角量子数下不同的磁量子数对应的波函数的形状相同吗，节点数目相同</p><p>玻尔半径：概率最大值 （概率&#x2F;体积）</p><p>电子并不是绕着原子核旋转的！要看能量，能量如果简并，就在这些简并轨道运动，如果不简并，就在特定轨道运动</p><h2 id="p轨道"><a href="#p轨道" class="headerlink" title="p轨道"></a>p轨道</h2><p>&#x3D;&#x3D;l m决定了角向分布函数，n,l决定径向波函数&#x3D;&#x3D; ,不同的径向波函数也可以有相同的角向分布</p><p><strong>能带是晶体整体的所有电子的排布下的分列能级，或者分列轨道，也就对应着所有可能的电子能量分布。能带就是一个能级分布。一个能级可以对应多个轨道。每个轨道都可以填充两个电子。组成晶体后，有多少能级呢，无穷个，对应倒空间中无穷个点。通过特定的k点连线，得到最低能级。每个能级还可能是简并的，无法区分出来轨道的具体形状。</strong></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20240108211517098.png" alt="image-20240108211517098"></p><p>2s 3s 的概率密度，激发后，最大可能位置变得更远 基态为a_0</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20240108211847524.png" alt="image-20240108211847524"></p><p>波粒二象性使得粒子可以不经过b而从a到达c (驻波)</p><p>p轨道 有三个轨道 px py pz(m&#x3D;0)</p><p>三个轨道的区别在于节面的位置不同，最大值位置不同，相位分布不同（大于x或者y，或者z为正）pz在xy平面 px在yz平面</p><p>p轨道的角向节点为L 总节点数为n-l-1+l&#x3D;n-1</p><p>对于2p轨道，没有径向的节点（径向的连续空白区域，只有角向的，也就是没有在某一位置处有一个球形的节点）</p><p>2p轨道的最可能概率半径要小于2s，也就是2p更靠近原子核。p轨道比s轨道更靠近原子核。</p><p>主量子数越大，每个轨道平均都离原子核更远。</p><p><strong>现在不是经典的静电势图景，离原子核近的地方也可以能量比较大</strong>在经典的图像中，能级对应的轨道是确定的。这是波尔的错误</p><p><strong>n不变，随着l增加，最可能几率半径 降低 3d&lt;3p&lt;3s，但是能够以大概率接近原子核的轨道是3s&gt;3p&gt;3d    最可能和最近不同。</strong></p><p>对于一个多电子原子，s轨道最不容易被屏蔽，因为s轨道可以有最大概率更接近原子核</p><p>s电子既最远离原子核也最容易接近原子核</p><h2 id="电子自旋"><a href="#电子自旋" class="headerlink" title="电子自旋"></a>电子自旋</h2><p>$m_s$&#x3D;+-1&#x2F;2</p><p>三个量子数描述轨道，第四个量子数描述电子的状态</p><p>四个量子数是对电子的准确描述</p><p>每个轨道有两个电子</p><h1 id="3-多电子原子"><a href="#3-多电子原子" class="headerlink" title="3.多电子原子"></a>3.多电子原子</h1><p>多电子原子的波函数方程不可能解出（多体问题）</p><p>单电子轨道近似</p><p>分别考虑多电子原子中的每一个电子，都是一个多电荷原子加一个电子，这样可以使用氢原子能级来表示，只是在波函数中增加一个Z，多电子将依次地从低能级开始占据高能级，能级对应的主量子数不止是n，还和l有关。（一个是能级，一个是波函数，分清楚）但是这样做忽略了电子间的排斥作用。</p><p>Hartree 轨道：单电子轨道近似 (薛定谔波函数地解) why?</p><p>Lithium  A &#x3D; A1×A2*A3  A100 A100 A200  1s2 &#x3D; 1s×1s</p><p>电子组态是根据Hartree轨道写出的，周期表中的电子组态并不真实</p><h2 id="Hartree轨道和氢原子波函数地相似性与区别"><a href="#Hartree轨道和氢原子波函数地相似性与区别" class="headerlink" title="Hartree轨道和氢原子波函数地相似性与区别"></a>Hartree轨道和氢原子波函数地相似性与区别</h2><blockquote><p>相似性</p><p>形状相似（总节点 n-1 角向节点 l)</p><p>相同的节点数量</p></blockquote><blockquote><p>区别</p><p>多电子原子的单轨道近似比对应的氢的轨道更小（核电荷数更多）</p><p>轨道能量不仅依赖于n，也依赖于l </p><p>轨道的能量比氢对应的轨道能量低</p></blockquote><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20240113194748612.png" alt="image-20240113194748612"></p><p>通过确定电子的能量，可以确定电子的波函数&#x2F;轨道</p><p>屏蔽效应：电子间的相互作用抵消吸引力  内层离子屏蔽外层 </p><h2 id="角量子数的能量顺序"><a href="#角量子数的能量顺序" class="headerlink" title="角量子数的能量顺序"></a>角量子数的能量顺序</h2><p>2p轨道比2s轨道更近，但是2s轨道可以距离原子核的距离更近，因此受到的屏蔽更小，使得s轨道感受到的Z_eff更大，对应到能级上，-ZR&#x2F;n2  轨道的能量更小 </p><p>同理 E3s&lt;E3p&lt;E3d</p><h2 id="多电子原子洪特规则"><a href="#多电子原子洪特规则" class="headerlink" title="多电子原子洪特规则"></a>多电子原子洪特规则</h2><p>电子优先占据不同的波函数&#x2F;轨道，而不是相同的波函数&#x2F;轨道    电子尽可能进入不同的轨道来减少相互的斥力，从而降低能量</p><p>第四个量子数要求要首先平行，即自旋相同</p><p>周期：&#x3D; 主量子数  n</p><p>核电子被紧紧束缚在原子核周围，常温下只有价电子能够被激发（毕竟温稠密物质内层会被激发），离核最远</p><p>&#x3D;&#x3D;第四周期 4s低于3d 能级上低&#x3D;&#x3D;，但是波函数的距离上呢，应该同样是靠的更近，因为近的电子电子能量低？</p><p>Cr 4s15d5   Cu 4s13d10</p><p>3d在没有电子填充时比4s高，所以先填充4s，但是当有一个电子填充到3d时，3d的轨道就比4s能量低了，这时候如果要产生离子，是从4s来拿的</p><h1 id="光电子能谱"><a href="#光电子能谱" class="headerlink" title="光电子能谱"></a>光电子能谱</h1><h1 id="X-ray-photoelectron-spectroscopy"><a href="#X-ray-photoelectron-spectroscopy" class="headerlink" title="X-ray photoelectron spectroscopy"></a>X-ray photoelectron spectroscopy</h1><p>实验上确定不同的能级</p><p>测量不同原子打出来后的剩余动能</p><p>&#x3D;&#x3D;外层价电子和内层电子的能量差距很大&#x3D;&#x3D;，化学反应和化学过程主要考虑价电子 </p><p>对于Al和Na,最外层电子感受到屏蔽效应，但是不能完全屏蔽，导致Al的最外层电子感应到的有效电荷量还是多过Na，因此能量更低</p><h1 id="元素周期律"><a href="#元素周期律" class="headerlink" title="元素周期律"></a>元素周期律</h1><p>门捷列夫 根据元素性质对元素分类</p><p>1、2主族化学性质活泼 ：最外层容易失去电子 得到更低的能量 （每电子，类似相图中的每原子）</p><p>N不活泼因为是半满的</p><ul><li>电离能（默认指第一电离能，第一束缚能）</li></ul><p>向右，第一电离能逐渐升高，因为z是增加的，有效电荷量在增加，l的作用不明显</p><p>向下，第一电离能降低，因为主量子数增加，距离被很大降低了（概率上），n起主要作用</p><p>半满&#x2F;全满会降低电离能，但是不会降低到小于隔着的上一个。Li&lt;B&lt;Be</p><p>中性B原子中打出2s和B+中打出一个2s是不同的，B+中的2s电子的屏蔽效应更小，使得感受到的电荷量更大，因此能量更低，更难打出来</p><ul><li><p>电子亲和能 （得到一个电子的能力）</p><p>Cl- 比Cl更稳定，会放出能量</p><p>&#x3D;&#x3D;电离能是正的，表示打出一个电子需要的能量；电子亲和能可以是正或者负，表示增加一个电子的能量的负数；电子亲合能等于增加电子后能量变化的负值，正数越大表明越容易得到电子&#x3D;&#x3D;，是两个不同的物理过程，</p><p>N的电子亲和能是正的</p><p>向右电子亲和能增加，向下增加</p></li><li><p>电负性：一个原子吸引另一个原子的电荷密度的能力</p><p>正比于1&#x2F;2（电离能+电子亲和能） 越难打出，越容易嵌入，则电负性越大</p><p>从周期表向右电负性增加，向下电负性减小</p></li><li><p>原子半径 &#x3D;&#x3D;（没有确定的半径，百分之90的电子密度所在的地方）&#x3D;&#x3D;</p><p>向右减小，向下增加</p></li><li><p>等电子原子&#x2F;等电子离子:和原子具有相同的电子排布的离子</p><p>O2- F- Ne Na+ Mg2+</p><p>负离子比本体原子要大，正离子比本体原子要小。F- 比O2- 要小，因为束缚能力更小</p></li></ul><h1 id="共价键"><a href="#共价键" class="headerlink" title="共价键"></a>共价键</h1><p>键：如何放置两个原子核和电子的位置，使得它们的能量最低（低于两个原子分开的时候 </p><p>两个原子共用一对电子 </p><p>成键强度：成键之后能量降低了多少</p><p>键长：两个原子核之间的距离 </p><p>成键的原因：其中一个原子的电子与另一个原子核的吸引力，因为电子的屏蔽效应并不是完全的</p><p>离解能&#x3D;键的强度  ：把分子分开为两个原子的能量</p><p>N2分子的成键强度大于H2，键长更短</p><h1 id="Lewis-structures-路易斯结构（经验规律）"><a href="#Lewis-structures-路易斯结构（经验规律）" class="headerlink" title="Lewis structures 路易斯结构（经验规律）"></a>Lewis structures 路易斯结构（经验规律）</h1><p>要点：每一个原子都达到价壳层填满；电子共用</p><p>F 7个价电子：</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;1-氢原子能级&quot;&gt;&lt;a href=&quot;#1-氢原子能级&quot; class=&quot;headerlink&quot; title=&quot;1.氢原子能级&quot;&gt;&lt;/a&gt;1.氢原子能级&lt;/h1&gt;&lt;h1 id=&quot;2-氢原子波函数&quot;&gt;&lt;a href=&quot;#2-氢原子波函数&quot; cl</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>表面计算</title>
    <link href="http://example.com/2024/05/25/%E8%A1%A8%E9%9D%A2%E8%AE%A1%E7%AE%97/"/>
    <id>http://example.com/2024/05/25/%E8%A1%A8%E9%9D%A2%E8%AE%A1%E7%AE%97/</id>
    <published>2024-05-25T14:01:20.383Z</published>
    <updated>2024-05-25T15:37:22.264Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="1-固定原子"><a href="#1-固定原子" class="headerlink" title="1.固定原子"></a>1.固定原子</h1><pre><code class="python">from numpy import *import pandas as pdimport stringwith open(&#39;POSCAR&#39;) as f:    f.readline()    f.readline()    f.readline()    f.readline()    f.readline()    atom_name=f.readline()    atom_num=f.readline()    atom_name2=atom_name.split()     print(atom_name2)    atom_num2=[int(x) for x in atom_num.split()]    print(atom_num2)    atom_total=sum(atom_num2)    line_total = 8+atom_total    line_a=f.readlines()[1:atom_total+1]A=zeros((atom_total,3))B=zeros((atom_num2[0],3))C=zeros((atom_num2[1],3))A_row=0for line in line_a:    list =line.strip(&#39; &#39;).strip(&#39;\n&#39;).split(&#39; &#39;)    list=[x for x in list if x !=&#39;&#39;]    float_list=[float(x) for x in list]    A[A_row:]=float_list[0:3]    A_row +=1B,C=vsplit(A,[atom_num2[0]])#A[:,2] +=0.1 #第三列加0.2#A[:,1] -=0.1format_string= &quot;&#123;:,.8f&#125;&quot;with open(&#39;POSCAR-2&#39;,&#39;w&#39;) as h:    for i in range(B.shape[0]):        if B[i,2] &lt;0.33644:          for j in range(B.shape[1]):            h.write(format_string.format(B[i,j]) + &#39; &#39;)          h.write(&#39;F F F&#39;)          print(B[i])        else:          for j in range(B.shape[1]):            h.write(format_string.format(B[i,j]) + &#39; &#39;)          h.write(&#39;T T T&#39;)          print(B[i])        h.write(&#39;\n&#39;)with open(&#39;POSCAR-2&#39;,&#39;a&#39;) as h:    for i in range(C.shape[0]):        if C[i,2] &lt;0.3703:          for j in range(C.shape[1]):            h.write(format_string.format(C[i,j]) + &#39; &#39;)          h.write(&#39;F F F&#39;)        else:          for j in range(C.shape[1]):            h.write(format_string.format(C[i,j]) + &#39; &#39;)          h.write(&#39;T T T&#39;)        h.write(&#39;\n&#39;)   </code></pre><h1 id="2-计算表面能"><a href="#2-计算表面能" class="headerlink" title="2.计算表面能"></a>2.计算表面能</h1><p><a href="https://zhuanlan.zhihu.com/p/379448266">表面能计算基础及最新进展（PRB连载，计算表面能） - 知乎 (zhihu.com)</a></p><p><a href="https://en.wikipedia.org/wiki/Surface_energy">https://en.wikipedia.org/wiki/Surface_energy</a></p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230604191033411.png" alt="image-20230604191033411"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;1-固定原子&quot;&gt;&lt;a href=&quot;#1-固定原子&quot; class=&quot;headerlink&quot; title=&quot;1.固定原子&quot;&gt;&lt;/a&gt;1.固定原子&lt;/h1&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;from numpy import </summary>
      
    
    
    
    <category term="模拟方法" scheme="http://example.com/categories/%E6%A8%A1%E6%8B%9F%E6%96%B9%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>缺陷能</title>
    <link href="http://example.com/2024/05/25/%E7%BC%BA%E9%99%B7%E8%83%BD/"/>
    <id>http://example.com/2024/05/25/%E7%BC%BA%E9%99%B7%E8%83%BD/</id>
    <published>2024-05-25T14:01:20.382Z</published>
    <updated>2024-05-25T12:00:05.794Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><p>参考文献</p><p><a href="https://mp.weixin.qq.com/s/gkfI3tuqyvjD6kTvnX8ogQ">https://mp.weixin.qq.com/s/gkfI3tuqyvjD6kTvnX8ogQ</a></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230529095246103.png" alt="image-20230529095246103"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230529095258898.png" alt="image-20230529095258898"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230529095310586.png" alt="image-20230529095310586"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230529095336478.png" alt="image-20230529095336478"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230529095348263.png" alt="image-20230529095348263"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230529095357191.png" alt="image-20230529095357191"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230529095408475.png" alt="image-20230529095408475"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230529095421379.png" alt="image-20230529095421379"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;参考文献&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/gkfI3tuqyvjD6kTvnX8ogQ&quot;&gt;https://mp.weixin.qq.com/s/gkfI3tuqyvjD6kTvnX8ogQ&lt;/a</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>绘图细节</title>
    <link href="http://example.com/2024/05/25/%E7%BB%98%E5%9B%BE/"/>
    <id>http://example.com/2024/05/25/%E7%BB%98%E5%9B%BE/</id>
    <published>2024-05-25T14:01:20.381Z</published>
    <updated>2024-05-25T12:00:06.786Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h3 id="1-properties"><a href="#1-properties" class="headerlink" title="1. properties"></a>1. properties</h3><h4 id="1-原子"><a href="#1-原子" class="headerlink" title="1.原子"></a>1.原子</h4><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230612142745335.png"></p><ol><li><p>Shininese 一行控制原子中心光点， 颜色设置为黑色表示没有光点 值控制光点大小</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230612142949636.png"><img src="/./../%E5%9B%BE%E7%89%87/image-20230612143024505.png" alt="image-20230612143024505"></p><ol start="2"><li><p>不同原子的颜色，一个参考的配色方案（from liujingyi)</p><p><img src="/./../%E5%9B%BE%E7%89%87/IMG_20230612_105110.jpg" alt="IMG_20230612_105110"></p></li></ol><h4 id="2-成键"><a href="#2-成键" class="headerlink" title="2.成键"></a>2.成键</h4><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230612143457999.png" alt="image-20230612143457999"></p></li></ol><p>bond style控制是否使用双色还是单色还是不同类型的成键</p><h4 id="3-多面体"><a href="#3-多面体" class="headerlink" title="3.多面体"></a>3.多面体</h4><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230612143844460.png" alt="image-20230612143844460"></p><p>opacity 控制多面体的透明度</p><p>show polyhedral edges 控制是否显示多面体的边</p><h3 id="2-view-overall-appearence"><a href="#2-view-overall-appearence" class="headerlink" title="2. view - overall  appearence"></a>2. view - overall  appearence</h3><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230612144101094.png" alt="image-20230612144101094"></p><p>projiection 控制显示方式，平行还是透视</p><p>enable lighting 控制是显示二维还是三维</p><p>ambient 和diffuse控制光亮明暗</p><p>enabledepth-cueing 在调整时先不要去掉，最后要导出图像时，可以去掉，有助于去除灰蒙蒙的感觉，更加立体</p><h1 id="3-绘制旋转的结构图在ppt中展示"><a href="#3-绘制旋转的结构图在ppt中展示" class="headerlink" title="3.绘制旋转的结构图在ppt中展示"></a>3.绘制旋转的结构图在ppt中展示</h1><p>1.vesta导出时可以使用stl格式，在ppt中打开为3D模型</p><h1 id="4-好看的配色"><a href="#4-好看的配色" class="headerlink" title="4. 好看的配色"></a>4. 好看的配色</h1><p>蓝  <code>29 123 249</code>  青 <code>227243181</code></p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20231026083755745.png" alt="image-20231026083755745"></p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20231026083824812.png" alt="image-20231026083824812"></p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20231026084245240.png" alt="image-20231026084245240"></p><h1 id="5-绘制相图（三元三角、四元四面体）"><a href="#5-绘制相图（三元三角、四元四面体）" class="headerlink" title="5.绘制相图（三元三角、四元四面体）"></a>5.绘制相图（三元三角、四元四面体）</h1><p><a href="https://www.originlab.com/doc/en/Origin-Help/3d-Tetrahedral">https://www.originlab.com/doc/en/Origin-Help/3d-Tetrahedral</a></p><p>x y z z </p><p>四面体只需要四个顶点</p><p>三维相图</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20231206211650444.png" alt="image-20231206211650444"></p><p>#print([entrya.composition.reduced_formula for entrya in pd2.qhull_entries]) </p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20231206211706137.png" alt="image-20231206211706137"></p><p>#print(pd2.facets)  输出所有连接方式 (标号是上面的顺序，从0开始 )     pymatgen</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20231206211658347.png" alt="image-20231206211658347"></p><p>四元</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20231206213332475.png" alt="image-20231206213332475"></p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20231206213336951.png" alt="image-20231206213336951"><br><img src="/./../%E5%9B%BE%E7%89%87/image-20231206213344510.png" alt="image-20231206213344510"></p><p>目的是把块分成区域，每个区域不再能分配</p><p>三元相图是由一系列的小三元相图构图的，而小三元相图是由二元相图的边构成的。同理，四元相图由小四元四面体组成，而小四元四面体的边是二元相图，一个面是一个三元相图。</p><p>&#x3D;&#x3D;三元比二元多出来的特征在于可以有一些只能分解为三元的化合物，其他的稳定化合物完全可以以化合物为顶点做一个二元相图。而四元多出来的特征在于可以有一些只能分解为四个组分的化合物（在四面体中间）,要表示四元相图中的稳定结构，完全可以用三元相图、或者二元相图表示。&#x3D;&#x3D;</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20231207101533459.png" alt="image-20231207101533459"></p><h2 id="1-关于分解"><a href="#1-关于分解" class="headerlink" title="1.关于分解"></a>1.关于分解</h2><p>二元相图的横坐标是 y&#x2F;(x+y) ，y占据的百分数，二元的点本质上纵坐标都可以设置为在线上，只不过是能量的差别设置出来了高度，落在哪条线上就会分解为线的两端，三元落在哪个三角里就会分解为哪三个化合物。</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20231207102045578.png" alt="image-20231207102045578"></p><p>E总是可以分解为C和D，当然也可以分解为A和D，但是一部分A和D可以生成更低的C，说明</p><p>E—A+D 并不完全，后面还有  A+D—–C+D，因此最终必然分解为C+D</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20231207102428536.png" alt="image-20231207102428536"></p><p>对于三元，F总能分解为A+B+D ，也可分解为A+B+C，但是A+B+C会合成D（因为D总是由A、B、C组成，道理和下面的解释一样），最终还是直接分解为D的能量最稳定。</p><p>为什么F总能分解为A+B+D? ： 因为F总能由A和H组成，而H总能由B+D组成，最终，F总能由B+D组成。</p><p>四元同理，四元的四面体内的不稳定化合物总可以先分解为三角形，再分解为线，再分解为点。</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20231207102751346.png" alt="image-20231207102751346"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h3 id=&quot;1-properties&quot;&gt;&lt;a href=&quot;#1-properties&quot; class=&quot;headerlink&quot; title=&quot;1. properties&quot;&gt;&lt;/a&gt;1. properties&lt;/h3&gt;&lt;h4 id=&quot;1-原子&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="绘图" scheme="http://example.com/categories/%E7%BB%98%E5%9B%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>纳米随机热力学暑期讲习班</title>
    <link href="http://example.com/2024/05/25/%E7%BA%B3%E7%B1%B3%E9%9A%8F%E6%9C%BA%E7%83%AD%E5%8A%9B%E5%AD%A6%E6%9A%91%E6%9C%9F%E8%AE%B2%E4%B9%A0%E7%8F%AD%202023/"/>
    <id>http://example.com/2024/05/25/%E7%BA%B3%E7%B1%B3%E9%9A%8F%E6%9C%BA%E7%83%AD%E5%8A%9B%E5%AD%A6%E6%9A%91%E6%9C%9F%E8%AE%B2%E4%B9%A0%E7%8F%AD%202023/</id>
    <published>2024-05-25T14:01:20.379Z</published>
    <updated>2024-05-25T12:00:10.278Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="1-赵鸿-第一讲-从微观到宏观"><a href="#1-赵鸿-第一讲-从微观到宏观" class="headerlink" title="1. 赵鸿 第一讲 从微观到宏观"></a>1. 赵鸿 第一讲 从微观到宏观</h1><ol><li><img src="/./../../%E5%9B%BE%E7%89%87/image-20230709091502519.png" alt="image-20230709091502519"></li></ol><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230709091756544.png" alt="image-20230709091756544"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230709091911808.png" alt="image-20230709091911808"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230709092043041.png" alt="image-20230709092043041"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230709092150325.png" alt="image-20230709092150325"></p><p>关于结构与力  61个基本砖块（含反物质） 通过作用传播子连接起来 （光子是电磁相互作用子，胶子是强相互作用传播子，z+w是弱相互作用</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230709092530855.png" alt="image-20230709092530855"></p><p>质量是什么 （希格斯粒子） 引力子</p><p>物理学大厦的基底</p><p>杨-米尔斯理论</p><p>统一弱电 </p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230709093413901.png" alt="image-20230709093413901"></p><p>在基本粒子上是对称的，在宏观尺度上，是对称破缺的。晶体是对称破缺的产物</p><p>框架之外的东西 ：暗物质与暗能量</p><p>超弦-拓宽这张表格</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230709093635774.png" alt="image-20230709093635774"></p><p>物理学是关于物质与物质的运动的问题（结构上是框架的搭建）</p><p>统计物理是关于运动的理论</p><p>&#x3D;&#x3D;密度泛函理论及其现在衍生出的凝聚态物理来源于混沌与无序，来源于无法精确求解，其全貌隐含着暗线，即统计物理、热力学等等。复杂系统的理论在做另一件事，不把复杂系统的理论应用到对凝聚态计算物理的研究中是完全错误的&#x3D;&#x3D;</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230709094635217.png" alt="image-20230709094635217"></p><p>统计是统计 统计物理是物理的</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230709094852376.png" alt="image-20230709094852376"></p><blockquote><p>很像一个分子动力学中的温度分布，服从右侧的分布 有了分布，统计就做完了。如何做这样一个统计分布呢（x-p)    是的！没有问题，服从正态分布，为什么和经验值有关系呢</p><p>能量的波动是否符合统计分布 应当符合</p></blockquote><blockquote><p> 是否可以构建一个结构信息的宏观变量</p></blockquote><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230709095340997.png" alt="image-20230709095340997"></p><p>N&#x3D;无穷，涨落一定为零</p><p>N有限时没有规律，但随着N增加，宏观变量就趋近常数，这就是涌现。</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230709100133951.png" alt="image-20230709100133951"></p><blockquote><p>如何用到粒子跳跃上</p></blockquote><blockquote><p>&#x3D;&#x3D;粒子跳跃事件随时间的涨落，随着系统增加，单位时间内观察到的跳跃次数应该是稳定的，但是在小体系下，单位时间应该是有涨落的。单位时间的跳跃次数的分布是服从什么分布&#x3D;&#x3D;</p><p>跳跃次数的微观量是什么</p><p>当跳跃之间存在长程关联时，统计物理不可用？。短程关联可以归到统计物理</p></blockquote><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230709101641721.png" alt="image-20230709101641721"></p><p>莱维飞行和随机行走的分布函数是不同的。如果r2不是2Dt，那么就是有莱维飞行。</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230709102923166.png" alt="image-20230709102923166"></p><p>漂亮的问题谁都会问，笨的，不是问题的问题问出来才有意思，做新的东西总有可能出错的。很喜欢统计物理的氛围</p><p>统计物理的数据是由动力学（经典动力学、量子动力学）产生的且受&#x3D;&#x3D;附加物理限制的&#x3D;&#x3D;</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230709104239644.png" alt="image-20230709104239644"></p><p>解上面的式子得出不同的解</p><p>不同的系统状态分布</p><p>正则系综中，Es对应多个微观状态，</p><blockquote><p>如何解出不同系综的分布</p></blockquote><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230709104844506.png" alt="image-20230709104844506"></p><p>得到p之后，物理量A的系综平均值就得到了</p><blockquote><p>时间平均&#x3D;空间平均，也就是现在算长时间的原因，通过足够长的时间来消除涨落，是否能做到？布朗运动。涨落与扩散系数的线性度的关系。</p></blockquote><p>遍历似乎很重要</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230709110342340.png" alt="image-20230709110342340"></p><p>热力学关系：热力学量之间的制约关系</p><p>热力学的更深层次的含义是统计物理</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230709110900149.png" alt="image-20230709110900149"></p><p>推论：温度不是一个恒量，这是N有限导致的。涨落是有限N下的行为。</p><p>能量的涨落是固定的,与N相关</p><blockquote><p>所有的量的涨落都是N的函数，所有的涨落来源于N</p><p>但是热力学量是没有涨落的，因为热力学对应大的系统</p></blockquote><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230709112701113.png" alt="image-20230709112701113"></p><p>刘维方程是动力学方程</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230709113516869.png" alt="image-20230709113516869"></p><p>输运过程中动理学经常使用</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230709113951506.png" alt="image-20230709113951506"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230709114119297.png" alt="image-20230709114119297"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230709114508765.png" alt="image-20230709114508765"></p><p>系综是麦克斯韦-玻尔兹曼统计得到的。考虑相互作用的气体</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230709115020763.png" alt="image-20230709115020763"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230709115515557.png" alt="image-20230709115515557"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230710090143790.png" alt="image-20230710090143790"></p><p>u和gamma空间的不同</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230710091729907.png" alt="image-20230710091729907"></p><p>动力学 统计物理 热力学 递进关系 是有问题的 关于运动的理论 </p><p>统计物理是冒险、辛苦但是未来回报可能性大的</p><p>趋势是大团队、大工程、企业化</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230710092834620.png" alt="image-20230710092834620"></p><p>基本问题！</p><p>统计物理的基本物理是动力学</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230710093609412.png" alt="image-20230710093609412"></p><p>![image-20230710095441424](.&#x2F;..&#x2F;..&#x2F;图片&#x2F;image-20230710095441424.png</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230710095503059.png" alt="image-20230710095503059"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230710095619594.png" alt="image-20230710095619594"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230710095651272.png" alt="image-20230710095651272"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230710100031322.png" alt="image-20230710100031322"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230710102310135.png" alt="image-20230710102310135"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230710110804265.png" alt="image-20230710110804265"></p><h1 id="2-纳米随机热力学的数学理论"><a href="#2-纳米随机热力学的数学理论" class="headerlink" title="2. 纳米随机热力学的数学理论"></a>2. 纳米随机热力学的数学理论</h1><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230711090029467.png" alt="image-20230711090029467"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230711090506672.png" alt="image-20230711090506672"></p><p>假设+逻辑推理  结论</p><p>真理 不是对或错，而是假设之下包含着这些对和错</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;1-赵鸿-第一讲-从微观到宏观&quot;&gt;&lt;a href=&quot;#1-赵鸿-第一讲-从微观到宏观&quot; class=&quot;headerlink&quot; title=&quot;1. 赵鸿 第一讲 从微观到宏观&quot;&gt;&lt;/a&gt;1. 赵鸿 第一讲 从微观到宏观&lt;/h1&gt;&lt;ol&gt;
&lt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>画相图</title>
    <link href="http://example.com/2024/05/25/%E7%94%BB%E7%9B%B8%E5%9B%BE/"/>
    <id>http://example.com/2024/05/25/%E7%94%BB%E7%9B%B8%E5%9B%BE/</id>
    <published>2024-05-25T14:01:20.378Z</published>
    <updated>2024-05-25T12:00:20.594Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="1-绘图脚本（相图、巨势相图）"><a href="#1-绘图脚本（相图、巨势相图）" class="headerlink" title="1.绘图脚本（相图、巨势相图）"></a>1.绘图脚本（相图、巨势相图）</h1><h2 id="1-相图-新的"><a href="#1-相图-新的" class="headerlink" title="1. 相图-新的"></a>1. 相图-新的</h2><h3 id="1-代码"><a href="#1-代码" class="headerlink" title="1.代码"></a>1.代码</h3><p>已经修正能量，注意关掉翻墙软件，需要安装新的API</p><p><a href="https://docs.materialsproject.org/methodology/materials-methodology/thermodynamic-stability/phase-diagrams-pds">https://docs.materialsproject.org/methodology/materials-methodology/thermodynamic-stability/phase-diagrams-pds</a></p><pre><code class="python">from mp_api.client import MPResterfrom pymatgen.core import compositionfrom pymatgen.io.vasp.outputs import Vasprunfrom pymatgen.analysis.phase_diagram import PhaseDiagram, PDPlotter, PDEntryfrom pymatgen.entries.compatibility import MaterialsProjectCompatibilitympr=MPRester(&quot;5BhZJctjosrFpkuE6qErpu85dT4gw4VZ&quot;)#entries = mpr.get_entries_in_chemsys(elements=[&quot;Li&quot;, &quot;Fe&quot;, &quot;O&quot;])#entries = mpr.materials.tasks.get_data_by_id(&quot;mp-2352&quot;)mp_entries = mpr.get_entries_in_chemsys(elements=[&quot;Na&quot;,&quot;Y&quot;,&quot;Si&quot;,&quot;O&quot;],additional_criteria=&#123;&quot;thermo_types&quot;: [&quot;GGA_GGA+U&quot;]&#125;) vasprun=Vasprun(&#39;vasprun.xml&#39;)entry_vasp = vasprun.get_computed_entry(inc_structure=True)compatibility = MaterialsProjectCompatibility()entry_from_vasp = compatibility.process_entry(entry_vasp)mp_entries.append(entry_from_vasp)pd=PhaseDiagram(mp_entries)stable_entries=list(pd.stable_entries)stable_entries.append(entry_from_vasp)pd2=PhaseDiagram(stable_entries)#print(stable_entries)print(stable_entries[-1])print(pd2.get_e_above_hull(stable_entries[-1]))plotter = PDPlotter(pd2)plotter.show()plotter.write_image(&#39;pd.png&#39;, image_format=&#39;png&#39;)###下面是拓展#可以看出四元相图中重合的线，关掉了颜色显示a = plotter.get_plot(fill=False)a.show()https://pymatgen.org/pymatgen.analysis.html#pymatgen.analysis.phase_diagram.PhaseDiagramprint(pd2.dim)print(pd2.qhull_entries) 给出hull上所有化合物print(pd2.qhull_data) 给出构建相图的数据，比实际相图维度少一维度，以三元A B C为例 知道A:B A:C那么B:C自然确定了，不需要增加维度print(pd2.all_entries_hulldata)   给出hull上的所有坐标和大小print(pd2.get_e_above_hull)  输出所有稳定的化合物print(pd2.computed_data) #包括facets(连接方式)  #simplexes(所有的形的坐标，三维相图里的形是二维的三角形，每个点都是坐标，坐标只有两个是因为只需要两个就能确定三角相图中一个点的位置) #all_entries(所有的化合物) #qhull_data(注意不能直接复制下来做相图，因为比实际多一行带2的，去掉这一行才可以。用于构建hull的数据，比实际相图维度少一维度，以三元A B C为例 知道A:B A:C那么B:C自然确定了，不需要增加) 多了一个1/3，1/3，2 多的应该是有用的，可能是用来做标定，实际上用不到，在算facets的时候没有考虑这一行。用自己下面的脚本才比较合适#确定的方法：1-x-y #material project自己画的图是顺时针坐标，给出了x和z，y没给出，需要1-x-z,但是origin是逆时针画图,需要双击画出来的图，点三元图，改成顺时针，然后双击图，调出图层属性界面，在显示部分，勾选输在坐标轴前面#dim(维度) #el_refs(hull的顶点)  #qhull_entries(用于构建hull/hull上的化合物)#print([entrya.composition.reduced_formula for entrya in pd2.qhull_entries])输出用于构建相图的简化的化学式#输出带某个化合物的组合，用于构建化合物相图import numpy as npprint(pd2.facets)  输出所有连接方式  每个数字与qhull.entries中的对应位置对应matrix2 = np.vstack(pd2.facets)rows_with_12 = matrix2[(matrix2 == 12).any(axis=1)]#绘制化合物相图from pymatgen.analysis.phase_diagram import PhaseDiagram, PDPlotter, PDEntry,CompoundPhaseDiagramfrom pymatgen.core import CompositionSiO2 = Composition(&quot;SiO2&quot;)Y2O3 = Composition(&quot;Y2O3&quot;)Na2O = Composition(&quot;Na2O&quot;)pd3=CompoundPhaseDiagram(stable_entries,[SiO2,Y2O3,Na2O])plotterb=PDPlotter(pd3)plotterb.show()#给出各个化合物的配比方式 注意是在stable_entries的基础上进行计算的，这样得到的都是稳定的#自动排除了那些不在面上的化合物，相当于一个提取，得到了转换后的化合物ppp,ddd=pd3.transform_entries(stable_entries,[SiO2,Y2O3,Na2O])print(ppp) #可以显示出实际的配分数#给出各个化合物的配比方式-更加直接一点import numpy as np#elements_fomula = sorted(&#123;els for e in ppp for els in e.composition.elements&#125;)#elements_fomula=list(elements_fomula)elements_fomula=pd3.elementsdata_fomula = np.array([[e.composition.get_atomic_fraction(el) for el in elements_fomula] for e in ppp])print(data_fomula)np.savetxt(&#39;fra.dat&#39;,data_fomula, delimiter=&#39;\t&#39;, fmt=&#39;%d&#39;)#data = np.array([e.composition.get_atomic_fraction(el) for el in elements] + [e.energy_per_atom] for e in min_entries])print(ppp)print([aa.composition for aa in ppp])</code></pre><h3 id="2-绘制三元-赝三元相图代码"><a href="#2-绘制三元-赝三元相图代码" class="headerlink" title="2. 绘制三元&#x2F;赝三元相图代码"></a>2. 绘制三元&#x2F;赝三元相图代码</h3><pre><code class="python">plotter = PDPlotter(pd2)plotter.show()plotter.write_image(&#39;pd.png&#39;, image_format=&#39;png&#39;)</code></pre><p>以Y-O为顶点和以Y-YSi为顶点，得到的Y5Si3的线段是不同的，赝三元相图的图像里线段不能直接比来获得比例</p><p><img src="/./../%E5%9B%BE%E7%89%87/d82b7383013d9a8faa68b0a453108e3.jpg"></p><h3 id="3-化合物相图的输出"><a href="#3-化合物相图的输出" class="headerlink" title="3. 化合物相图的输出"></a>3. 化合物相图的输出</h3><p><img src="/./../%E5%9B%BE%E7%89%87/image-20231208093545191.png" alt="image-20231208093545191"></p><p>输出的化合物相图的数据，以虚拟物种的方式出现，其中，上面是每个化合物，虚拟物种xf0、xh0、xg0后面的数字代表需要的组合</p><h3 id="4-pymatgen中的代码结构"><a href="#4-pymatgen中的代码结构" class="headerlink" title="4.pymatgen中的代码结构"></a>4.pymatgen中的代码结构</h3><h4 id="1-化学式相图"><a href="#1-化学式相图" class="headerlink" title="1.化学式相图"></a>1.化学式相图</h4><p>本质上是重构entry，把化合物变成单元的</p><pre><code class="python">class CompoundPhaseDiagram(PhaseDiagram):    #化学式相图的类是继承自phaseDiagram,继承的意思是子类可以使用父类的所有属性和方法    def __init__(self, entries, terminal_compositions, normalize_terminal_compositions=True):        self.original_entries = entries        self.terminal_compositions = terminal_compositions        self.normalize_terminals = normalize_terminal_compositions        p_entries, species_mapping = self.transform_entries(entries, terminal_compositions)        self.species_mapping = species_mapping        super().__init__(p_entries, elements=species_mapping.values())        #super()是用子类的这两个参数去实例化phasediagram 这两个参数分别对应虚拟化的化合物分数坐标和顶点的虚拟化物种</code></pre><h4 id="2-相图"><a href="#2-相图" class="headerlink" title="2. 相图"></a>2. 相图</h4><pre><code class="python">class PhaseDiagram(MSONable):    #phasediagram继承MSONable，这个类可以用来做json的数据输入输出    formation_energy_tol = 1e-11    numerical_tol = 1e-8    def __init__(        self,        entries: Sequence[PDEntry] | set[PDEntry],        elements: Sequence[Element] = (),        *,        computed_data: dict[str, Any] | None = None,    ) -&gt; None:        #computed_data接受一个字典或者none。如果提供的是一个字典，它可能包含了一些预先计算好的数据，如相图中的临界点、相边界等        #-none表示构造函数没有返回值        self.elements = elements        self.entries = entries        if computed_data is None:            computed_data = self._compute()            #计算得到相图的数据</code></pre><pre><code class="python">def _compute(self) -&gt; dict[str, Any]:        if self.elements == ():            self.elements = sorted(&#123;els for e in self.entries for els in e.elements&#125;)            #找出所有的元素，四种、三种、两种。。。        elements = list(self.elements)        dim = len(elements)        entries = sorted(self.entries, key=lambda e: e.composition.reduced_composition)        el_refs: dict[Element, PDEntry] = &#123;&#125;        min_entries: list[PDEntry] = []        all_entries: list[PDEntry] = []        for composition, group_iter in itertools.groupby(entries, key=lambda e: e.composition.reduced_composition):            group = list(group_iter)            min_entry = min(group, key=lambda e: e.energy_per_atom)            if composition.is_element:                el_refs[composition.elements[0]] = min_entry            min_entries.append(min_entry)            all_entries.extend(group)            #对entries进行分类，找到顶点、和各个组成中能量最低的entry        if missing := set(elements) - set(el_refs):            raise ValueError(f&quot;Missing terminal entries for elements &#123;sorted(map(str, missing))&#125;&quot;)        if extra := set(el_refs) - set(elements):            raise ValueError(f&quot;There are more terminal elements than dimensions: &#123;sorted(map(str, extra))&#125;&quot;)        data = np.array(            [[e.composition.get_atomic_fraction(el) for el in elements] + [e.energy_per_atom] for e in min_entries]        )        #用于绘图的坐标数据        #前三列是分数的坐标，最后一列是能量，后面dot一下就计算出来每个entry相对原点的形成能        # Use only entries with negative formation energy        vec = [el_refs[el].energy_per_atom for el in elements] + [-1]        #-1直接拼接在后面，点乘后相当于直接 -E        form_e = -np.dot(data, vec)        idx = np.where(form_e &lt; -PhaseDiagram.formation_energy_tol)[0].tolist()        #得到        # Add the elemental references        idx.extend([min_entries.index(el) for el in el_refs.values()])        #extend 把list2中的元素一个接一个添加到list1        #把min_entries对应顶点位置的坐标的索引增加到idx        qhull_entries = [min_entries[i] for i in idx]        #所有hull上的entries        qhull_data = data[idx][:, 1:]                # Add an extra point to enforce full dimensionality.        # This point will be present in all upper hull facets.        extra_point = np.zeros(dim) + 1 / dim        #创建一个一行三列的向量        extra_point[-1] = np.max(qhull_data) + 1        qhull_data = np.concatenate([qhull_data, [extra_point]], axis=0)        #增加了一行                 if dim == 1:            facets = [qhull_data.argmin(axis=0)]        else:            facets = get_facets(qhull_data)            final_facets = []            for facet in facets:                # Skip facets that include the extra point                if max(facet) == len(qhull_data) - 1:                    continue                    #去除增加的行的影响，不清楚为什么加一行，可能前面有用                m = qhull_data[facet]                m[:, -1] = 1                if abs(np.linalg.det(m)) &gt; 1e-14:                    final_facets.append(facet)            facets = final_facets        simplexes = [Simplex(qhull_data[f, :-1]) for f in facets]        #用于找到不同三角形的坐标        self.elements = elements        return &#123;            &quot;facets&quot;: facets,            &quot;simplexes&quot;: simplexes,            &quot;all_entries&quot;: all_entries,            &quot;qhull_data&quot;: qhull_data,            &quot;dim&quot;: dim,            # Dictionary with Element keys is not JSON-serializable            &quot;el_refs&quot;: list(el_refs.items()),            &quot;qhull_entries&quot;: qhull_entries,        &#125;</code></pre><p>computed_data</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20231208101440132.png" alt="image-20231208101440132"></p><h2 id="2-老的，似乎不能用了-不能从materials-project数据库中提取数据了"><a href="#2-老的，似乎不能用了-不能从materials-project数据库中提取数据了" class="headerlink" title="2. 老的，似乎不能用了 (不能从materials project数据库中提取数据了)"></a>2. 老的，似乎不能用了 (不能从materials project数据库中提取数据了)</h2><pre><code class="python">from pymatgen.io.vasp.outputs import Vasprunimport pandas as pdfrom pymatgen.ext.matproj import MPResterfrom pymatgen.analysis.phase_diagram import PhaseDiagram, PDPlotter, PDEntryfrom pymatgen.entries.compatibility import MaterialsProjectCompatibilityvasprun=Vasprun(&#39;vasprun.xml&#39;)entry = vasprun.get_computed_entry(inc_structure=True)compatibility = MaterialsProjectCompatibility()entry = compatibility.process_entry(entry)a=MPRester(&#39;BhgyCJsKOOA3cRIi&#39;)mp_entries=a.get_entries_in_chemsys([&#39;K&#39;,&#39;Y&#39;,&#39;Si&#39;,&#39;O&#39;])mp_entries.append(entry)phd=PhaseDiagram(mp_entries)stable_entries=list(phd.stable_entries)stable_entries.append(entry)phd2=PhaseDiagram(stable_entries)#print(stable_entries)print(stable_entries[-1])print(phd2.get_e_above_hull(stable_entries[-1]))plotter = PDPlotter(phd2)plotter.show()</code></pre><h2 id="3-从现有数据的-dat文件读取然后绘制相图"><a href="#3-从现有数据的-dat文件读取然后绘制相图" class="headerlink" title="3. 从现有数据的.dat文件读取然后绘制相图"></a>3. 从现有数据的.dat文件读取然后绘制相图</h2><p>（&#x2F;work&#x2F;home&#x2F;liz&#x2F;workspace&#x2F;1-system-MD&#x2F;2-Li5YSi4O12&#x2F;6phase&#x2F;LYSO）</p><pre><code class="python">from pymatgen.analysis.phase_diagram import *from pymatgen.core.periodic_table import Element, DummySpeciefrom pymatgen.core.composition import Compositionentries = []with open(&#39;lyso.dat&#39;) as fr :    for line in fr :      comp, ene = line.split(&#39;,&#39;)      entries.append(PDEntry(Composition(comp), float(ene)))pd = PhaseDiagram(entries)#stable_formulas = [ent.name for ent in pd.stable_entries]entry=PDEntry(composition=&#39;Li30Y6Si24O72&#39;,energy=-937.044768)stable_entries=list(pd.stable_entries)#print(pd.stable_entries)stable_entries.append(entry)phd=PhaseDiagram(stable_entries)#plotter=PDPlotter(phd,show_unstable=True)#plotter.show()print(stable_entries[-1])print(phd.get_e_above_hull(stable_entries[-1]))#for formula in stable_formulas:#        print (formula)#for e in entries:#        ehull = pd.get_e_above_hull(e)#        print (e.composition, ehull)#plotter = PDPlotter(pd)#plotter.show()#plotter.write_image(&#39;pd.png&#39;, image_format=&#39;png&#39;)#entries.append(PDEntry(Composition(&#39;Li2MgH15&#39;),float(3.1)))#pd.get_e_above_hull(entries[9])#pd.get_all_chempots(Composition(&#39;MgH16&#39;)) 一个化合物中所有元素的化学势#pd.get_chempot_range_map([Element(&#39;Li&#39;)])  每个化合物某种元素的化学势范围#get_composition_chempots(comp)print(phd.get_decomp_and_e_above_hull(stable_entries[-1]))</code></pre><h2 id="4-巨势相图"><a href="#4-巨势相图" class="headerlink" title="4. 巨势相图"></a>4. 巨势相图</h2><pre><code class="python">from pymatgen.io.vasp.outputs import Vasprunimport pandas as pdfrom pymatgen.ext.matproj import MPResterfrom pymatgen.analysis.phase_diagram import PhaseDiagram, PDPlotter, PDEntryfrom pymatgen.entries.compatibility import MaterialsProjectCompatibilityfrom pymatgen.analysis.phase_diagram import *from pymatgen.core.periodic_table import Element, DummySpeciefrom pymatgen.core.composition import Compositionvasprun=Vasprun(&#39;vasprun.xml&#39;)entry = vasprun.get_computed_entry(inc_structure=True)compatibility = MaterialsProjectCompatibility()entry = compatibility.process_entry(entry)a=MPRester(&#39;BhgyCJsKOOA3cRIi&#39;)mp_entries=a.get_entries_in_chemsys([&#39;Na&#39;,&#39;Y&#39;,&#39;Si&#39;,&#39;O&#39;])mp_entries.append(entry)phd=PhaseDiagram(mp_entries)li_entries = [e for e in mp_entries if e.composition.reduced_formula == &quot;Li&quot;]uli0 = min(li_entries, key=lambda e: e.energy_per_atom).energy_per_atomel_profile = phd.get_element_profile(Element(&quot;Li&quot;), mp_entries[-1].composition)for i, d in enumerate(el_profile):    voltage = -(d[&quot;chempot&quot;] - uli0)    print(&quot;Voltage: %s V&quot; % voltage)    print(d[&quot;reaction&quot;])    print(&quot;&quot;)</code></pre><p>新的</p><pre><code class="python">from mp_api.client import MPResterfrom pymatgen.core import compositionfrom pymatgen.io.vasp.outputs import Vasprunfrom pymatgen.analysis.phase_diagram import PhaseDiagram, PDPlotter, PDEntryfrom pymatgen.entries.compatibility import MaterialsProjectCompatibilityfrom pymatgen.core.periodic_table import Element, DummySpeciempr=MPRester(&quot;5BhZJctjosrFpkuE6qErpu85dT4gw4VZ&quot;)mp_entries = mpr.get_entries_in_chemsys(elements=[&quot;Na&quot;,&quot;Y&quot;,&quot;Si&quot;,&quot;O&quot;],additional_criteria=&#123;&quot;thermo_types&quot;: [&quot;GGA_GGA+U&quot;]&#125;)vasprun=Vasprun(&#39;Na.xml&#39;)entry_vasp = vasprun.get_computed_entry(inc_structure=True)compatibility = MaterialsProjectCompatibility()entry_from_vasp = compatibility.process_entry(entry_vasp)mp_entries.append(entry_from_vasp)phd=PhaseDiagram(mp_entries)na_entries = [e for e in mp_entries if e.composition.reduced_formula == &quot;Na&quot;]una0 = min(na_entries, key=lambda e: e.energy_per_atom).energy_per_atomprint(mp_entries[-1])el_profile = phd.get_element_profile(Element(&quot;Na&quot;), mp_entries[-1].composition)for i, d in enumerate(el_profile):    voltage = -(d[&quot;chempot&quot;] - una0)    print(&quot;Voltage: %s V&quot; % voltage)    print(d[&quot;reaction&quot;])    print(&quot;&quot;)</code></pre><h1 id="2-计算化合物的分解"><a href="#2-计算化合物的分解" class="headerlink" title="2. 计算化合物的分解"></a>2. 计算化合物的分解</h1><pre><code class="python">print(phd.get_decomp_and_e_above_hull(stable_entries[-1]))可以给出分解的路径，进而求出结合能（和e_above_hull是不一样的）也可以给出结合能，用里面的函数</code></pre><p>路径 &#x2F;work&#x2F;home&#x2F;liz&#x2F;workspace&#x2F;1-system-MD&#x2F;2-Li5YSi4O12&#x2F;6phase&#x2F;LYSO</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20231013111011468.png" alt="image-20231013111011468"></p><p><img src="/./../%E5%9B%BE%E7%89%87/a.jpg" alt="a"></p><h1 id="2-相图解释-（三元三角、四元四面体）"><a href="#2-相图解释-（三元三角、四元四面体）" class="headerlink" title="2. 相图解释 （三元三角、四元四面体）"></a>2. 相图解释 （三元三角、四元四面体）</h1><h2 id="1-相图的理解"><a href="#1-相图的理解" class="headerlink" title="1.相图的理解"></a>1.相图的理解</h2><p>x y z z </p><p>四面体只需要四个顶点</p><p>三维相图</p><p>&#x3D;&#x3D;逆时针&#x3D;&#x3D;</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20231208204343051.png" alt="image-20231208204343051"></p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20231206211650444.png" alt="image-20231206211650444"></p><p>#print([entrya.composition.reduced_formula for entrya in pd2.qhull_entries]) </p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20231206211706137.png" alt="image-20231206211706137"></p><p>#print(pd2.facets)  输出所有连接方式 (标号是上面的顺序，从0开始 )     pymatgen</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20231206211658347.png" alt="image-20231206211658347"></p><p>四元</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20231206213332475.png" alt="image-20231206213332475"></p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20231206213336951.png" alt="image-20231206213336951"><br><img src="/./../%E5%9B%BE%E7%89%87/image-20231206213344510.png" alt="image-20231206213344510"></p><p>目的是把块分成区域，每个区域不再能分配</p><p>三元相图是由一系列的小三元相图构图的，而小三元相图是由二元相图的边构成的。同理，四元相图由小四元四面体组成，而小四元四面体的边是二元相图，一个面是一个三元相图。</p><p>&#x3D;&#x3D;三元比二元多出来的特征在于可以有一些只能分解为三元的化合物，其他的稳定化合物完全可以以化合物为顶点做一个二元相图。而四元多出来的特征在于可以有一些只能分解为四个组分的化合物（在四面体中间）,要表示四元相图中的稳定结构，完全可以用三元相图、或者二元相图表示。&#x3D;&#x3D;</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20231207101533459.png" alt="image-20231207101533459"></p><h2 id="1-关于分解"><a href="#1-关于分解" class="headerlink" title="1.关于分解"></a>1.关于分解</h2><p>&#x3D;&#x3D;二元相图的横坐标是 y&#x2F;(x+y) ，y占据的百分数，二元的点本质上纵坐标都可以设置为在线上，只不过是能量的差别设置出来了高度，落在哪条线上就会分解为线的两端，三元落在哪个三角里就会分解为哪三个化合物，四元落在哪个四面体内就会分解为哪四个化合物&#x3D;&#x3D;</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20231207102045578.png" alt="image-20231207102045578"></p><p>E总是可以分解为C和D，当然也可以分解为A和D，但是一部分A和D可以生成更低的C，说明</p><p>E—A+D 并不完全，后面还有  A+D—–C+D，因此最终必然分解为C+D</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20231207102428536.png" alt="image-20231207102428536"></p><p>对于三元，F总能分解为A+B+D ，也可分解为A+B+C，但是A+B+C会合成D（因为D总是由A、B、C组成，道理和下面的解释一样），最终还是直接分解为D的能量最稳定。</p><p>为什么F总能分解为A+B+D? ： 因为F总能由A和H组成，而H总能由B+D组成，最终，F总能由A+B+D组成。</p><p>四元同理，四元的四面体内的不稳定化合物总可以先分解为三角形，再分解为线，再分解为点。</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20231207102751346.png" alt="image-20231207102751346"></p><h1 id="3-计算化合物的分解"><a href="#3-计算化合物的分解" class="headerlink" title="3. 计算化合物的分解"></a>3. 计算化合物的分解</h1><pre><code class="python">print(phd.get_decomp_and_e_above_hull(stable_entries[-1]))可以给出分解的路径，进而求出结合能（和e_above_hull是不一样的）也可以给出结合能，用里面的函数</code></pre><p>路径 &#x2F;work&#x2F;home&#x2F;liz&#x2F;workspace&#x2F;1-system-MD&#x2F;2-Li5YSi4O12&#x2F;6phase&#x2F;LYSO</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20231013111011468.png" alt="image-20231013111011468"></p><p><img src="/./../%E5%9B%BE%E7%89%87/a.jpg" alt="a"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;1-绘图脚本（相图、巨势相图）&quot;&gt;&lt;a href=&quot;#1-绘图脚本（相图、巨势相图）&quot; class=&quot;headerlink&quot; title=&quot;1.绘图脚本（相图、巨势相图）&quot;&gt;&lt;/a&gt;1.绘图脚本（相图、巨势相图）&lt;/h1&gt;&lt;h2 id=&quot;</summary>
      
    
    
    
    <category term="模拟方法" scheme="http://example.com/categories/%E6%A8%A1%E6%8B%9F%E6%96%B9%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>系统环境+软件安装</title>
    <link href="http://example.com/2024/05/25/%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83+%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    <id>http://example.com/2024/05/25/%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83+%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/</id>
    <published>2024-05-25T14:01:20.378Z</published>
    <updated>2024-05-25T12:00:16.414Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="1-什么是linux系统中的环境"><a href="#1-什么是linux系统中的环境" class="headerlink" title="1.什么是linux系统中的环境"></a>1.什么是linux系统中的环境</h1><h1 id="2-如何使用anaconda"><a href="#2-如何使用anaconda" class="headerlink" title="2. 如何使用anaconda"></a>2. 如何使用anaconda</h1><p>方便可视化，所有的包都以图形的的形式展现，下载的包都在d盘的下载目录</p><ol><li><p>更改powershell的初始路径：更改下图的起始位置</p></li><li><p><img src="/./../%E5%9B%BE%E7%89%87/image-20231225195806411.png" alt="image-20231225195806411"></p></li><li><p>更改jupyter的初始路径：</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20231225195904473.png" alt="image-20231225195904473"></p></li></ol><p>更改属性中目标位置最后的路径</p><ol start="4"><li><p>安装origin提示试用期已过 解决方法：更改系统时间</p></li><li><p><a href="https://blog.csdn.net/dengjin20104042056/article/details/131502937">【Tools】Xshell中中文字体和英语字体大小不一致问题_xshell字体一大一小-CSDN博客</a></p></li></ol><h1 id="3-配置ssh"><a href="#3-配置ssh" class="headerlink" title="3. 配置ssh"></a>3. 配置ssh</h1><p>[快速实战派：ssh公钥登录远程服务器配置_配置公钥私钥进行远程登录-CSDN博客](<a href="https://blog.csdn.net/u011291072/article/details/119298179#:~:text=%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%8C%E5%85%A8%E8%BF%87%E7%A8%8B%E6%9C%89%E4%B8%89%E6%AD%A5%EF%BC%8C%E7%AC%AC%E4%B8%80%E6%AD%A5%E6%98%AF%E8%BE%93%E5%85%A5%E5%85%AC%E9%92%A5%E7%A7%81%E9%92%A5%E7%9A%84%E4%BF%9D%E5%AD%98%E8%B7%AF%E5%BE%84%EF%BC%8C%E7%AC%AC%E4%BA%8C%E6%AD%A5%E5%92%8C%E7%AC%AC%E4%B8%89%E6%AD%A5%E6%98%AF%E8%AE%BE%E7%BD%AE%E7%A7%81%E9%92%A5%E5%AF%86%E7%A0%81%E5%92%8C%E7%A1%AE%E8%AE%A4%E5%AF%86%E7%A0%81%E3%80%82">https://blog.csdn.net/u011291072/article/details/119298179#:~:text=如下图，全过程有三步，第一步是输入公钥私钥的保存路径，第二步和第三步是设置私钥密码和确认密码。</a> 如果是第一次生成公钥，则直接一路回车确认就行。,公钥和私钥会自动生成到%2FUsers%2F [用户名]%2F.ssh路径下。 默认公钥文件名为id_rsa.pub，私钥文件名为id_rsa。)</p><ol><li><p>ssh-keygen </p><p>生成公钥</p></li><li><p>把.ssh&#x2F;id_rsa.pub的内容cat到服务器的~&#x2F;.ssh&#x2F;authorized_keys</p></li><li><p>可以登录</p><p>ssh -p ****  用户名@地址</p></li><li><p>可以在本地的.ssh内构造config 文件 ，使用用户名登陆</p></li></ol><p><img src="/./../%E5%9B%BE%E7%89%87/image-20231227224213521.png" alt="image-20231227224213521"></p><p><a href="https://zhuanlan.zhihu.com/p/136152982">https://zhuanlan.zhihu.com/p/136152982</a></p><p><a href="https://blog.csdn.net/yangzhuoluo/article/details/7295433">Linux 将标准输出重定向到剪切板_linux 重定向剪贴板-CSDN博客</a></p><p>[Ubuntu将标准输出重定向到剪贴板_ubuntu命令输出重定向到粘贴板-CSDN博客](<a href="https://blog.csdn.net/tcliuwenwen/article/details/103752486#:~:text=%E9%82%A3%E4%B9%88%E5%A6%82%E4%BD%95%E5%B0%86%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91%E5%88%B0%E5%89%AA%E8%B4%B4%E6%9D%BF%E6%96%B9%E4%BE%BF%E6%88%91%E4%BB%AC%E7%B2%98%E8%B4%B4%E5%91%A2%EF%BC%9F">https://blog.csdn.net/tcliuwenwen/article/details/103752486#:~:text=那么如何将标准输出重定向到剪贴板方便我们粘贴呢？</a> 1.更新源sudo apt update2.安装xsel或者xclipsudo apt install xselsudo apt,install xclip3.将输出通过管道重定向到剪贴板ls | xsel -ib %23 使用xsel…_ubuntu 剪切板)</p><h1 id="4-Powershell使用"><a href="#4-Powershell使用" class="headerlink" title="4. Powershell使用"></a>4. Powershell使用</h1><ol><li><p>ii &#x3D; Invoke-Item 对文件&#x2F;文件夹&#x2F;程序进行默认操作</p></li><li><p>cat &#x3D;Get-Content  </p><p>cat a.dat |clip  把内容复制到剪切板</p></li><li><p>Get-Alias 获取所有简化的名称</p></li><li><p>(gl).path |clip 把输出的路径放到剪切板</p></li><li><p>powershell中与.bashrc相似的文件是$profile ，初始是没有的，需要自己构建。在Set</p></li></ol><p>-Alias之前需要定义要做的事 </p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20231228152827863.png" alt="image-20231228152827863"></p><p>对应于$profile powershell中使用的是.$$profile</p><ol start="6"><li>notepad 用记事本打开文件</li></ol><p>电脑创建文件夹不显示的原因：海康智存</p><h1 id="5-安装wsl2-ubuntu与卸载"><a href="#5-安装wsl2-ubuntu与卸载" class="headerlink" title="5.安装wsl2 -ubuntu与卸载"></a>5.安装wsl2 -ubuntu与卸载</h1><p><a href="https://zhuanlan.zhihu.com/p/668630951">在Windows中安装Linux（亲测） - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/263089007">自定义WSL的安装位置，别再装到C盘啦 - 知乎 (zhihu.com)</a></p><p>cd &#x2F;mnt 从linux查看windows文件</p><p>&#x2F;&#x2F;wsl$  从windows查看linux文件</p><h1 id="6-slurm系统的sq命令"><a href="#6-slurm系统的sq命令" class="headerlink" title="6. slurm系统的sq命令"></a>6. slurm系统的sq命令</h1><pre><code class="shell">#!/bin/bash# A simple wrapper for squeue, requires bash 4.0+# by Junhao Li@TCBUSAGE()&#123;echoecho &quot;available arguments: &quot;echo &quot;   -h | --help             print the help information&quot;echo &quot;   -P | --show_partition   number (optional, default is 10)&quot;echo &quot;   -j | --job_length       number (optional, default is 20)&quot;echo &quot;   -p | --workidng_dir     number (optional, default is a full path)&quot;echo &quot;   -a | --show_account     number (optional, default is 15)&quot;echo &quot;   -A | --tcb_users&quot;echo &quot;    *                      other arguments pass to squeue&quot;echo&#125;resize &gt;&amp; /dev/null[[ -z $1 ]] &amp;&amp; squeue -u $USER -o &#39; %10i %15a %20j %8u %3t %10M %10l %4D%5C %20V %Z&#39; &amp;&amp; exit 0squeueArgs=()TCBUserList=&quot;lilu,user2,user3,user4&quot; # replace the username herewhile [[ $# -gt 0 ]]; do    case $1 in     -P | --show_partition)    showPartition=&quot;%10P&quot;    [[ &quot;$2&quot; -gt 0 ]] &amp;&amp; showPartition=&quot;%$&#123;2&#125;P&quot; &amp;&amp; shift 2 || shift 1    ;;    -U | --User_list) #user1,user2,.. or user1    if [[ -z $showTCBUsers ]]; then        if [[ &quot;$2&quot; -gt 0 ]]; then            userList=&quot;-u $&#123;2&#125;&quot;            shift 2        else            echo &quot;Warning: please give user after -u&quot;            shift 1        fi    else        echo &quot;-u could not be used with -A!&quot;        exit 1    fi        ;;    -j | --job_length)    [[ &quot;$2&quot; -gt 0 ]] &amp;&amp; jobLength=&quot;%$&#123;2&#125;j&quot; || echo &quot;Warning: please give number after -j&quot;    shift 2    ;;    -p | -wd | --working_dir)    showWorkingDir=&quot;%Z&quot;    [[ &quot;$2&quot; -gt 0 ]] &amp;&amp; showWorkingDir=&quot;%$&#123;2&#125;Z&quot; &amp;&amp; shift 2 || shift 1    ;;    -a | --show_account)    showAccount=&quot;%15a&quot;    [[ &quot;$2&quot; -gt 0 ]] &amp;&amp; showAccount=&quot;%$&#123;2&#125;a&quot; &amp;&amp; shift 2 || shift 1    ;;    -A | --tcb_users)    if [[ ! -z userList ]]; then        showTCBUsers=&quot;-u $TCBUserList&quot;     shift 1    else        echo &quot;-A could not be used with -u!&quot;        exit 1    fi    ;;    -s | --star | --start)    showStartTime=&quot;--start&quot;    shift 1    ;;    -aAp | -apA | -Aap | -Apa | -paA | -pAa)    showAccount=&quot;%15a&quot;    showTCBUsers=&quot;-u $TCBUserList&quot;    showWorkingDir=&quot;%Z&quot;    shift 1    ;;    -h | --help)    USAGE    exit 0    ;;    *) # Other argurement pass to squeue!    squeueArgs=($&#123;squeueArgs[*]&#125; $1)    shift 1    ;;    esacdone[[ -z $jobLength ]] &amp;&amp; jobLength=&quot;%20j&quot;#if [[ -z $userList ]] &amp;&amp; [[ -z $showTCBUsers ]]; then#    userToShow=&quot;-u $USER&quot;#elif [[ ! -z $userList ]]; then#    userToShow=$userList#elif [[ ! -z $showTCBUsers ]]; then#    userToShow=$showTCBUsers#fiformat=$(echo &quot; %10i $showPartition $showAccount $jobLength %8u %3t %10M %10l %4D%5C %20V $showWorkingDir&quot;)squeue $userToShow -o &quot;$format&quot; $showStartTime $&#123;squeueArgs[@]&#125;</code></pre><h1 id="7-windows11的问题"><a href="#7-windows11的问题" class="headerlink" title="7.windows11的问题"></a>7.windows11的问题</h1><p><a href="https://answers.microsoft.com/zh-hans/windows/forum/all/win11%E7%B3%BB%E7%BB%9F/a004fdd5-db81-4486-93bc-98b76d5668d1">Win11系统 任务栏软件图标不显示 - Microsoft Community</a></p><h1 id="8-source-in-shell"><a href="#8-source-in-shell" class="headerlink" title="8.source in shell"></a>8.source in shell</h1><p><a href="https://phoenixnap.com/kb/linux-source-command">https://phoenixnap.com/kb/linux-source-command</a></p><p>source命令用于逐行运行文件中的命令，如</p><p><img src="/./../%E5%9B%BE%E7%89%87/linux-source-command-01-pass-argument-lat.png" alt="Using the source command to pass a file as an argument"></p><p>source用于把一些变量或者命令在当前环境中读取，而不需要重新开一个新的环境</p><p>source和 .的作用相同 ，是在当前进程下运行命令，会保留脚本内的变量</p><p>而.&#x2F;则是新开一个进程运行命令，运行结束进程关闭，不会保留下变量</p><p><a href="https://medium.com/@sdbutalla/what-really-is-the-difference-between-the-source-and-dot-commands-in-bash-zshell-736896bc26a3">https://medium.com/@sdbutalla/what-really-is-the-difference-between-the-source-and-dot-commands-in-bash-zshell-736896bc26a3</a></p><p>source 和 . 的区别</p><p>&#96;&#96;source can be run in any directory, provided the file is in the current directory or the path is provided, whereas . looks for the file in the paths in your <code>PATH</code> variable; if the file is not in a directory that is in your <code>PATH</code>, you must provide the full path to the file.&#96;</p><p>source可以在所有情况下适用， . 必须指定完整路径或者在环境变量下</p><pre><code class="shell">export PATH=&quot;/work/home/liz/software/vtst/vtstscripts-972:$PATH&quot;</code></pre><p>添加目录到环境变量</p><p>MPI :并行用到的库，用于在不同进程间传递信息</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;1-什么是linux系统中的环境&quot;&gt;&lt;a href=&quot;#1-什么是linux系统中的环境&quot; class=&quot;headerlink&quot; title=&quot;1.什么是linux系统中的环境&quot;&gt;&lt;/a&gt;1.什么是linux系统中的环境&lt;/h1&gt;&lt;h1 </summary>
      
    
    
    
    <category term="软件安装与使用" scheme="http://example.com/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>电池计算</title>
    <link href="http://example.com/2024/05/25/%E7%94%B5%E6%B1%A0%E8%AE%A1%E7%AE%97/"/>
    <id>http://example.com/2024/05/25/%E7%94%B5%E6%B1%A0%E8%AE%A1%E7%AE%97/</id>
    <published>2024-05-25T14:01:20.377Z</published>
    <updated>2024-05-25T12:00:22.317Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="1-电池负极比容量计算"><a href="#1-电池负极比容量计算" class="headerlink" title="1.电池负极比容量计算"></a>1.<strong>电池负极比容量计算</strong></h1><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230510095231025.png" alt="image-20230510095231025"></p><p><strong>法拉第常数：96485 C&#x2F;mol</strong>  </p><p><strong>含义：1mol电子的带电量</strong> </p><p>*<em>6.02</em>10^23 * 1.6 <em>10^-19</em>*</p><h1 id="2-阿伦尼乌斯关系式辨析"><a href="#2-阿伦尼乌斯关系式辨析" class="headerlink" title="2. 阿伦尼乌斯关系式辨析"></a>2. 阿伦尼乌斯关系式辨析</h1><p>关于电导率和温度倒数的图像，目前有两种画法，分别是</p><p>$log(\sigma T)与\frac{1}{T}$和$log(\sigma)与1&#x2F;T$</p><p>根据公式</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230525105911064.png" alt="image-20230525105911064"></p><p>绘制$log(\sigma T)与$$\frac{1}{T}$的关系是正确的</p><p>为什么一些计算用$log(\sigma)$与温度倒数仍能得到不错的结论呢</p><p>$log(\sigma T)&#x3D;log(\sigma )+log(T)$,相当于在log(σ)的基础上每个点加上log(T)项，而log(T)项，在几百k的温度下，变化幅度并不大，所以能够得到相近的活化能。</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230525110449083.png" alt="image-20230525110449083"></p><p>由于更高温度log(T)带来的增幅更大， 所以log(σT)得到的活化能要比log(σ)更大</p><p>σ的值通常在1附近。</p><p>尤其对于实验，很难做特别大温度范围内的测量，通常温度幅度只有几十K，这样，使用log(σT)和log(σ)能够得到完全一致的活化能。</p><p>&#x3D;&#x3D;对于计算，由于温度变化幅度很大，因此必须要用log(σT)，对于实验，温度范围不大的话，而且与要探测的温度差距不大的话，无所谓了，当然，用log(σT)肯定是对的。&#x3D;&#x3D;</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230525111543913.png" alt="image-20230525111543913"></p><p>以这篇文章（Adv. Funct. Mater. 2022, 32, 2206036）的黑色点为例，文中给的是log(σ),得到的值为</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230525111713971.png" alt="image-20230525111713971"></p><p>使用数据重新作图后得到</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230525111741409.png" alt="image-20230525111741409"></p><h5 id="Ea-0-4248-eV-σ300-2-58-10-5-S-cm"><a href="#Ea-0-4248-eV-σ300-2-58-10-5-S-cm" class="headerlink" title="Ea &#x3D; 0.4248 eV  σ300&#x3D;2.58*10^-5 S&#x2F;cm"></a>Ea &#x3D; 0.4248 eV  σ300&#x3D;2.58*10^-5 S&#x2F;cm</h5><ol><li>首次充放电、高倍率下的低容量、充放电曲线</li></ol><h1 id="3-关于扩散系数的尺寸效应"><a href="#3-关于扩散系数的尺寸效应" class="headerlink" title="3. 关于扩散系数的尺寸效应"></a>3. 关于扩散系数的尺寸效应</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;1-电池负极比容量计算&quot;&gt;&lt;a href=&quot;#1-电池负极比容量计算&quot; class=&quot;headerlink&quot; title=&quot;1.电池负极比容量计算&quot;&gt;&lt;/a&gt;1.&lt;strong&gt;电池负极比容量计算&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;img</summary>
      
    
    
    
    <category term="模拟方法" scheme="http://example.com/categories/%E6%A8%A1%E6%8B%9F%E6%96%B9%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>电子能带理论</title>
    <link href="http://example.com/2024/05/25/%E7%94%B5%E5%AD%90%E8%83%BD%E5%B8%A6%E7%90%86%E8%AE%BA/"/>
    <id>http://example.com/2024/05/25/%E7%94%B5%E5%AD%90%E8%83%BD%E5%B8%A6%E7%90%86%E8%AE%BA/</id>
    <published>2024-05-25T14:01:20.376Z</published>
    <updated>2024-05-25T03:08:19.478Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>The Basics of Electronic Structure Theory for Periodic Systems</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;The Basics of Electronic Structure Theory for Periodic Systems&lt;/p&gt;
&lt;/blockquote&gt;
</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>机器学习与主动学习</title>
    <link href="http://example.com/2024/05/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%B8%BB%E5%8A%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2024/05/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%B8%BB%E5%8A%A8%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-05-25T14:01:20.375Z</published>
    <updated>2024-05-25T12:00:27.567Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="1-机器学习"><a href="#1-机器学习" class="headerlink" title="1.机器学习"></a>1.机器学习</h1><h2 id="1-安装-V3-版本"><a href="#1-安装-V3-版本" class="headerlink" title="1.安装:V3 版本"></a>1.安装:V3 版本</h2><p><strong>1.git clone -b v3 <a href="https://gitlab.com/Herbbb/torchdemo.git">https://gitlab.com/Herbbb/torchdemo.git</a></strong> ****</p><p><strong>2. source</strong> <strong>env_torchdemo</strong> <strong>(optional)</strong></p><p><strong>3.安装各种库,修改cmakelist&#x2F;prifix.~前几行</strong>  </p><p>  **completer:**<strong>编译器</strong> </p><p><strong>4.makedir build</strong> </p><p>  <strong>cd build</strong> </p><p>  <strong>cmake</strong>  **..&#x2F;**<strong>cmakelist</strong></p><p>  <strong>make</strong> </p><p><strong>5.编译和lammps的接口</strong></p><p>把lammps的文件包复制过来，然后sh ~.sh build 18 (18是主节点核数，可以通过lscps 查看cpus的值获得)</p><h2 id="2-训练势基本流程"><a href="#2-训练势基本流程" class="headerlink" title="2.训练势基本流程"></a>2.训练势基本流程</h2><p><strong>1.从OUTCAR构建训练集，xsf格式，可直接在xcrystal 打开</strong> </p><p>   <strong>sampleing.py</strong></p><ol start="2"><li><p><strong>修改inv2</strong></p><p><strong>traindatapath  &#x3D;  .&#x2F;train-set</strong>*</p><p><strong>batchsize    &#x3D;  1  和原子数相乘超过200</strong></p><p><strong>device     &#x3D;  cpu</strong> </p><p><strong>printstep    &#x3D;  100</strong></p><p><strong>hasattention  &#x3D;  false 加不加注意力</strong></p></li><li><p><strong>训练</strong></p><p><strong>export OMP_NUM_THREADS&#x3D;12 多线程</strong></p><p>   <strong>.&#x2F;&#x3D;&#x3D;main.mp&#x3D;&#x3D; –train inv2</strong>   (是main.mp而不是lam.mpi)</p></li><li><p><strong>测试（修改inv2的测试部分）</strong></p><p><strong>.&#x2F;main.mp –eval inv2   保证能量相差几个meV,力相差几十meV,输出的单位是eV</strong></p><p>&#x3D;&#x3D;<strong>注意：线程和核，48核是虚拟核，实际只有24物理核，提交一个6线程任务就会占据6个核</strong>&#x3D;&#x3D;</p><p>&#x3D;&#x3D;<strong>训练机器学习势需要测试进程数，并不是越多越好，比如4远远好于48</strong>&#x3D;&#x3D;</p><p><strong>注意二:楼下集群做训练的速度太慢,最好不要用楼下集群训练</strong></p></li><li><p>&#x3D;&#x3D;计算 （记得训练用的什么样的inv2计算就要用什么样子的inv2)&#x3D;&#x3D;。否则会报错，无法运行</p></li><li><p>可以在训练过程中增加训练集，只要注意名字别和最开始的训练集重复</p></li></ol><h2 id="3-机器学习取样脚本"><a href="#3-机器学习取样脚本" class="headerlink" title="3.机器学习取样脚本"></a>3.机器学习取样脚本</h2><h3 id="1-按照目录来提取"><a href="#1-按照目录来提取" class="headerlink" title="1. 按照目录来提取"></a>1. 按照目录来提取</h3><pre><code class="python">import osimport sysimport timeimport scipy.stats as stimport numpy as npfrom sklearn.neighbors import KernelDensityfrom matplotlib import pyplotdef timer(func):    def wrapper(*args, **kwargs):        start_time = time.time()        result = func(*args, **kwargs)        end_time = time.time()        print(f&quot;Time elapsed: &#123;end_time - start_time:.4f&#125; seconds&quot;)        return result    return wrapperdef find_files(directory):    &quot;&quot;&quot;    递归查找一个目录下所有叫OUTCAR的文件，并返回这些文件的完整路径    &quot;&quot;&quot;    outcar_files = []  # 保存所有叫OUTCAR的文件的路径    for root, dirs, files in os.walk(directory):        for file in files:            if file == &quot;OUTCAR&quot;:                outcar_files.append(os.path.join(root, file))        for dir in dirs:            dir_outcar_files = find_files(os.path.join(root, dir))            outcar_files.extend(dir_outcar_files)        # 将子目录添加到 dirs 中，以便递归处理        dirs[:] = [d for d in dirs if os.path.isdir(os.path.join(root, d))]    outcar_files = list(set(outcar_files))    return outcar_files@timerdef read_vasp_xdatcar(file_path):    f = open(file=file_path)    f.readline()    f.readline()    lat = []    pos = []    # lattice    for _ in range(3):        lat.append(f.readline())    ele = f.readline()    npele = f.readline()    cnt = 0    tmp = None    while True:        line = f.readline()        if &quot;configuration&quot; in line:            cnt += 1            if tmp is not None:                pos.append(tmp)            tmp = []            continue        if not line:            pos.append(tmp)            break        tmp.append(line)    for conf_i in range(len(pos)):        for atom_i in range(len(pos[conf_i])):            pos[conf_i][atom_i] = pos[conf_i][atom_i].split()        pos[conf_i] = np.array(pos[conf_i]).astype(float)    ele = ele.split()    npele = npele.split()    npele = [int(i) for i in npele]    for i in range(len(lat)):        lat[i] = lat[i].split()    lat = np.array(lat).astype(float)    return cnt, ele, npele, lat, posdef topn(arr, n):    indices = np.argpartition(arr, -n)[-n:]    values = arr[indices]    sort_indices = np.argsort(values)[::-1]    return values[sort_indices], indices[sort_indices]def split_alp_num(string):    for i in range(len(string)):        if string[i].isdigit():            return [string[:i]], int(string[i:])def write2my(file_path, ene_i, lat_i, ele_i, coo_i, foc_i):    lat_i = lat_i.reshape(3, 3)    coo_i = coo_i.reshape(-1, 3)    foc_i = foc_i.reshape(-1, 3)    with open(file_path, &#39;w&#39;) as file:        file.write(f&quot;# total energy = &#123;ene_i&#125; eV\n\n&quot;)        file.write(&quot;CRYSTAL\n&quot;)        file.write(&quot;PRIMVEC\n&quot;)        for j in lat_i:            for k in j:                file.write(f&#39;&#123;k:20.8f&#125;&#39;)            file.write(&#39;\n&#39;)        file.write(&quot;PRIMCOORD\n&quot;)        file.write(f&quot;&#123;len(coo_i)&#125; 1\n&quot;)        for j in range(len(coo_i)):            file.write(f&#39;&#123;ele_i[j]:2&#125;&#39;)            # coo            for k in coo_i[j]:                file.write(f&quot;&#123;k:20.8f&#125;&quot;)            # force            for k in foc_i[j]:                file.write(f&quot;&#123;k:20.8f&#125;&quot;)            file.write(&quot;\n&quot;)    passdef direct2pos(lat, pos, direction=True):    &quot;&quot;&quot;    lat = [[Ax, Ay, Az],           [Bx, By, Bz],           [Cx, Cy, Cz]]    Pos = [n, 3]    :return: direct = [n, 3]    if direction=True    &quot;&quot;&quot;    if direction:        return pos @ lat    else:        return pos @ np.linalg.inv(lat)class MyDistrib(st.rv_continuous):    def __init__(self, prdf):        super().__init__()        self.prdf = prdf    def _pdf(self, x, *args):        return self.prdf.evaluate(x)class RejectSamp:    def __init__(self, ocr_name: str):        self.ocr_name = ocr_name  # &#123;XDATCAR path: OUTCAR path&#125;        self.rng_min = 0        self.rng_max = None        self.rng_grid = 10000        self.rng = None        self.rng_intv = None        self.pdf = None        self.sum_intv = 10        self.envelope = None        self.samples = None        pass    def sampling(self, num):        nframe, natom, ele, ene, lat, pos, foc = self._anls_ocr()        print(nframe)        print(natom)        # print(ele)        print(ene.shape)        print(lat.shape)        print(pos.shape)        print(foc.shape)        self.rng_max = nframe        self.rng = np.linspace(self.rng_min, self.rng_max, self.rng_grid)        self.rng_intv = self.rng[1] - self.rng[0]        sd = np.sum((pos[1:] - pos[:-1]) ** 2, (1, 2))        nintv = sd.size // self.sum_intv        sum_sd = sd[:nintv * self.sum_intv].reshape(nintv, self.sum_intv).sum(1)        sum_sd_body = np.copy(sum_sd)        sum_sd_body[:sum_sd.size // 20] = sum_sd.min()        topn_val, topn_idx = topn(sum_sd_body, 100)        x_train = topn_idx * self.sum_intv        distrib = KernelDensity(kernel=&quot;gaussian&quot;, bandwidth=int(0.003 * nframe)).fit(x_train[..., None])        self.pdf = lambda x: np.exp(distrib.score_samples(np.reshape(x, [-1, 1])))        self.envelope = self.pdf(self.rng).max()        cnt = 0        iters = 0        res = np.array([])        while cnt &lt; num:            u = np.random.uniform(self.rng_min, self.rng_max, num - cnt)            y = np.random.uniform(0, self.envelope, num - cnt)            pd = self.pdf(u)            res = np.append(res, u[pd &gt; y])            res = res.astype(int)            res = np.unique(res)            cnt = len(res)            iters += 1            print(f&quot;&#123;iters:&lt;3&#125;&#123;cnt:6&#125;&quot;)        print(&quot;Total iters: &quot;, iters)        self.samples = res        return self.samples.size, natom, ele, ene[self.samples], \            lat[self.samples], pos[self.samples], foc[self.samples]    def plot(self):        fig, ax = pyplot.subplots(figsize=(10, 6))        ax.hist(self.samples, bins=int(self.samples.size / 8), density=True, alpha=0.5)        ax.plot(self.rng, self.pdf(self.rng), &#39;r-&#39;, lw=1)        ax.plot(self.samples, -0.01 * self.envelope - 0.03 * self.envelope * np.random.random(self.samples.size), &quot;+k&quot;)        ax.set_ylim(-self.envelope * 0.05)        ax.set_title(self.ocr_name + &quot;  PDF&quot;)        return fig    @timer    def _anls_ocr(self):        pos_foc = []        ene = []        lat = []        ions_per = []        types = []        print(self.ocr_name)        with open(self.ocr_name, &#39;r&#39;) as file:            while True:                line = file.readline()                # eof break                if not line:                    break                # ions per type                #if &quot;POSCAR&quot; in line:                #    ions_per.append(line)                #    continue                if &quot;ions per type&quot; in line:                    ions_per.append(line)                if &quot;VRHFIN&quot; in line:                    types.append(line)                # lat                if &quot;BASIS-vectors&quot; in line:                    file.readline()                    file.readline()                    file.readline()                    file.readline()                    for i in range(3):                        line = file.readline()                        lat.append(line)                    continue                # pos &amp; force                if &quot;TOTAL-FORCE (eV/Angst)&quot; in line:                    line = file.readline()                    while True:                        line = file.readline()                        if not line:                            break                        if &quot;------&quot; in line:                            break                        pos_foc.append(line)                    continue                # ene                if &quot;energy  without entropy&quot; in line:                    ene.append(line)        ene = np.array([i.split(&#39;=&#39;)[1].split()[0] for i in ene]).astype(np.float64)        # lat = np.array([i.split() for i in lat]).astype(np.float64)[:, :3].reshape(-1, 3, 3)        lat = np.array([[float(i[4:][:12]), float(i[4:][12:25]), float(i[4:][25:38])] for i in lat]).astype(np.float64)[:, :3].reshape(-1, 3, 3)        # ele pretreatment        types = [i.split(&#39;=&#39;)[1].split(&#39;:&#39;)[0].rstrip() for i in types]        ions_per = ions_per[0].split()[-4:]        ele = sum([[i] * int(j) for i, j in zip(types, ions_per)], [])        pos_foc = np.array([i.split() for i in pos_foc]).astype(np.float64)        nframe = len(ene)        natom = len(ele)        pos = pos_foc[:, :3][:nframe * natom].reshape(nframe, natom, 3)[:nframe]        foc = pos_foc[:, 3:][:nframe * natom].reshape(nframe, natom, 3)[:nframe]        lat = lat[:nframe]        return nframe, natom, ele, ene, lat, pos, focif __name__ == &#39;__main__&#39;:    # ocr_files = find_files(&quot;/data/ljx/third/lizhao/LYSO/LYSO-src/old&quot;)#训练结构路径    ocr_files = [&quot;/work/home/liz/workspace/1-system-MD/3-K5YSi4O12/9-1-lammps/6-train-NNP/outcar/1fs/2&quot;,                 &quot;/work/home/liz/workspace/1-system-MD/3-K5YSi4O12/9-1-lammps/6-train-NNP/outcar/1fs/4&quot;,                 &quot;/work/home/liz/workspace/1-system-MD/3-K5YSi4O12/9-1-lammps/6-train-NNP/outcar/2fs/2&quot;,                 &quot;/work/home/liz/workspace/1-system-MD/3-K5YSi4O12/9-1-lammps/6-train-NNP/outcar/2fs/4&quot;]    #ocr_files = [&quot;/work/home/liz/workspace/1-system-MD/3-K5YSi4O12/9-1-lammps/6-train-NNP/outcar/triple/1&quot;,    #             &quot;/work/home/liz/workspace/1-system-MD/3-K5YSi4O12/9-1-lammps/6-train-NNP/outcar/triple/2&quot;] #训练集输出路径      out_path = &quot;/work/home/liz/workspace/1-system-MD/3-K5YSi4O12/9-1-lammps/6-train-NNP/&quot;    if not os.path.exists(out_path):        os.mkdir(out_path)    out_data_path = os.path.join(out_path, &quot;eval-set&quot;)    if not os.path.exists(out_data_path):        os.mkdir(out_data_path)#每个数据取多少点，大概相乘在10000附近    smp_per_ocr = 1500    # mode = &#39;rand&#39;    mode = &#39;kde&#39;    # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #    # Be careful when changing the code below    print(f&quot;total trajectories: &#123;len(ocr_files)&#125;&quot;)    if not os.path.exists(out_data_path):        os.mkdir(out_data_path)    xsf_tot_cnt = 0    if mode == &#39;kde&#39;:        for ocr_i in range(len(ocr_files)):            r = RejectSamp(ocr_files[ocr_i])            n_frame, n_atom, ele, ene, lat, pos, foc = r.sampling(smp_per_ocr)            fig = r.plot()            fig_path = os.path.join(out_path, str(ocr_i))            fig.savefig(fig_path)            for j in range(n_frame):                path_j = os.path.join(out_data_path, f&#39;structure&#123;str(smp_per_ocr * ocr_i + j).zfill(5)&#125;.xsf&#39;)                ene_j = ene[j]                lat_j = lat[j]                ele_j = ele                coo_j = pos[j]                foc_j = foc[j]                write2my(path_j, ene_j, lat_j, ele_j, coo_j, foc_j)                xsf_tot_cnt += 1</code></pre><h3 id="2-从单个目录下递归直接提取全部"><a href="#2-从单个目录下递归直接提取全部" class="headerlink" title="2. 从单个目录下递归直接提取全部"></a>2. 从单个目录下递归直接提取全部</h3><p>&#x3D;&#x3D;注意root_dir和write_dir的位置，其中root_dir放到要提取的当前目录最好，并且使用相对路径，这样提取的文件名称比较短&#x3D;&#x3D;</p><p>&#x3D;&#x3D;而write_dir则需要新建一个目录来存储提取的结构&#x3D;&#x3D;</p><pre><code class="python">import osfrom ase.io import readfrom ase import Atomsdef write2my(file_path, ene_i, lat_i, ele_i, coo_i, foc_i, vir_i=None):    lat_i = lat_i.reshape(3, 3)    coo_i = coo_i.reshape(-1, 3)    foc_i = foc_i.reshape(-1, 3)    with open(file_path, &#39;w&#39;) as file:        file.write(f&quot;# total energy = &#123;ene_i&#125; eV\n\n&quot;)        if vir_i is not None:            file.write(f&quot;VIRIAL\n&quot;)            for i in vir_i:                file.write(f&#39;&#123;i:20.8f&#125;&#39;)        file.write(&quot;\n&quot;)        file.write(&quot;CRYSTAL\n&quot;)        file.write(&quot;PRIMVEC\n&quot;)        for j in lat_i:            for k in j:                file.write(f&#39;&#123;k:20.8f&#125;&#39;)            file.write(&#39;\n&#39;)        file.write(&quot;PRIMCOORD\n&quot;)        file.write(f&quot;&#123;len(coo_i)&#125; 1\n&quot;)        for j in range(len(coo_i)):            file.write(f&#39;&#123;ele_i[j]:2&#125;&#39;)            # coo            for k in coo_i[j]:                file.write(f&quot;&#123;k:20.8f&#125;&quot;)            # force            for k in foc_i[j]:                file.write(f&quot;&#123;k:20.8f&#125;&quot;)            file.write(&quot;\n&quot;)    passdef read_from_ase_atoms(atoms: Atoms):    ene = atoms.get_potential_energy()    lat = atoms.get_cell()    pos = atoms.get_positions()    foc = atoms.get_forces()    try:        sts = atoms.get_stress()        xx, yy, zz, yz, xz, xy = - sts * atoms.get_volume()        vir = np.array(            [[xx, xy, xz],             [xy, yy, yz],             [xz, yz, zz]]).reshape(-1)    except:        vir = None    ele = atoms.get_chemical_symbols()    return ene, lat, pos, foc, vir, eledef find_files(directory, filename):    result = []    for root, dirs, files in os.walk(directory):        for file in files:            if file == filename:                result.append(os.path.join(root, file))    return resultif __name__ == &#39;__main__&#39;:    root_dir = &quot;./&quot;     outcar_dir = find_files(root_dir, &quot;OUTCAR&quot;)    write_dir = &quot;/work/home/xieyu/workplace/liz/2-Li-Y-Si-O-600K/B-升温/data_xsf&quot;    for i in outcar_dir:        xsf_head = &#39;_&#39;.join(i.split(&#39;.&#39;)[-1].split(&#39;/&#39;))        print(xsf_head)        datas = read(i, index=&quot;:&quot;)        for n, i in enumerate(datas):            ene, lat, pos, foc, vir, ele = read_from_ase_atoms(i)            write2my(                os.path.join(write_dir, f&quot;&#123;xsf_head&#125;_struct&#123;str(n).zfill(6)&#125;.xsf&quot;),                ene_i=ene,                lat_i=lat,                ele_i=ele,                coo_i=pos,                foc_i=foc,                vir_i=vir)</code></pre><h2 id="4-遇到的报错、问题"><a href="#4-遇到的报错、问题" class="headerlink" title="4.遇到的报错、问题"></a>4.遇到的报错、问题</h2><ol><li><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230518110402035.png" alt="image-20230518110402035"></p><p><strong>晶胞中某种原子的个数少，导致小的截断半径探索不到足够的数据，需要增加截断半径</strong></p><p><strong>解决方法：增加rcut和acut</strong></p></li></ol><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230518110457046.png" alt="image-20230518110457046"></p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230518110502110.png" alt="image-20230518110502110"></p><ol start="2"><li><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230518110515573.png" alt="image-20230518110515573"></p><p><strong>找师弟</strong></p></li><li><p><strong>取样脚本报错，原因是中文名称路径</strong></p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230518110605312.png" alt="image-20230518110605312"></p></li></ol><h1 id="2-主动学习机器学习"><a href="#2-主动学习机器学习" class="headerlink" title="2. 主动学习机器学习"></a>2. 主动学习机器学习</h1><p>如果给主动学习一个很大的初始训练集，会降低主动学习的速度，原因是主动学习需要遍历很多的结构</p><p>初始训练集太少会导致一些较少的原子检测不到，会报错</p><h2 id="1-注意事项"><a href="#1-注意事项" class="headerlink" title="1.注意事项"></a>1.注意事项</h2><h3 id="1-老版本"><a href="#1-老版本" class="headerlink" title="1. 老版本"></a>1. 老版本</h3><h4 id="1-关于显卡"><a href="#1-关于显卡" class="headerlink" title="1 关于显卡"></a>1 关于显卡</h4><p>gtop查看显卡信息，&#x3D;&#x3D;注意别把显存提爆&#x3D;&#x3D;  占用显存大小和胞的大小有关，和数据集数量无关</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20231022221759671.png" alt="image-20231022221759671"></p><h4 id="2-关于主动学习"><a href="#2-关于主动学习" class="headerlink" title="2 关于主动学习"></a>2 关于主动学习</h4><p>对每个主动学习任务，需要在集群处建立新的文件夹，来进行自洽计算，避免多个任务进行时发生‘哈希碰撞’</p><p>修改下面文件中的路径</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20231023155810672.png" alt="image-20231023155810672"></p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20231023155824015.png" alt="image-20231023155824015"></p><ol start="2"><li><p>cal.slurm里提任务的名称要不同，因为是依据任务名称来回收任务的</p></li><li><p>记得激活python3环境（不然不写新找到的数据集，现在修复了）</p></li><li><p>修改使用哪个卡<img src="/./../%E5%9B%BE%E7%89%87/image-20231118163008730.png" alt="image-20231118163008730"></p><p>可以把多个任务提交到一块卡上面</p><p>如果是单独只训练需要把restart修改为false</p><p>不能把poscar放到fp里面，否则会反复lable 一个结构</p><p>任务输出的log文件要统一命名   3-md-log（lammps分子动力学输出）</p><p>2-train-log（训练输出）</p><p>4-select-log （选择输出）</p><p>vasp.log vasp输出</p><p>训练的圈数不需要太多 3000-5000</p><p>初始训练集的数目100左右</p><p>acnn的路径（sub-train.sh sub-select.sh)要正确</p><p>inv2 里rcut等</p><p>注意sub-md.sh和sub.slurm里面的任务名称不但不同任务要不同，而且要与原来集群上的任务名称不同</p><p>waiting remote jobs: 1  含义是有一个等待回收的任务</p><p>lr是学习率，学习率的值减小，说明模型的变化量减小</p></li><li><p>inv2中 select_thr 控制挑选结构的下限阈值。目的是挑选出结构差异性大的结构，增大sub-select.log中target的值（一个矩阵的行列式，不同行差异性越大行列式越大）。初期因为跑的少，很多相似结构，所以阈值要高点，不能什么都加进去，后期跑的多了，可以把阈值调低点，增加多样性，</p><p>现在推荐把select_thr设置为1.2</p></li></ol><h4 id="3-需要测试的事项"><a href="#3-需要测试的事项" class="headerlink" title="3.需要测试的事项"></a>3.需要测试的事项</h4><ol><li>初始数据集的大小多少更合适</li><li>训练的圈数需要随着主动学习次数的增加而变化，多少圈比较合适</li><li>小包跑多少算合理了</li><li>主动学习过程中，哪些是占资源多的，哪些是花费时间长的</li><li>nohup .&#x2F;sub-train.sh &gt; train.log 2&gt;&amp;1 &amp;</li><li>inv2 里卡的名称</li><li>in.lmp 里质量、名称</li><li>给一个data.nlso文件</li></ol><h4 id="4-训练方式-增强采样"><a href="#4-训练方式-增强采样" class="headerlink" title="4.训练方式-增强采样"></a>4.训练方式-增强采样</h4><p>&#x3D;&#x3D;先用小胞，小圈数  训练到一定程度后（小胞可以跑足够长时间），用大胞、大圈数&#x3D;&#x3D;   目的是增加训练集</p><p>&#x3D;&#x3D;可以循环着提供大胞的扩胞方式&#x3D;&#x3D;</p><p>inv2 nbatch和savestep要联动修改</p><p>增加胞的大小应该可以减小代数</p><p>top -u lijx</p><p>跑升温过程训练，这样得到的势理论上可以跑不同的温度</p><p>增强采样：大晶胞、训练圈数增加、广的温度采样范围、长的模拟时间</p><h4 id="5-关于续算"><a href="#5-关于续算" class="headerlink" title="5. 关于续算"></a>5. 关于续算</h4><h5 id="1-没有跑到设置条件（没有跑足1ns…"><a href="#1-没有跑到设置条件（没有跑足1ns…" class="headerlink" title="1.没有跑到设置条件（没有跑足1ns…)"></a>1.没有跑到设置条件（没有跑足1ns…)</h5><ol><li><p>删除最后一代</p></li><li><p>在scheduling.sh里修改代数，不从0开始，而是输入刚刚删除的代的代号，这样，会自动从前一代读取最后的模型，进行训练。在提交任务后，新的一代内训练输出2-train.log中会出现提示（需要向下多翻）</p><p>例如，跑完是 28 29 30 ，那就删除30的文件夹，同时把scheduling.sh里改为30</p></li><li><p>提交任务应该注意 &gt;&gt; log 否则续算会把之前的log覆盖掉  nohup .&#x2F;scheduling.sh &gt;&gt; log 2&gt;&amp;1 &amp;</p></li><li><p>可以适当修改分子动力学里的晶胞尺寸、模拟时间、训练圈数和保存的步数、训练用到的卡</p></li></ol><h5 id="2-跑到预定条件，但是希望续算"><a href="#2-跑到预定条件，但是希望续算" class="headerlink" title="2.跑到预定条件，但是希望续算"></a>2.跑到预定条件，但是希望续算</h5><ol><li><p>正常训练结束后log会报没有输出oos的错误，可以通过看最后一代3md的输出log.lammps判断</p></li><li><p>不需要删除最后一代，只需要修改scheduling.sh为下一代开始，例如，出现了 28 29 30 那么scheduling.sh里修改为 31</p></li><li><p>需要把前一代的Ap_inv_*拷贝过来，因为没有select的步骤没有办法产生这些文件，但是分子动力学计算需要这些文件</p><p>&#x3D;&#x3D;Ap_inv_<em>用于主动学习中选择结构，如果用al的模式跑分子动力学，需要用到Ap_inv</em>来作为选择结构的标准，但是分子动力学过程并没有用到。用不用al跑出来的结果是一样的，差别是要不要获取结构&#x3D;&#x3D;</p><p>&#x3D;&#x3D;可以不用al，也就不需要Ap_inv&#x3D;&#x3D;</p></li><li><p>修改in.lmp里面的模拟晶胞尺寸、模拟时间、以及升温过程的温度（更广一些）、增加训练和保存的圈数、等等方式来增加采样  </p><p>还有修改 restart_lr &#x3D; 1e-4  &#x3D;&#x3D;学习率&#x3D;&#x3D;</p><p>学习率1e-7训练就差别不大了</p><p>inv2中 select_thr  调低 1.2</p></li></ol><p><img src="/./../%E5%9B%BE%E7%89%87/image-20231207153430496.png" alt="image-20231207153430496"></p><h4 id="6-批量化杀掉当前文件夹内后台的任务（不想继续跑的时候）"><a href="#6-批量化杀掉当前文件夹内后台的任务（不想继续跑的时候）" class="headerlink" title="6 批量化杀掉当前文件夹内后台的任务（不想继续跑的时候）"></a>6 批量化杀掉当前文件夹内后台的任务（不想继续跑的时候）</h4><pre><code class="shell"># 获取用户 lijx的所有进程 IDpgrep -u lijx &gt; lijx_processes.txt # 通过进程 ID 获取对应的进程所在目录while read -r pid; do    ls -l /proc/&quot;$pid&quot;/cwd 2&gt;/dev/null | grep -q &quot;/public/lijx/work/Na-X-Si-O/2-onthefly/3-gpu&quot; &amp;&amp; echo &quot;$      pid&quot;done &lt; lijx_processes.txt &gt; lijx_processes_in_test.txt# 通过进程 ID 杀死位于 /home/lijx/test 及其子目录下的所有进程while read -r pid; do    kill -9 &quot;$pid&quot;done &lt; lijx_processes_in_test.txt</code></pre><pre><code class="shell">for i in $(cat lijx_processes_in_test.txt);do llpid $i;done</code></pre><h2 id="2-集成化提任务方式"><a href="#2-集成化提任务方式" class="headerlink" title="2.集成化提任务方式"></a>2.集成化提任务方式</h2><p>四个文件  1-convert_outcar_xsf.py   2-convert_POSCAR_data.py   3-makepot.py    make_initial.sh</p><p>只需要配置make_initial.sh</p><pre><code class="shell">#需要的文件：POSCAR OUTCAR sub.slurm(vasp) sub-md.sh(lammps)#先切换到python3环境 conda activate #set vasp_systermvasp_folder=&#39;&quot;/work/home/liz/workspace/1-system-MD/5-Na-X-Si-O/md/1-Mo&quot;&#39;md_duty_name=&#39;md-Mo&#39;vasp_label_duty_name=&#39;vasp-Mo&#39;#set GPUGPU_number=0#set mdcat &gt; in.lmp &lt;&lt; lzhvariable        x index 1variable        y index 1variable        z index 1variable        ss equal 0.001variable        tdamp equal &quot;v_ss*100&quot;variable        dmsdx  equal   c_1[1]variable        dmsdy  equal   c_1[2]variable        dmsdz  equal   c_1[3]variable        dmsd   equal   c_1[4]variable        istep  equal   stepvariable        msdx   format  dmsdx  %16.8evariable        msdy   format  dmsdy  %16.8evariable        msdz   format  dmsdz  %16.8evariable        msd    format  dmsd   %16.8evariable        sstep  format  istep  %-10gunits           metalatom_style      atomicboundary        p p pread_data       ./data.nsomass            1 22.990    #importantmass            2 95.94mass            3 28.084mass            4 15.999replicate       \$x \$y \$zpair_style      acnn ./model/all alpair_coeff      * * Na   Mo   Si   O   #importantthermo          1thermo_style    custom step time temp press pe lx ly lz kethermo_modify   format 4 %20.15gcompute         1 all msd com yesdump            out  all custom 100 A.lammpstrj id element xu yu zu fx fy fzdump_modify     out  element 1   2   3   4dump_modify     out  format 1 %4ddump_modify     out  format 2 %4sdump_modify     out  format float %16.8fvelocity        all create 800.0 8728timestep        \$&#123;ss&#125;fix             1 all nvt temp 800 800 \$&#123;tdamp&#125;fix             2 all print 1 &quot;\$&#123;sstep&#125; \$&#123;msdx&#125; \$&#123;msdy&#125; \$&#123;msdz&#125; \$&#123;msd&#125;&quot; screen no file msd.datrun             1000000lzh#not always need changesvasp_ip=&#39;&quot;liz@59.72.114.246&quot;&#39;vasp_port=&#39;&quot;2222&quot;&#39;command_line=&#39;&quot;slurm&quot;&#39;# set vasp_inputvasp_pot_PBE_Path=&#39;&quot;/public/lijx/work/Na-X-Si-O/pot-makepot/potpaw_PBE/&quot;&#39;cat &gt; INCAR &lt;&lt; liz SYSTEM = Na-X-Si-OALGO = NormalISYM = 0LREAL =AutoPREC = NormalEDIFF = 1e-5ENCUT = 400NELMIN = 4NELM = 500IBRION = -1ISIF = 2ISMEAR = 0SIGMA = 0.05NPAR = 6LH5 = .TRUE.lizcat &gt; KPOINTS &lt;&lt; lizhK-Spacing Value to Generate K-Mesh: 0.060Gamma 1   1   1 0.0  0.0  0.0lizhsed -i &quot;s|^base_pseudo_path.*|base_pseudo_path = $vasp_pot_PBE_Path|&quot; 3-makepot.pymv ../POSCAR ../resource/fpmv ../sub.slurm ../resource/fpmv ../sub-md.sh ../resource/mdmv ./INCAR ../resource/fpmv ./KPOINTS ../resource/fpmv ./in.lmp ../resource/mdmv ../OUTCAR ../resource/init_dtcp ./1-convert_outcar_xsf.py ../resource/init_dtcp ./2-convert_POSCAR_data.py ../resource/fpcp ./3-makepot.py ../resource/fpcd ../resource/init_dt/python 1-convert_outcar_xsf.py waitrm OUTCARmv eval-set/* ./cd ../fppython 2-convert_POSCAR_data.py POSCAR data.nsowaitmv data.nso ../mdpython 3-makepot.py rm POSCARwaitif [ &quot;$command_line&quot;=&quot;slurm&quot; ]; then    sed -i &quot;s|^#SBATCH  --job-name.*|#SBATCH  --job-name=$vasp_label_duty_name|&quot; sub.slurmelif [ &quot;$command_line&quot; = &quot;PBS&quot; ]; then    sed -i &quot;s|^#PBS -N|#PBS -N $vasp_label_duty_name|&quot; sub.slurmelse    echo &quot;Command line is not &#39;slurm&#39; or &#39;PBS. Run another command.&quot;ficd ../mdif [ &quot;$command_line&quot;=&quot;slurm&quot; ]; then    sed -i &quot;s|^#SBATCH  --job-name.*|#SBATCH  --job-name=$md_duty_name|&quot; sub-md.shelif [ &quot;$command_line&quot; = &quot;PBS&quot; ]; then    sed -i &quot;s|^#PBS -N|#PBS -N $md_duty_name|&quot; sub-md.shelse    echo &quot;Command line is not &#39;slurm&#39; or &#39;PBS. Run another command.&quot;ficd ..sed -i &quot;9s|.*|remote_work_place=$vasp_folder|&quot; iter_scheduling_remote.shsed -i &quot;s|^remote_ip=.*|remote_ip=$vasp_ip|&quot; iter_scheduling_remote.shsed -i &quot;s|^remote_port=.*|remote_port=$vasp_port|&quot; iter_scheduling_remote.shsed -i &quot;s|^task_sys=.*|task_sys=$command_line|&quot; iter_scheduling_remote.shsed -i &quot;s|^device.*|device          =   cuda:$GPU_number|&quot; inv2</code></pre><p>1-</p><pre><code class="python">import osimport sysimport timeimport scipy.stats as stimport numpy as npfrom sklearn.neighbors import KernelDensityfrom matplotlib import pyplotdef timer(func):    def wrapper(*args, **kwargs):        start_time = time.time()        result = func(*args, **kwargs)        end_time = time.time()        print(f&quot;Time elapsed: &#123;end_time - start_time:.4f&#125; seconds&quot;)        return result    return wrapperdef find_files(directory):    &quot;&quot;&quot;    递归查找一个目录下所有叫OUTCAR的文件，并返回这些文件的完整路径    &quot;&quot;&quot;    outcar_files = []  # 保存所有叫OUTCAR的文件的路径    for root, dirs, files in os.walk(directory):        for file in files:            if file == &quot;OUTCAR&quot;:                outcar_files.append(os.path.join(root, file))        for dir in dirs:            dir_outcar_files = find_files(os.path.join(root, dir))            outcar_files.extend(dir_outcar_files)        # 将子目录添加到 dirs 中，以便递归处理        dirs[:] = [d for d in dirs if os.path.isdir(os.path.join(root, d))]    outcar_files = list(set(outcar_files))    return outcar_files@timerdef read_vasp_xdatcar(file_path):    f = open(file=file_path)    f.readline()    f.readline()    lat = []    pos = []    # lattice    for _ in range(3):        lat.append(f.readline())    ele = f.readline()    npele = f.readline()    cnt = 0    tmp = None    while True:        line = f.readline()        if &quot;configuration&quot; in line:            cnt += 1            if tmp is not None:                pos.append(tmp)            tmp = []            continue        if not line:            pos.append(tmp)            break        tmp.append(line)    for conf_i in range(len(pos)):        for atom_i in range(len(pos[conf_i])):            pos[conf_i][atom_i] = pos[conf_i][atom_i].split()        pos[conf_i] = np.array(pos[conf_i]).astype(float)    ele = ele.split()    npele = npele.split()    npele = [int(i) for i in npele]    for i in range(len(lat)):        lat[i] = lat[i].split()    lat = np.array(lat).astype(float)    return cnt, ele, npele, lat, posdef topn(arr, n):    indices = np.argpartition(arr, -n)[-n:]    values = arr[indices]    sort_indices = np.argsort(values)[::-1]    return values[sort_indices], indices[sort_indices]def split_alp_num(string):    for i in range(len(string)):        if string[i].isdigit():            return [string[:i]], int(string[i:])def write2my(file_path, ene_i, lat_i, ele_i, coo_i, foc_i):    lat_i = lat_i.reshape(3, 3)    coo_i = coo_i.reshape(-1, 3)    foc_i = foc_i.reshape(-1, 3)    with open(file_path, &#39;w&#39;) as file:        file.write(f&quot;# total energy = &#123;ene_i&#125; eV\n\n&quot;)        file.write(&quot;CRYSTAL\n&quot;)        file.write(&quot;PRIMVEC\n&quot;)        for j in lat_i:            for k in j:                file.write(f&#39;&#123;k:20.8f&#125;&#39;)            file.write(&#39;\n&#39;)        file.write(&quot;PRIMCOORD\n&quot;)        file.write(f&quot;&#123;len(coo_i)&#125; 1\n&quot;)        for j in range(len(coo_i)):            file.write(f&#39;&#123;ele_i[j]:2&#125;&#39;)            # coo            for k in coo_i[j]:                file.write(f&quot;&#123;k:20.8f&#125;&quot;)            # force            for k in foc_i[j]:                file.write(f&quot;&#123;k:20.8f&#125;&quot;)            file.write(&quot;\n&quot;)    passdef direct2pos(lat, pos, direction=True):    &quot;&quot;&quot;    lat = [[Ax, Ay, Az],           [Bx, By, Bz],           [Cx, Cy, Cz]]    Pos = [n, 3]    :return: direct = [n, 3]    if direction=True    &quot;&quot;&quot;    if direction:        return pos @ lat    else:        return pos @ np.linalg.inv(lat)class MyDistrib(st.rv_continuous):    def __init__(self, prdf):        super().__init__()        self.prdf = prdf    def _pdf(self, x, *args):        return self.prdf.evaluate(x)class RejectSamp:    def __init__(self, ocr_name: str):        self.ocr_name = ocr_name  # &#123;XDATCAR path: OUTCAR path&#125;        self.rng_min = 0        self.rng_max = None        self.rng_grid = 10000        self.rng = None        self.rng_intv = None        self.pdf = None        self.sum_intv = 10        self.envelope = None        self.samples = None        pass    def sampling(self, num):        nframe, natom, ele, ene, lat, pos, foc = self._anls_ocr()        print(nframe)        print(natom)        # print(ele)        print(ene.shape)        print(lat.shape)        print(pos.shape)        print(foc.shape)        self.rng_max = nframe        self.rng = np.linspace(self.rng_min, self.rng_max, self.rng_grid)        self.rng_intv = self.rng[1] - self.rng[0]        sd = np.sum((pos[1:] - pos[:-1]) ** 2, (1, 2))        nintv = sd.size // self.sum_intv        sum_sd = sd[:nintv * self.sum_intv].reshape(nintv, self.sum_intv).sum(1)        sum_sd_body = np.copy(sum_sd)        sum_sd_body[:sum_sd.size // 20] = sum_sd.min()        topn_val, topn_idx = topn(sum_sd_body, 100)        x_train = topn_idx * self.sum_intv        distrib = KernelDensity(kernel=&quot;gaussian&quot;, bandwidth=int(0.003 * nframe)).fit(x_train[..., None])        self.pdf = lambda x: np.exp(distrib.score_samples(np.reshape(x, [-1, 1])))        self.envelope = self.pdf(self.rng).max()        cnt = 0        iters = 0        res = np.array([])        while cnt &lt; num:            u = np.random.uniform(self.rng_min, self.rng_max, num - cnt)            y = np.random.uniform(0, self.envelope, num - cnt)            pd = self.pdf(u)            res = np.append(res, u[pd &gt; y])            res = res.astype(int)            res = np.unique(res)            cnt = len(res)            iters += 1            print(f&quot;&#123;iters:&lt;3&#125;&#123;cnt:6&#125;&quot;)        print(&quot;Total iters: &quot;, iters)        self.samples = res        return self.samples.size, natom, ele, ene[self.samples], \            lat[self.samples], pos[self.samples], foc[self.samples]    def plot(self):        fig, ax = pyplot.subplots(figsize=(10, 6))        ax.hist(self.samples, bins=int(self.samples.size / 8), density=True, alpha=0.5)        ax.plot(self.rng, self.pdf(self.rng), &#39;r-&#39;, lw=1)        ax.plot(self.samples, -0.01 * self.envelope - 0.03 * self.envelope * np.random.random(self.samples.size), &quot;+k&quot;)        ax.set_ylim(-self.envelope * 0.05)        ax.set_title(self.ocr_name + &quot;  PDF&quot;)        return fig    @timer    def _anls_ocr(self):        pos_foc = []        ene = []        lat = []        ions_per = []        types = []        print(self.ocr_name)        with open(self.ocr_name, &#39;r&#39;) as file:            while True:                line = file.readline()                # eof break                if not line:                    break                # ions per type                #if &quot;POSCAR&quot; in line:                #    ions_per.append(line)                #    continue                if &quot;ions per type&quot; in line:                    ions_per.append(line)                if &quot;VRHFIN&quot; in line:                    types.append(line)                # lat                if &quot;BASIS-vectors&quot; in line:                    file.readline()                    file.readline()                    file.readline()                    file.readline()                    for i in range(3):                        line = file.readline()                        lat.append(line)                    continue                # pos &amp; force                if &quot;TOTAL-FORCE (eV/Angst)&quot; in line:                    line = file.readline()                    while True:                        line = file.readline()                        if not line:                            break                        if &quot;------&quot; in line:                            break                        pos_foc.append(line)                    continue                # ene                if &quot;energy  without entropy&quot; in line:                    ene.append(line)        ene = np.array([i.split(&#39;=&#39;)[1].split()[0] for i in ene]).astype(np.float64)        # lat = np.array([i.split() for i in lat]).astype(np.float64)[:, :3].reshape(-1, 3, 3)        lat = np.array([[float(i[4:][:12]), float(i[4:][12:25]), float(i[4:][25:38])] for i in lat]).astype(np.float64)[:, :3].reshape(-1, 3, 3)        # ele pretreatment        types = [i.split(&#39;=&#39;)[1].split(&#39;:&#39;)[0].rstrip() for i in types]        ions_per = ions_per[0].split()[-4:]        ele = sum([[i] * int(j) for i, j in zip(types, ions_per)], [])        pos_foc = np.array([i.split() for i in pos_foc]).astype(np.float64)        nframe = len(ene)        natom = len(ele)        pos = pos_foc[:, :3][:nframe * natom].reshape(nframe, natom, 3)[:nframe]        foc = pos_foc[:, 3:][:nframe * natom].reshape(nframe, natom, 3)[:nframe]        lat = lat[:nframe]        return nframe, natom, ele, ene, lat, pos, focif __name__ == &#39;__main__&#39;:    # ocr_files = find_files(&quot;/data/ljx/third/lizhao/LYSO/LYSO-src/old&quot;)#训练结构路径    ocr_files = [&quot;./OUTCAR&quot;]    #ocr_files = [&quot;/work/home/liz/workspace/1-system-MD/3-K5YSi4O12/9-1-lammps/6-train-NNP/outcar/triple/1&quot;,    #             &quot;/work/home/liz/workspace/1-system-MD/3-K5YSi4O12/9-1-lammps/6-train-NNP/outcar/triple/2&quot;] #训练集输出路径      out_path = &quot;./&quot;    if not os.path.exists(out_path):        os.mkdir(out_path)    out_data_path = os.path.join(out_path, &quot;eval-set&quot;)    if not os.path.exists(out_data_path):        os.mkdir(out_data_path)#每个数据取多少点，大概相乘在10000附近    smp_per_ocr = 50    # mode = &#39;rand&#39;    mode = &#39;kde&#39;    # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #    # Be careful when changing the code below    print(f&quot;total trajectories: &#123;len(ocr_files)&#125;&quot;)    if not os.path.exists(out_data_path):        os.mkdir(out_data_path)    xsf_tot_cnt = 0    if mode == &#39;kde&#39;:        for ocr_i in range(len(ocr_files)):            r = RejectSamp(ocr_files[ocr_i])            n_frame, n_atom, ele, ene, lat, pos, foc = r.sampling(smp_per_ocr)            fig = r.plot()            fig_path = os.path.join(out_path, str(ocr_i))            fig.savefig(fig_path)            for j in range(n_frame):                path_j = os.path.join(out_data_path, f&#39;structure&#123;str(smp_per_ocr * ocr_i + j).zfill(5)&#125;.xsf&#39;)                ene_j = ene[j]                lat_j = lat[j]                ele_j = ele                coo_j = pos[j]                foc_j = foc[j]                write2my(path_j, ene_j, lat_j, ele_j, coo_j, foc_j)                xsf_tot_cnt += 1</code></pre><p>2-</p><pre><code class="python"># convert VASP OUTCAT to lammps .data (atomic)## usage:# python &quot;this file&quot; OUTCAR.input data.output## # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # ###import numpy as npfrom sys import argvdef anls_poscar(file_name: str):    with open(file_name, &#39;r&#39;) as f:        lines = f.readlines()    bloom_factor = float(lines[1])    lat = np.array([i.split() for i in lines[2: 5]]).astype(float)    lat = bloom_factor * lat    ele_and_num = lines[5][:-1] + &quot;:&quot; + lines[6][:-1]    pos_d = None    if (lines[7][0] == &#39;d&#39;) or (lines[7][0] == &#39;D&#39;):        # direct coord.        pos_d = np.array([i.split() for i in lines[8:]]).astype(float)    elif (lines[7][0] == &#39;c&#39;) or (lines[7][0] == &#39;C&#39;):        # cartesian        pos_c = np.array([i.split() for i in lines[8:]]).astype(float)        pos_d = direct2pos(lat, pos_c, False)    return lat, pos_d, ele_and_numdef direct2pos(lat, pos, direction=True):    &quot;&quot;&quot;    lat = [[Ax, Ay, Az],           [Bx, By, Bz],           [Cx, Cy, Cz]]    Pos = [n, 3]    :return: if True:  return cart   = [n, 3]             if False: return direct = [n, 3]    &quot;&quot;&quot;    if direction:        return pos @ lat    else:        return pos @ np.linalg.inv(lat)def clip_ny_norm(x):    return x / np.linalg.norm(x)def cart2lams(lat):    &quot;&quot;&quot;    vasp (POSCAR) Coordinate System:    O = [[ax, ay, az],         [bx, by, bz],         [cx, cy, cz]]    :return:    lammps Coordinate System:    O&#39; = [[xhi - xlo,  0,  0],          [xy, yhi - ylo,  0],          [xz, yz, zhi - zlo]]    &quot;&quot;&quot;    ax = (lat[0] ** 2).sum() ** 0.5    a_hat = clip_ny_norm(lat[0])    bx = (lat[1] * a_hat).sum()    by = np.linalg.norm(np.cross(a_hat, lat[1]))    cx = (lat[2] * a_hat).sum()    cy = (lat[2] * np.cross(clip_ny_norm(np.cross(lat[0], lat[1])), a_hat)).sum()    cz = np.abs((lat[2] * clip_ny_norm(np.cross(lat[0], lat[1]))).sum())    new = np.array([        [ax, 0, 0],        [bx, by, 0],        [cx, cy, cz]    ])    return newdef write_lmp_atomic_data(filename, lmp_lat, pos_c, strr):    new_coo = pos_c    Z_of_type = strr.split(&#39;:&#39;)[0].split()    n_type = strr.split(&#39;:&#39;)[1].split()    new_ele = [[i] * int(n_type[i - 1]) for i in range(1, len(n_type) + 1)]    new_ele = sum(new_ele, [])    # write    with open(filename, &quot;w&quot;) as f:        f.writelines(&quot;%s (written by ARES-NNP)\n\n&quot; % str(filename + strr))        f.writelines(&quot;%i    atoms\n&quot; % len(new_coo))        f.writelines(&quot;%i    atom types\n&quot; % len(Z_of_type))        f.writelines(&quot;0.0    %.17f  xlo xhi\n&quot; % lmp_lat[0][0])        f.writelines(&quot;0.0    %.17f  ylo yhi\n&quot; % lmp_lat[1][1])        f.writelines(&quot;0.0    %.17f  zlo zhi\n&quot; % lmp_lat[2][2])        f.writelines(            &quot;    %18.12f    %18.12f    %18.12f  xy xz yz\n\n\n&quot; % (lmp_lat[1][0], lmp_lat[2][0], lmp_lat[2][1]))        f.writelines(&quot;Atoms\n\n&quot;)        index_list = np.arange(1, len(new_coo) + 1)        for i, ele, coo in zip(index_list, new_ele, new_coo):            f.writelines(&quot;&#123;0:&gt;6&#125; &#123;1:&gt;3&#125; &#123;2:20.12f&#125; &#123;3:20.12f&#125; &#123;4:20.12f&#125;\n&quot;.format(i, ele, coo[0], coo[1], coo[2]))if __name__ == &#39;__main__&#39;:    filename = argv[2]    lat, pos, strr = anls_poscar(argv[1])    crs_para = np.linalg.norm(lat, axis=1)    exg = np.argsort(crs_para)[::-1]    lat = lat[exg, :]    pos = pos[:, exg]    lmp_lat = cart2lams(lat)    inv = np.linalg.inv(lat) @ lmp_lat    pos_c = direct2pos(lat, pos, True) @ inv    write_lmp_atomic_data(filename, lmp_lat, pos_c, strr)</code></pre><p>3-</p><pre><code class="python"># 字典：元素对应的赝势文件路径base_pseudo_path = &quot;/public/lijx/work/Na-X-Si-O/pot-makepot/potpaw_PBE/&quot;pseudo_paths = &#123;    &#39;H&#39;: &#39;H/POTCAR&#39;,    &#39;Li&#39;: &#39;Li_sv/POTCAR&#39;,    &#39;Be&#39;: &#39;Be_sv/POTCAR&#39;,    &#39;B&#39;: &#39;B/POTCAR&#39;,    &#39;C&#39;: &#39;C/POTCAR&#39;,    &#39;N&#39;: &#39;N/POTCAR&#39;,    &#39;O&#39;: &#39;O/POTCAR&#39;,    &#39;F&#39;: &#39;F/POTCAR&#39;,    &#39;Ne&#39;: &#39;Ne/POTCAR&#39;,    &#39;Na&#39;: &#39;Na_pv/POTCAR&#39;,    &#39;Mg&#39;: &#39;Mg_pv/POTCAR&#39;,    &#39;Al&#39;: &#39;Al/POTCAR&#39;,    &#39;Si&#39;: &#39;Si/POTCAR&#39;,    &#39;P&#39;: &#39;P/POTCAR&#39;,    &#39;S&#39;: &#39;S/POTCAR&#39;,    &#39;Cl&#39;: &#39;Cl/POTCAR&#39;,    &#39;K&#39;: &#39;K_sv/POTCAR&#39;,    &#39;Ca&#39;: &#39;Ca_sv/POTCAR&#39;,    &#39;Sc&#39;: &#39;Sc_sv/POTCAR&#39;,    &#39;Ti&#39;: &#39;Ti_pv/POTCAR&#39;,    &#39;V&#39;: &#39;V_pv/POTCAR&#39;,    &#39;Cr&#39;: &#39;Cr_pv/POTCAR&#39;,    &#39;Mn&#39;: &#39;Mn_pv/POTCAR&#39;,    &#39;Fe&#39;: &#39;Fe_pv/POTCAR&#39;,    &#39;Co&#39;: &#39;Co/POTCAR&#39;,    &#39;Ni&#39;: &#39;Ni_pv/POTCAR&#39;,    &#39;Cu&#39;: &#39;Cu_pv/POTCAR&#39;,    &#39;Zn&#39;: &#39;Zn/POTCAR&#39;,    &#39;Ga&#39;: &#39;Ga_d/POTCAR&#39;,    &#39;Ge&#39;: &#39;Ge_d/POTCAR&#39;,    &#39;As&#39;: &#39;As/POTCAR&#39;,    &#39;Se&#39;: &#39;Se/POTCAR&#39;,    &#39;Br&#39;: &#39;Br/POTCAR&#39;,    &#39;Kr&#39;: &#39;Kr/POTCAR&#39;,    &#39;Rb&#39;: &#39;Rb_sv/POTCAR&#39;,    &#39;Sr&#39;: &#39;Sr_sv/POTCAR&#39;,    &#39;Y&#39;: &#39;Y_sv/POTCAR&#39;,    &#39;Zr&#39;: &#39;Zr_sv/POTCAR&#39;,    &#39;Nb&#39;: &#39;Nb_pv/POTCAR&#39;,    &#39;Mo&#39;: &#39;Mo_pv/POTCAR&#39;,    &#39;Tc&#39;: &#39;Tc_pv/POTCAR&#39;,    &#39;Ru&#39;: &#39;Ru_pv/POTCAR&#39;,    &#39;Rh&#39;: &#39;Rh_pv/POTCAR&#39;,    &#39;Pd&#39;: &#39;Pd/POTCAR&#39;,    &#39;Ag&#39;: &#39;Ag/POTCAR&#39;,    &#39;Cd&#39;: &#39;Cd/POTCAR&#39;,    &#39;In&#39;: &#39;In_d/POTCAR&#39;,    &#39;Sn&#39;: &#39;Sn_d/POTCAR&#39;,    &#39;Sb&#39;: &#39;Sb/POTCAR&#39;,    &#39;Te&#39;: &#39;Te/POTCAR&#39;,    &#39;I&#39;: &#39;I/POTCAR&#39;,    &#39;Xe&#39;: &#39;Xe/POTCAR&#39;,    &#39;Cs&#39;: &#39;Cs_sv/POTCAR&#39;,    &#39;Ba&#39;: &#39;Ba_sv/POTCAR&#39;,    &#39;La&#39;: &#39;La/POTCAR&#39;,    &#39;Ce&#39;: &#39;Ce_3/POTCAR&#39;,    &#39;Pr&#39;: &#39;Pr_3/POTCAR&#39;,    &#39;Nd&#39;: &#39;Nd_3/POTCAR&#39;,    &#39;Pm&#39;: &#39;Pm_3/POTCAR&#39;,    &#39;Sm&#39;: &#39;Sm_3/POTCAR&#39;,    &#39;Eu&#39;: &#39;Eu_3/POTCAR&#39;,    &#39;Gd&#39;: &#39;Gd_3/POTCAR&#39;,    &#39;Tb&#39;: &#39;Tb_3/POTCAR&#39;,    &#39;Dy&#39;: &#39;Dy_3/POTCAR&#39;,    &#39;Ho&#39;: &#39;Ho_3/POTCAR&#39;,    &#39;Er&#39;: &#39;Er_3/POTCAR&#39;,    &#39;Tm&#39;: &#39;Tm_3/POTCAR&#39;,    &#39;Yb&#39;: &#39;Yb_2/POTCAR&#39;,    &#39;Lu&#39;: &#39;Lu_3/POTCAR&#39;,    &#39;Hf&#39;: &#39;Hf_pv/POTCAR&#39;,    &#39;Ta&#39;: &#39;Ta_pv/POTCAR&#39;,    &#39;W&#39;: &#39;W_pv/POTCAR&#39;,    &#39;Re&#39;: &#39;Re_pv/POTCAR&#39;,    &#39;Os&#39;: &#39;Os_pv/POTCAR&#39;,    &#39;Ir&#39;: &#39;Ir/POTCAR&#39;,    &#39;Pt&#39;: &#39;Pt/POTCAR&#39;,    &#39;Au&#39;: &#39;Au/POTCAR&#39;,    &#39;Hg&#39;: &#39;Hg/POTCAR&#39;,    &#39;Tl&#39;: &#39;Tl_d/POTCAR&#39;,    &#39;Pb&#39;: &#39;Pb_d/POTCAR&#39;,    &#39;Bi&#39;: &#39;Bi/POTCAR&#39;,    &#39;Th&#39;: &#39;Th/POTCAR&#39;,    &#39;Pa&#39;: &#39;Pa/POTCAR&#39;,    &#39;U&#39;: &#39;U/POTCAR&#39;,    &#39;Np&#39;: &#39;Np/POTCAR&#39;,    &#39;Pu&#39;: &#39;Pu/POTCAR&#39;,# 添加其他元素和对应的赝势路径&#125;for element, relative_path in pseudo_paths.items():    full_path = f&quot;&#123;base_pseudo_path&#125;&#123;relative_path&#125;&quot;    pseudo_paths[element] = full_path# 读取 POSCAR 文件def read_poscar(poscar_path):      with open(poscar_path, &#39;r&#39;) as f:          lines = f.readlines()          elements = lines[5].split()        periodic_table_order = [&#39;H&#39;, &#39;He&#39;, &#39;Li&#39;, &#39;Be&#39;, &#39;B&#39;, &#39;C&#39;, &#39;N&#39;, &#39;O&#39;, &#39;F&#39;, &#39;Ne&#39;,&#39;Na&#39;, &#39;Mg&#39;, &#39;Al&#39;, &#39;Si&#39;, &#39;P&#39;, &#39;S&#39;, &#39;Cl&#39;, &#39;Ar&#39;,&#39;K&#39;,&#39;Ca&#39;, &#39;Sc&#39;, &#39;Ti&#39;, &#39;V&#39;, &#39;Cr&#39;, &#39;Mn&#39;, &#39;Fe&#39;, &#39;Co&#39;,&#39;Ni&#39;, &#39;Cu&#39;, &#39;Zn&#39;,&#39;Ga&#39;, &#39;Ge&#39;, &#39;As&#39;, &#39;Se&#39;, &#39;Br&#39;, &#39;Kr&#39;, &#39;Rb&#39;, &#39;Sr&#39;, &#39;Y&#39;, &#39;Zr&#39;, &#39;Nb&#39;,&#39;Mo&#39;, &#39;Tc&#39;, &#39;Ru&#39;, &#39;Rh&#39;, &#39;Pd&#39;, &#39;Ag&#39;, &#39;Cd&#39;, &#39;In&#39;, &#39;Sn&#39;, &#39;Sb&#39;, &#39;Te&#39;,&#39;I&#39;, &#39;Xe&#39;, &#39;Cs&#39;, &#39;Ba&#39;, &#39;La&#39;, &#39;Ce&#39;, &#39;Pr&#39;, &#39;Nd&#39;, &#39;Pm&#39;, &#39;Sm&#39;, &#39;Eu&#39;,&#39;Gd&#39;, &#39;Tb&#39;, &#39;Dy&#39;, &#39;Ho&#39;, &#39;Er&#39;, &#39;Tm&#39;, &#39;Yb&#39;, &#39;Lu&#39;, &#39;Hf&#39;, &#39;Ta&#39;, &#39;W&#39;,&#39;Re&#39;, &#39;Os&#39;, &#39;Ir&#39;, &#39;Pt&#39;, &#39;Au&#39;, &#39;Hg&#39;, &#39;Tl&#39;, &#39;Pb&#39;, &#39;Bi&#39;, &#39;Po&#39;,&#39;At&#39;,&#39;Rn&#39;,&#39;Fr&#39;,&#39;Ra&#39;,&#39;Ac&#39;,&#39;Th&#39;, &#39;Pa&#39;,&#39;U&#39;, &#39;Np&#39;, &#39;Pu&#39;, &#39;Am&#39;, &#39;Cm&#39;, &#39;Bk&#39;, &#39;Cf&#39;, &#39;Es&#39;, &#39;Fm&#39;, &#39;Md&#39;, &#39;No&#39;, &#39;Lr&#39;]        sorted_elements = sorted(elements, key=lambda x: periodic_table_order.index(x))        return sorted_elements# 创建大的 POTCAR 文件def create_big_potcar(elements, pseudo_paths, output_path):    with open(output_path, &#39;w&#39;) as f_out:        for element in elements:            if element in pseudo_paths:                pseudo_path = pseudo_paths[element]                with open(pseudo_path, &#39;r&#39;) as f_pseudo:                    f_out.write(f_pseudo.read())            else:                print(f&quot;赝势文件不存在或未定义：&#123;element&#125;&quot;)def copypot(elments,pseudo_paths):    import os     for element in elements:        output_path2 = &quot;POT-&quot;+element        if element in pseudo_paths:            pseudo_path = pseudo_paths[element]            with open(output_path2, &#39;w&#39;) as f_out:                with open(pseudo_path, &#39;r&#39;) as f_pseudo:                    f_out.write(f_pseudo.read())        else:            print(f&quot;赝势文件不存在或未定义：&#123;element&#125;&quot;)            if __name__ == &quot;__main__&quot;:    poscar_path = &quot;POSCAR&quot;  # 输入文件名    output_potcar_path = &quot;POTCAR&quot;  # 输出的大 POTCAR 文件名    elements = read_poscar(poscar_path)    create_big_potcar(elements, pseudo_paths, output_potcar_path)    copypot(elements,pseudo_paths)    print(&quot;大的 POTCAR 文件已创建&quot;)</code></pre><p>nohup .&#x2F;scheduling.sh &gt; log 2&gt;&amp;1 &amp;</p><h2 id="3-华为新版本"><a href="#3-华为新版本" class="headerlink" title="3. 华为新版本"></a>3. 华为新版本</h2><h4 id="1-变化"><a href="#1-变化" class="headerlink" title="1.变化"></a>1.变化</h4><p>增加了server.sh </p><p>改变了iter_scheduling_remote.sh 现在，这两个都不需要做改变可以直接复制</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20231227085340259.png" alt="image-20231227085340259"></p><h4 id="2-技巧"><a href="#2-技巧" class="headerlink" title="2. 技巧"></a>2. 技巧</h4><h5 id="1-各个文件夹含义"><a href="#1-各个文件夹含义" class="headerlink" title="1.各个文件夹含义"></a>1.各个文件夹含义</h5><p>pre-select  :主动学习最后一步训练inv2里用的是train_dt，之前步用的看上去是pre-select，但实际上运行时用的也是train_dt</p><p>train_dt</p><p>非主动学习训练：只需要把主动学习inv2的restart改为false，不能删掉，记得更改inv2中cuda的编号，只申请了一张卡</p><p>如果一直训练出的只能跑几步，可以尝试修改select_thr      &#x3D;   2.0 为1.2</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;1-机器学习&quot;&gt;&lt;a href=&quot;#1-机器学习&quot; class=&quot;headerlink&quot; title=&quot;1.机器学习&quot;&gt;&lt;/a&gt;1.机器学习&lt;/h1&gt;&lt;h2 id=&quot;1-安装-V3-版本&quot;&gt;&lt;a href=&quot;#1-安装-V3-版本&quot; cl</summary>
      
    
    
    
    <category term="机器学习" scheme="http://example.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>晶格振动</title>
    <link href="http://example.com/2024/05/25/%E6%99%B6%E6%A0%BC%E6%8C%AF%E5%8A%A8/"/>
    <id>http://example.com/2024/05/25/%E6%99%B6%E6%A0%BC%E6%8C%AF%E5%8A%A8/</id>
    <published>2024-05-25T14:01:20.374Z</published>
    <updated>2024-05-25T12:00:29.933Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="1-晶格振动和晶体热学性质"><a href="#1-晶格振动和晶体热学性质" class="headerlink" title="1.晶格振动和晶体热学性质"></a>1.晶格振动和晶体热学性质</h1><p><a href="https://zhuanlan.zhihu.com/p/206648238">黄昆的《固体物理学》的第五章：晶格振动和晶体热学性质 - 知乎 (zhihu.com)</a></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230529100521027.png" alt="image-20230529100521027"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230529100531454.png" alt="image-20230529100531454"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230529100544548.png" alt="image-20230529100544548"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230529100605166.png" alt="image-20230529100605166"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230529100618229.png" alt="image-20230529100618229"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230529100629669.png" alt="image-20230529100629669"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230529100641715.png" alt="image-20230529100641715"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230529100652763.png" alt="image-20230529100652763"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230529100703279.png" alt="image-20230529100703279"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230529100711059.png" alt="image-20230529100711059"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230529100719044.png" alt="image-20230529100719044"></p><h1 id="2-简正坐标-声子"><a href="#2-简正坐标-声子" class="headerlink" title="2.简正坐标 声子"></a>2.简正坐标 声子</h1><p><a href="https://zhuanlan.zhihu.com/p/462245774">固体物理：2.3 谐振子能量 声子 - 知乎 (zhihu.com)</a></p><h2 id="1-广义坐标"><a href="#1-广义坐标" class="headerlink" title="1. 广义坐标"></a>1. 广义坐标</h2><p>​      1.   广义坐标就是在处理多物体的体系时，把整个体系看成一个物体，把多个物体（包括N自由度）的运动看成一个物体的不同部分在N维空间内的运动。但是区别于单个物体，一个体系物体内部的各部分的质量是不同的</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230619193505887.png" alt="image-20230619193505887"></p><p> 对于一个物体的能量，也可以按照自由度拆分为各个分能量</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230619193703700.png" alt="image-20230619193703700"></p><ol start="2"><li><p>原子链中格波的表达式</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230619193855965.png" alt="image-20230619193855965"></p></li></ol><p>​          每个独立格波，都是一维单原子链的运动。体系的运动，就是多个格波的叠加</p><p>​           分运动的叠加是矢量叠加，需要给各个运动乘上对应方向的单位矢量</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230619194110896.png" alt="image-20230619194110896"></p><ol start="3"><li>什么是坐标系：坐标系只不过是一种描述方式，只要找到两两不平行的一组向量，就能作为坐标系</li></ol><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230619194244393.png" alt="image-20230619194244393"></p><p>​                                 其中，$k&#x3D;m\frac{2\pi}{Na}, m&#x3D;1-N$ 对应N个独立格波</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230619194602615.png" alt="image-20230619194602615"></p><p>这样，可以把一个格波中所有原子的坐标改写为（把振动作为基本坐标）</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230619194755465.png" alt="image-20230619194755465"></p><p>也就是只沿着第一个方向有分量。看成是整个个体的振动</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230619194905667.png" alt="image-20230619194905667"></p><h2 id="2-声子"><a href="#2-声子" class="headerlink" title="2. 声子"></a>2. 声子</h2><p>&#x3D;&#x3D;引入简正坐标就是为了引入不同简正模式的叠加&#x3D;&#x3D;</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230619194950360.png" alt="image-20230619194950360"></p><p>经典理论中，谐振子的能量包括动能和势能</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230619195025489.png" alt="image-20230619195025489"></p><p>量子力学中，谐振子的能量为</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230619195119335.png" alt="image-20230619195119335"></p><p>声子就是一个个的能量单元</p><h2 id="3-玻色爱因斯坦分布"><a href="#3-玻色爱因斯坦分布" class="headerlink" title="3. 玻色爱因斯坦分布"></a>3. 玻色爱因斯坦分布</h2><p>晶体中的振动总能就是所有独立格波能量的累加，原子坐标就看成n个简正坐标的叠加</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230619195401810.png" alt="image-20230619195401810"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230619195419417.png" alt="image-20230619195419417"></p><p>每个格波都对应着一定数量的声子</p><p>温度升高，所有格波的声子数都增加，温度下降，声子数减小，这也符合温度越大能量越高的判断</p><p>一个独立格波的平均能量就变成</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230619195549761.png" alt="image-20230619195549761"></p><p>T&#x3D;0 K时，声子树趋近于零，但是格波的能量不为零，存在零点能 <img src="/./../../%E5%9B%BE%E7%89%87/image-20230619195651927.png" alt="image-20230619195651927"></p><p>当温度很高时</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230619195709149.png" alt="image-20230619195709149"></p><p>这个时候一个格波的能量和温度T成正比</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230619195742758.png" alt="image-20230619195742758"></p><p>可以用来解决热容得问题，三维单原子链中有3N个独立格波</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230619195834864.png" alt="image-20230619195834864"></p><h1 id="3-态密度"><a href="#3-态密度" class="headerlink" title="3. 态密度"></a>3. 态密度</h1><p>独立格波的总数&#x3D;总的自由度数&#x3D;维数*原子数&#x3D;原胞数*维数*单个原胞内的原子个数</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230619200644243.png" alt="image-20230619200644243"></p><p>绘制一张图，横坐标是频率，纵坐标是对应的能量</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230619200814442.png" alt="image-20230619200814442"></p><p>要计算总能，只需要对w积分，但是这里把无穷变为积分还需要打个补丁，考虑落在w-dw范围内的模式数是多少，也就是模式密度</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230619200933075.png" alt="image-20230619200933075"></p><p>给模式密度积分，就能得到独立格波总数</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230619201218235.png" alt="image-20230619201218235"></p><p>g(w)横坐标是w，纵坐标是不同的模式数</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230619201342762.png" alt="image-20230619201342762"></p><p>g(w)的值有些地方密集，有些地方分散每一处的模式密度都不同。模式密度处处不同，但是模式对应的波矢是均匀分布的。</p><p>&#x3D;&#x3D;波矢空间的密度分布&#x3D;&#x3D;</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230619201601839.png" alt="image-20230619201601839"></p><p>仿照g(w),可以定义一个单位波矢空间间隔内的振动模式数量，称为波矢密度</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230619201740595.png" alt="image-20230619201740595"></p><p>可以得到p(k)是一个常数</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230619201941371.png" alt="image-20230619201941371"></p><p>联系两个式子</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230619202130428.png" alt="image-20230619202130428"></p><p>例如</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230619202200090.png" alt="image-20230619202200090"></p><p>下面可以计算格波的总能量</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230619202349749.png" alt="image-20230619202349749"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230619202409453.png" alt="image-20230619202409453"></p><p>色散关系很重要</p><h1 id="4-晶格热容"><a href="#4-晶格热容" class="headerlink" title="4. 晶格热容"></a>4. 晶格热容</h1><p>计算固体的热容，主要需要求声子的总能量。总能量等于各格波的能量叠加</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230619202604994.png" alt="image-20230619202604994"></p><p>确定态密度最关键的是知道色散关系</p><p>杜隆-波提 </p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230619202930486.png" alt="image-20230619202930486"></p><p>爱因斯坦模型直接定义有3N个谐振子（考虑了分布，有温度的效应）</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230619202848068.png" alt="image-20230619202848068"></p><p>德拜模型，考虑了线性的色散关系 w&#x3D;cK  （连续介质弹性波）</p><h1 id="5-固体物理-from-simon"><a href="#5-固体物理-from-simon" class="headerlink" title="5 固体物理 from simon"></a>5 固体物理 from simon</h1><ul><li>非简谐性质：非抛物线形状的势能曲线</li></ul><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20240514150953237.png" alt="image-20240514150953237"></p><p>热膨胀：在温度升高时，x$<em>{max}$ 要大于x$</em>{min}$ ，导致原子间距离的平均值向右侧移动，晶格体积膨胀。平衡位置是能量最小值，但是不是原子振动的平均值（在小振动时由于是抛物线，所以相等，但是在高温下，不再是抛物线形状</p><p>&#x3D;&#x3D;热膨胀本身对应着非简谐性&#x3D;&#x3D;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;1-晶格振动和晶体热学性质&quot;&gt;&lt;a href=&quot;#1-晶格振动和晶体热学性质&quot; class=&quot;headerlink&quot; title=&quot;1.晶格振动和晶体热学性质&quot;&gt;&lt;/a&gt;1.晶格振动和晶体热学性质&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http</summary>
      
    
    
    
    <category term="课题研究" scheme="http://example.com/categories/%E8%AF%BE%E9%A2%98%E7%A0%94%E7%A9%B6/"/>
    
    <category term="离子输运与晶格振动" scheme="http://example.com/categories/%E8%AF%BE%E9%A2%98%E7%A0%94%E7%A9%B6/%E7%A6%BB%E5%AD%90%E8%BE%93%E8%BF%90%E4%B8%8E%E6%99%B6%E6%A0%BC%E6%8C%AF%E5%8A%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>处理分数占据结构</title>
    <link href="http://example.com/2024/05/25/%E5%A4%84%E7%90%86%E5%88%86%E6%95%B0%E5%8D%A0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2024/05/25/%E5%A4%84%E7%90%86%E5%88%86%E6%95%B0%E5%8D%A0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2024-05-25T14:01:20.372Z</published>
    <updated>2024-05-25T15:12:22.377Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="1-pymatgen检验相同结构"><a href="#1-pymatgen检验相同结构" class="headerlink" title="1.pymatgen检验相同结构"></a>1.pymatgen检验相同结构</h1><p>fcc、bcc等对应着特殊空间群里特定位置的占据</p><h2 id="1-一次性检验"><a href="#1-一次性检验" class="headerlink" title="1.一次性检验"></a>1.一次性检验</h2><pre><code class="python">import os from pymatgen.core import Structurefrom pymatgen.io.vasp.sets import batch_write_input, MPRelaxSetfrom pymatgen.io.vasp.inputs import Poscarstandard_structures= []dir=&#39;./&#39;for i in range(1000):    filename = &quot;&#123;&#125;.vasp&quot;.format(i)    if not os.path.exists(os.path.join(dir,filename)):        continue    print(filename)    structure = Structure.from_file(filename)    structure.remove_species(&quot;O&quot;)    standard_structures.append(structure)from pymatgen.analysis.structure_matcher import StructureMatchermatcher = StructureMatcher()groups = matcher.group_structures([d for d in standard_structures])print(len(groups))groupstructures = [x[0] for x in groups]  # 将嵌套列表的每个列表的第一个元素提取出来做成一个新列表from pymatgen.io.vasp.inputs import Poscarn = 0for Cry_Str in groupstructures:    #print(Cry_Str)    Vasp_Str = Poscar(Cry_Str)    n = n+1    Vasp_Str.write_file(&#39;%dnew.vasp&#39;%n)</code></pre><h2 id="2-逐个检验"><a href="#2-逐个检验" class="headerlink" title="2.逐个检验"></a>2.逐个检验</h2><pre><code class="python">import numpy as npimport sys,os,timefrom pymatgen.core import Structurefrom pymatgen.analysis.structure_matcher import StructureMatchermatcher = StructureMatcher()all_str = []for i in range(1,100000):    file = f&#39;&#123;i&#125;.vasp&#39;    if not os.path.exists(file):       continue    print(file)    strua = Structure.from_file(file)    match_found = False    for str in all_str:        if matcher.fit(strua,str):           match_found = True           break    if not match_found:        all_str.append(strua)        print(&#39;%d structures&#39; % len(all_str))from pymatgen.io.vasp.inputs import Poscarn = 0for strua in all_str:    Vasp_Str = Poscar(strua)    n +=1    Vasp_Str.write_file(&#39;%dnew.vasp&#39;%n)</code></pre><h2 id="3-检验两个结构"><a href="#3-检验两个结构" class="headerlink" title="3. 检验两个结构"></a>3. 检验两个结构</h2><pre><code class="python">import numpy as npimport sys,os,timefrom pymatgen.core import Structurefrom pymatgen.analysis.structure_matcher import StructureMatchermatcher = StructureMatcher()aa = Structure.from_file(&#39;16.vasp&#39;)bb = Structure.from_file(&#39;4199.vasp&#39;)matcher.fit(aa,bb)</code></pre><h1 id="2-pymatgen-enumeration"><a href="#2-pymatgen-enumeration" class="headerlink" title="2. pymatgen-enumeration"></a>2. pymatgen-enumeration</h1><pre><code class="python">from pymatgen.core import Structurefrom pymatgen.symmetry.analyzer import SpacegroupAnalyzerfrom pymatgen.transformations.advanced_transformations import EnumerateStructureTransformationfrom pymatgen.io.vasp.sets import batch_write_input, MPRelaxSetfrom pymatgen.analysis.energy_models import EwaldElectrostaticModelfrom pymatgen.analysis.bond_valence import BVAnalyzerstructure = Structure.from_file(&quot;a.cif&quot;)data = &#123;&quot;Na&quot;:1, &quot;Y&quot;:3, &quot;Si&quot;:4,&quot;O&quot;:-2,&quot;Al&quot;:3,&quot;K&quot;:1&#125;analyzer = SpacegroupAnalyzer(structure)prim_cell = analyzer.find_primitive()prim_cell.add_oxidation_state_by_element(data)#print(prim_cell)enum = EnumerateStructureTransformation()enumerated = enum.apply_transformation(prim_cell, 100)structures = [d[&quot;structure&quot;] for d in enumerated]print(&quot;%d structures returned.&quot; % len(structures))from pymatgen.io.vasp.inputs import Poscarn = 0for Cry_Str in structures:    #print(Cry_Str)    Vasp_Str = Poscar(Cry_Str)    n = n+1    Vasp_Str.write_file(&#39;%d.vasp&#39;%n)#from pymatgen.io.cif import CifWriter#n = 0#for Cry_Str in structures:#    n = n + 1#    cif_filename = f&quot;&#123;n&#125;.cif&quot;#    cif_writer = CifWriter(Cry_Str)#    cif_writer.write_file(cif_filename)   #energy= [d[&quot;energy&quot;] for d in enumerated]#fl = open(&#39;energy.dat&#39;,&#39;w&#39;)#fl.writelines(str(energy))#data = &#123;&quot;K&quot;:1, &quot;O&quot;:-2, &quot;Fe&quot;:2,&quot;Ti&quot;:4.25,&quot;Mn&quot;:3.75&#125;#abc=[]#for i in range(1,101):#    m = Structure.from_file(&#39;%d.vasp&#39;%i)#    m.add_oxidation_state_by_element(data)#    energy = EwaldElectrostaticModel().get_energy(m)#    abc.append(energy)#f2 = open(&#39;energy2.dat&#39;,&#39;w&#39;)#f2.writelines(str(abc))with open(&#39;energy.dat&#39;, &#39;w&#39;) as f:    for item in abc:        f.write(str(item) + &#39;\n&#39;)#strcturelist2.sort(key = EwaldElectrostaticModel().get_energy)</code></pre><h1 id="3-pymatgen-orderdisorder"><a href="#3-pymatgen-orderdisorder" class="headerlink" title="3. pymatgen-orderdisorder"></a>3. pymatgen-orderdisorder</h1><pre><code class="python">import osfrom pymatgen.io.cif import CifParser, CifWriterfrom pymatgen.transformations.standard_transformations import SubstitutionTransformation, OrderDisorderedStructureTransformation, SupercellTransformationfrom pymatgen.core import Structurefrom pymatgen.symmetry.analyzer import SpacegroupAnalyzerfrom pymatgen.analysis.energy_models import EwaldElectrostaticModelfrom pymatgen.transformations.advanced_transformations import EnumerateStructureTransformationfrom pymatgen.io.vasp.sets import batch_write_input, MPRelaxSetfrom pymatgen.io.vasp.inputs import Poscarstructure = Structure.from_file(&quot;a.cif&quot;)data = &#123;&quot;Ni&quot;:2, &quot;Co&quot;:3, &quot;S&quot;:-2,&quot;Se&quot;:-2&#125;analyzer = SpacegroupAnalyzer(structure)prim_cell = analyzer.find_primitive()prim_cell.add_oxidation_state_by_element(data)print(prim_cell)order = OrderDisorderedStructureTransformation()standard_structures=order.apply_transformation(prim_cell,return_ranked_list=1000)from pymatgen.analysis.structure_matcher import StructureMatchermatcher = StructureMatcher()groups = matcher.group_structures([d[&quot;structure&quot;] for d in standard_structures]) #这应该是个字典，把字典中的structure关键字提出来组&gt;成列表,groups里只剩下结构了#structures = [d[&quot;structure&quot;] for d in standard_structures]#print(&quot;%d structures returned.&quot; % len(structures))#from pymatgen.io.vasp.inputs import Poscar#n = 0#for Cry_Str in structures:    #print(Cry_Str)#    Vasp_Str = Poscar(Cry_Str)#    n = n+1#    Vasp_Str.write_file(&#39;%d.vasp&#39;%n)groupstructures = [x[0] for x in groups]  # 将嵌套列表的每个列表的第一个元素提取出来做成一个新列表from pymatgen.io.vasp.inputs import Poscarn = 0for Cry_Str in groupstructures:    #print(Cry_Str)    Vasp_Str = Poscar(Cry_Str)    n = n+1    Vasp_Str.write_file(&#39;%d.vasp&#39;%n)#产生等差数列 for i in range(len(groups))#提取出列举时计算的能量 energy = [x(&#39;energy&#39;) for x in standard_structures]#验证同一类群下的结构静电能相等#suoyoua = [x for x in groups[0]]#for cry in suoyoua:#   energy = EwaldElectrostaticModel().get_energy(cry)#  print(energy)#验证输出的顺序是按照能量升序进行的#suoyou1 = [x[0] for x in groups]#for cry in suoyou1:#    energy = EwaldElectrostaticModel().get_energy(cry)#    print(energy)</code></pre><h1 id="4-计算静电能"><a href="#4-计算静电能" class="headerlink" title="4.计算静电能"></a>4.计算静电能</h1><pre><code class="python">import osfrom pymatgen.core import Structurefrom pymatgen.io.vasp.inputs import Poscarfrom pymatgen.analysis.energy_models import EwaldElectrostaticModelabc=[]data = &#123;&quot;Ca&quot;:-6, &quot;H&quot;:1&#125;for i in range(1,5034):    m = Structure.from_file(&#39;%d.vasp&#39;%i)    m.add_oxidation_state_by_element(data)    energy = EwaldElectrostaticModel().get_energy(m)    abc.append(energy)with open(&#39;energy.dat&#39;, &#39;w&#39;) as f:    for item in abc:        f.write(str(item) + &#39;\n&#39;)    </code></pre><h1 id="5-sqs"><a href="#5-sqs" class="headerlink" title="5. sqs"></a>5. sqs</h1><h2 id="1-前处理"><a href="#1-前处理" class="headerlink" title="1.前处理"></a>1.前处理</h2><h3 id="1-转换rndstr格式的结构"><a href="#1-转换rndstr格式的结构" class="headerlink" title="1. 转换rndstr格式的结构"></a><strong>1. 转换rndstr格式的结构</strong></h3><pre><code class="python">from pymatgen.core import Structurestructure = Structure.from_file(&quot;a.cif&quot;)structure.to(filename=&#39;rndstr.in&#39;)</code></pre><h3 id="2-提交多个ip的任务"><a href="#2-提交多个ip的任务" class="headerlink" title="2.提交多个ip的任务"></a><strong>2.提交多个ip的任务</strong></h3><pre><code class="shell">for i in $(seq 1 1 20)docat &gt; sqs_$i.slurm &lt;&lt; liz#!/bin/sh#SBATCH -J analyze#SBATCH -p xieyu#SBATCH -N 1#SBATCH -n 1#SBATCH -w c0406source activate lizmcsqs -n=36 -ip=$ilizsbatch sqs_$i.slurmdone#grep Objective_function bestcorr*.out|sort -n</code></pre><h2 id="2-后处理"><a href="#2-后处理" class="headerlink" title="2. 后处理"></a>2. 后处理</h2><h3 id="1-提取bestcorr"><a href="#1-提取bestcorr" class="headerlink" title="1. 提取bestcorr"></a><strong>1. 提取bestcorr</strong></h3><pre><code class="shell">for i in $(seq 1 1 12)dotail -n 1 bestcorr.out &gt;&gt; corr.datdone</code></pre><h3 id="2-对多任务ip产生的best-out文件处理"><a href="#2-对多任务ip产生的best-out文件处理" class="headerlink" title="2.对多任务ip产生的best.out文件处理"></a><strong>2.对多任务ip产生的best.out文件处理</strong></h3><p>&#x3D;&#x3D;<strong>注意，数字前的空格会对结构在vesta中的显示产生影响</strong>&#x3D;&#x3D; </p><blockquote><p><strong>sqs2poscar文件在 同步空间&#x2F;计算脚本&#x2F;sqs处</strong></p></blockquote><pre><code class="shell">for i in $(seq 1 1 12)do ./sqs2poscar bestsqs$i.outmv bestsqs$i.out-POSCAR $i.vaspsed -i &#39;2s/.*/1/&#39; $i.vaspsed -i &#39;3s/-10\.57524/ -10.57524/&#39; $i.vaspdone </code></pre><h3 id="3-检验相同的结构"><a href="#3-检验相同的结构" class="headerlink" title="3. 检验相同的结构"></a><strong>3. 检验相同的结构</strong></h3><pre><code class="python">import osfrom pymatgen.core import Structurefrom pymatgen.io.vasp.sets import batch_write_input, MPRelaxSetfrom pymatgen.io.vasp.inputs import Poscarstandard_structures= []for i in range(1,13):    filename = &quot;&#123;&#125;.vasp&quot;.format(i)    print(filename)    structure = Structure.from_file(filename)    standard_structures.append(structure)from pymatgen.analysis.structure_matcher import StructureMatchermatcher = StructureMatcher()groups = matcher.group_structures([d for d in standard_structures])  #这应该是个字典，把字典中的structure关键字提出来组成列表,groups里只剩下结构了#structures = [d[&quot;structure&quot;] for d in standard_structures]#print(&quot;%d structures returned.&quot; % len(structures))#from pymatgen.io.vasp.inputs import Poscar#n = 0#for Cry_Str in structures:    #print(Cry_Str)#    Vasp_Str = Poscar(Cry_Str)#    n = n+1#    Vasp_Str.write_file(&#39;%d.vasp&#39;%n)print(len(groups))groupstructures = [x[0] for x in groups]  # 将嵌套列表的每个列表的第一个元素提取出来做成一个新列表from pymatgen.io.vasp.inputs import Poscarn = 0for Cry_Str in groupstructures:    #print(Cry_Str)    Vasp_Str = Poscar(Cry_Str)    n = n+1    Vasp_Str.write_file(&#39;%dnew.vasp&#39;%n)#产生等差数列 for i in range(len(groups))#提取出列举时计算的能量 energy = [x(&#39;energy&#39;) for x in standard_structures]#验证同一类群下的结构静电能相等#suoyoua = [x for x in groups[0]]#for cry in suoyoua:#   energy = EwaldElectrostaticModel().get_energy(cry)#  print(energy)#验证输出的顺序是按照能量升序进行的#suoyou1 = [x[0] for x in groups]#for cry in suoyou1:#    energy = EwaldElectrostaticModel().get_energy(cry)#    print(energy)</code></pre><h1 id="6-暴力枚举"><a href="#6-暴力枚举" class="headerlink" title="6.暴力枚举"></a>6.暴力枚举</h1><h2 id="1-枚举脚本"><a href="#1-枚举脚本" class="headerlink" title="1.枚举脚本"></a>1.枚举脚本</h2><p>在替换多种元素时，可以只替换一种元素，然后在生成的poscar中直接修改元素种类和个数</p><pre><code class="python">#!/usr/bin/python2#Change the format of crystal structure#python Str_Format.py infile outfiletry:    from pymatgen.core.structure          import IStructure, Structure    from pymatgen.io.vasp.inputs          import Poscarexcept:    print (&#39;You should install pymatgen first.&#39;)    exit(0)from monty.io import zopenimport randomimport sys,os,timeimport numpy as npdef readvasp(infile):    with zopen(infile, &quot;rt&quot;) as f:        contents = f.read()    Cry_Str = IStructure.from_str(contents, fmt=&quot;poscar&quot;)    lattice = Cry_Str.lattice    species = [ x.species.elements[0] for x in Cry_Str.sites ]    coords  = [ x.coords for x in Cry_Str.sites ]    Cry_Str = Structure(lattice,species,coords,coords_are_cartesian=True)    return Cry_Strdef replace(Cry_Str, replace_list, outfile):    natom = len(Cry_Str.sites)    for ele in replace_list:        for i in ele[0]:            Cry_Str.replace(i,ele[1])    Cry_Str.sort()    Vasp_Str = Poscar(Cry_Str)    Vasp_Str.write_file(outfile)    returnif __name__ == &#39;__main__&#39;:    instr = &#39;a.vasp&#39;    Cry_Str = readvasp(instr)    #modify    Cry_Str.make_supercell([1,1,1])    for i in range(10):        Cry_tp = Cry_Str.copy()        re_index = np.arange(28,82)        np.random.shuffle(re_index)        re_index1 = re_index[:3]        re_index2 = re_index[7:9]        replace_list = [ [re_index1, &#39;B&#39;],[re_index2,&#39;O&#39;] ]        tmp = &#39;%d.vasp&#39;%i        replace(Cry_tp, replace_list, tmp)</code></pre><h2 id="2-多任务脚本-检验相同结构"><a href="#2-多任务脚本-检验相同结构" class="headerlink" title="2. 多任务脚本 检验相同结构"></a>2. 多任务脚本 检验相同结构</h2><pre><code class="shell">for i in $(seq 0 1000 25000)do cat &gt; job_$i.sh &lt;&lt; liz#!/bin/sh#SBATCH -J liz#SBATCH -p xieyu#SBATCH -N 1#SBATCH -n 1#SBATCH -w c0607source activate lizpython jianyan_$i.pylizcat &gt; jianyan_$i.py &lt;&lt; lizimport osfrom pymatgen.core import Structurefrom pymatgen.io.vasp.sets import batch_write_input, MPRelaxSetfrom pymatgen.io.vasp.inputs import Poscarstandard_structures= []dir=&#39;/work/home/liz/workspace/D-LuNH-sqs/2-Lu-25电子/1-暴力破解/3-zuhe&#39;for i in range($i,$((i+1000))):    filename = &quot;&#123;&#125;.vasp&quot;.format(i)    if not os.path.exists(os.path.join(dir,filename)):        continue    print(filename)    structure = Structure.from_file(filename)    standard_structures.append(structure)from pymatgen.analysis.structure_matcher import StructureMatchermatcher = StructureMatcher()groups = matcher.group_structures([d for d in standard_structures])print(len(groups))groupstructures = [x[0] for x in groups]  # 将嵌套列表的每个列表的第一个元素提取出来做成一个新列表from pymatgen.io.vasp.inputs import Poscarn = $ifor Cry_Str in groupstructures:    #print(Cry_Str)    Vasp_Str = Poscar(Cry_Str)    n = n+1    Vasp_Str.write_file(&#39;%dnew.vasp&#39;%n)lizsbatch job_$i.shdone</code></pre><h2 id="3-改良版"><a href="#3-改良版" class="headerlink" title="3.改良版"></a>3.改良版</h2><h3 id="1-限定最小距离"><a href="#1-限定最小距离" class="headerlink" title="1.限定最小距离"></a>1.限定最小距离</h3><pre><code class="python">from pymatgen.core.structure import IStructure, Structurefrom pymatgen.io.vasp.inputs import Poscarfrom monty.io import zopenimport randomimport sys,os,timeimport numpy as npfrom pymatgen.core import Structurestrua = Structure.from_file(&quot;a.vasp&quot;)#print(strua.sites[re_index1[1]])#print(strua.get_distance(re_index1[0],re_index1[1]))#a_frac_coords=strua.sites[re_index1[0]].frac_coords#b_frac_coords=strua.sites[re_index1[1]].frac_coords#c_frac_coords=strua.sites[re_index1[2]].frac_coords#arr1=a_frac_coords-b_frac_coords#arr1[arr1 &gt;= 0.5] = 1#arr1[arr1 &lt;= -0.5] = -1#arr1[np.logical_and(arr1 &gt; -0.5, arr1 &lt; 0.5)] = 0#print(arr1)#strua.sites[re_index1[1]].frac_coords +=arr1#print(strua.sites[re_index1[1]])#print(strua.get_distance(re_index1[0],re_index1[1]))#diff1=np.sqrt(np.dot(strua.sites[re_index1[0]].coords-strua.sites[re_index1[1]].coords,strua.sites[re_index1[0]].coords-strua.sites[re_index1[1]].coords))#if diff1&lt;3#print(strua.sites[re_index1[1]].frac_coords)#h2=a_frac_coords-c_frac_coords#h3=b_frac_coords-c_frac_coords#lattice = strua.lattice#lattice_matrix =np.array(lattice.matrix)#coords  = [ x.coords for x in strua.sites ]#矩阵乘法 np.dot(A,B)#矩阵改变维数 A.reshape(1,3)#sites从0开始#np.dot(a,a)求平方和#strua.sites[0].coords 输出笛卡尔坐标 .frac_coords分数坐标#print(np.sqrt(np.dot(strua.sites[70].coords-strua.sites[71].coords,strua.sites[70].coords-strua.sites[71].coords)))#求两个原子的距离for i in range(20):    Cry_tp = strua.copy()    re_index = np.arange(27,82)    np.random.shuffle(re_index)    re_index1 = re_index[:3]    replace_list = [ [re_index1, &#39;N&#39;] ]    if Cry_tp.get_distance(re_index1[0],re_index1[1])&lt;3.6 or Cry_tp.get_distance(re_index1[0],re_index1[2])&lt;3.6 or Cry_tp.get_distance(re_index1[1],re_index1[2])&lt;3.6:        continue    for ele in replace_list:        for j in ele[0]:            Cry_tp.replace(j,ele[1])    Cry_tp.sort()    Vasp_Str = Poscar(Cry_tp)    Vasp_Str.write_file(&#39;%d.vasp&#39;%i)</code></pre><h3 id="2-限定最小距离且保证替代发生在不同的位置"><a href="#2-限定最小距离且保证替代发生在不同的位置" class="headerlink" title="2.限定最小距离且保证替代发生在不同的位置"></a>2.限定最小距离且保证替代发生在不同的位置</h3><pre><code class="python">from pymatgen.core.structure import IStructure, Structurefrom pymatgen.io.vasp.inputs import Poscarfrom monty.io import zopenimport randomimport sys,os,timeimport numpy as npfrom pymatgen.core import Structurestrua = Structure.from_file(&quot;a.vasp&quot;)#print(strua.sites[re_index1[1]])#print(strua.get_distance(re_index1[0],re_index1[1]))#a_frac_coords=strua.sites[re_index1[0]].frac_coords#b_frac_coords=strua.sites[re_index1[1]].frac_coords#c_frac_coords=strua.sites[re_index1[2]].frac_coords#arr1=a_frac_coords-b_frac_coords#arr1[arr1 &gt;= 0.5] = 1#arr1[arr1 &lt;= -0.5] = -1#arr1[np.logical_and(arr1 &gt; -0.5, arr1 &lt; 0.5)] = 0#print(arr1)#strua.sites[re_index1[1]].frac_coords +=arr1#print(strua.sites[re_index1[1]])#print(strua.get_distance(re_index1[0],re_index1[1]))#diff1=np.sqrt(np.dot(strua.sites[re_index1[0]].coords-strua.sites[re_index1[1]].coords,strua.sites[re_index1[0]].coords-strua.sites[re_index1[1]].coords))#if diff1&lt;3#print(strua.sites[re_index1[1]].frac_coords)#h2=a_frac_coords-c_frac_coords#h3=b_frac_coords-c_frac_coords#lattice = strua.lattice#lattice_matrix =np.array(lattice.matrix)#coords  = [ x.coords for x in strua.sites ]#矩阵乘法 np.dot(A,B)#矩阵改变维数 A.reshape(1,3)#sites从0开始#np.dot(a,a)求平方和#strua.sites[0].coords 输出笛卡尔坐标 .frac_coords分数坐标#print(np.sqrt(np.dot(strua.sites[70].coords-strua.sites[71].coords,strua.sites[70].coords-strua.sites[71].coords)))#求两个原子的距离for i in range(20):    Cry_tp = strua.copy()    re_index = np.arange(27,108)    np.random.shuffle(re_index)    re_index1 = re_index[:3]    if all(27&lt;= num &lt;=53 for num in re_index1):        continue    if all(54&lt;= num &lt;=107 for num in re_index1):        continue    replace_list = [ [re_index1, &#39;N&#39;] ]    if Cry_tp.get_distance(re_index1[0],re_index1[1])&lt;3.6 or Cry_tp.get_distance(re_index1[0],re_index1[2])&lt;3.6 or Cry_tp.get_distance(re_index1[1],re_index1[2])&lt;3.6:        continue    for ele in replace_list:        for j in ele[0]:            Cry_tp.replace(j,ele[1])    Cry_tp.sort()    Vasp_Str = Poscar(Cry_tp)    Vasp_Str.write_file(&#39;%d.vasp&#39;%i)</code></pre><h3 id="3-限定空间群"><a href="#3-限定空间群" class="headerlink" title="3.限定空间群"></a>3.限定空间群</h3><pre><code class="python">from pymatgen.core.structure import IStructure, Structurefrom pymatgen.io.vasp.inputs import Poscarfrom monty.io import zopenimport randomimport sys,os,timeimport numpy as npfrom pymatgen.core import Structurefrom pymatgen.symmetry.analyzer import SpacegroupAnalyzerfrom pymatgen.analysis.structure_matcher import StructureMatcherstrua = Structure.from_file(&quot;a.vasp&quot;)#print(strua.sites[re_index1[1]])#print(strua.get_distance(re_index1[0],re_index1[1]))#a_frac_coords=strua.sites[re_index1[0]].frac_coords#b_frac_coords=strua.sites[re_index1[1]].frac_coords#c_frac_coords=strua.sites[re_index1[2]].frac_coords#arr1=a_frac_coords-b_frac_coords#arr1[arr1 &gt;= 0.5] = 1#arr1[arr1 &lt;= -0.5] = -1#arr1[np.logical_and(arr1 &gt; -0.5, arr1 &lt; 0.5)] = 0#print(arr1)#strua.sites[re_index1[1]].frac_coords +=arr1#print(strua.sites[re_index1[1]])#print(strua.get_distance(re_index1[0],re_index1[1]))#diff1=np.sqrt(np.dot(strua.sites[re_index1[0]].coords-strua.sites[re_index1[1]].coords,strua.sites[re_index1[0]].coords-strua.sites[re_index1[1]].coords))#if diff1&lt;3#print(strua.sites[re_index1[1]].frac_coords)#h2=a_frac_coords-c_frac_coords#h3=b_frac_coords-c_frac_coords#lattice = strua.lattice#lattice_matrix =np.array(lattice.matrix)#coords  = [ x.coords for x in strua.sites ]#矩阵乘法 np.dot(A,B)#矩阵改变维数 A.reshape(1,3)#sites从0开始#np.dot(a,a)求平方和#strua.sites[0].coords 输出笛卡尔坐标 .frac_coords分数坐标#print(np.sqrt(np.dot(strua.sites[70].coords-strua.sites[71].coords,strua.sites[70].coords-strua.sites[71].coords)))#求两个原子的距离total_structure=[]for i in range(200000):    Cry_tp = strua.copy()    re_index = np.arange(0,96)    np.random.shuffle(re_index)    re_index1 = re_index[:4]    Cry_tp.remove_sites(re_index1)    a=SpacegroupAnalyzer(Cry_tp).get_space_group_number()    if a&lt;= 140:      continue    print(i)    print(a)    Vasp_Str = Poscar(Cry_tp)    Vasp_Str.write_file(&#39;%d.vasp&#39;%i)    total_structure.append(Cry_tp)matcher = StructureMatcher()groups = matcher.group_structures([d for d in total_structure])groupstructures = [x[0] for x in groups]from pymatgen.io.vasp.inputs import Poscarn = 10001for Cry_Str in groupstructures:    #print(Cry_Str)    Vasp_Str = Poscar(Cry_Str)    n = n+1    Vasp_Str.write_file(&#39;%dnew.vasp&#39;%n)</code></pre><h3 id="4-多任务做改良版"><a href="#4-多任务做改良版" class="headerlink" title="4.多任务做改良版"></a>4.多任务做改良版</h3><pre><code class="shell">for i in $(seq 1 100 10100)docat &gt; baoli_$i.py &lt;&lt; lizfrom pymatgen.core.structure import IStructure, Structurefrom pymatgen.io.vasp.inputs import Poscarfrom monty.io import zopenimport randomimport sys,os,timeimport numpy as npfrom pymatgen.core import Structurefrom pymatgen.symmetry.analyzer import SpacegroupAnalyzerfrom pymatgen.analysis.structure_matcher import StructureMatcherstrua = Structure.from_file(&quot;a.vasp&quot;)#print(strua.sites[re_index1[1]])#print(strua.get_distance(re_index1[0],re_index1[1]))#a_frac_coords=strua.sites[re_index1[0]].frac_coords#b_frac_coords=strua.sites[re_index1[1]].frac_coords#c_frac_coords=strua.sites[re_index1[2]].frac_coords#arr1=a_frac_coords-b_frac_coords#arr1[arr1 &gt;= 0.5] = 1#arr1[arr1 &lt;= -0.5] = -1#arr1[np.logical_and(arr1 &gt; -0.5, arr1 &lt; 0.5)] = 0#print(arr1)#strua.sites[re_index1[1]].frac_coords +=arr1#print(strua.sites[re_index1[1]])#print(strua.get_distance(re_index1[0],re_index1[1]))#diff1=np.sqrt(np.dot(strua.sites[re_index1[0]].coords-strua.sites[re_index1[1]].coords,strua.sites[re_index1[0]].coords-strua.sites[re_index1[1]].coords))#if diff1&lt;3#print(strua.sites[re_index1[1]].frac_coords)#h2=a_frac_coords-c_frac_coords#h3=b_frac_coords-c_frac_coords#lattice = strua.lattice#lattice_matrix =np.array(lattice.matrix)#coords  = [ x.coords for x in strua.sites ]#矩阵乘法 np.dot(A,B)#矩阵改变维数 A.reshape(1,3)#sites从0开始#np.dot(a,a)求平方和#strua.sites[0].coords 输出笛卡尔坐标 .frac_coords分数坐标#print(np.sqrt(np.dot(strua.sites[70].coords-strua.sites[71].coords,strua.sites[70].coords-strua.sites[71].coords)))#求两个原子的距离total_structure=[]for i in range(20000):    Cry_tp = strua.copy()    re_index = np.arange(0,96)    np.random.shuffle(re_index)    re_index1 = re_index[:4]    Cry_tp.remove_sites(re_index2)    a=SpacegroupAnalyzer(Cry_tp).get_space_group_number()    if a&lt;= 140:      continue    print(i)    print(a)    Vasp_Str = Poscar(Cry_tp)    Vasp_Str.write_file(&#39;%d.vasp&#39;%i)    total_structure.append(Cry_tp)matcher = StructureMatcher()groups = matcher.group_structures([d for d in total_structure])groupstructures = [x[0] for x in groups]from pymatgen.io.vasp.inputs import Poscarn = $((i))for Cry_Str in groupstructures:    #print(Cry_Str)    Vasp_Str = Poscar(Cry_Str)    n = n+1    Vasp_Str.write_file(&#39;%dnew.vasp&#39;%n)lizdone</code></pre><h2 id="4-使用枚举方法处理蓝钻结构"><a href="#4-使用枚举方法处理蓝钻结构" class="headerlink" title="4.使用枚举方法处理蓝钻结构"></a>4.使用枚举方法处理蓝钻结构</h2><blockquote><ol><li>这是第一次系统使用暴力枚举法产生结构，其中，由于pymatgen用于计算ewald加和的程序太慢，使用了组内ARES中用于计算ewald能量的脚本ewalds.x</li><li>一共有两种方式产生，一种是完全随机的，另一种相当于对整个分子的替代（使用了pymatgen中找原子附近其他原子的功能</li><li>脚本、流程都经过了反复的改进</li></ol></blockquote><h3 id="1-完全随机的方法（完全解放双手了）"><a href="#1-完全随机的方法（完全解放双手了）" class="headerlink" title="1.完全随机的方法（完全解放双手了）"></a>1.完全随机的方法（完全解放双手了）</h3><blockquote><ol><li>一共需要四个文件</li></ol><p>a.vasp </p><p>multitask.sh</p><p>ewalds.x </p><p>changeatom.py:用于产生随机的结构</p><p>以及一个后处理文件</p><p>get-all.sh</p><p>2.分为三级别目录</p><p>一级： 1-21</p><p>二级： 1-48</p><p>三级： 1-random  2-low ；其中 1-random是随机产生的结构，并计算了静电能，2-low是能量最低的前30个结构以及对应的能量</p><ol start="3"><li>通过设置不同的价态，可以得到不同种原子靠近或者远离的结构</li></ol></blockquote><p>流程(产生1000万个随机结构）：</p><h4 id="1-提任务"><a href="#1-提任务" class="headerlink" title="1. 提任务"></a>1. 提任务</h4><p><code>for i in $(seq 1 1 10);do mkdir $i;cp a.vasp ewalds.x multitask.sh changeatom.py $i;cd $i; ./multitask.sh ;cd ..;done</code></p><h4 id="2-changeatom-py"><a href="#2-changeatom-py" class="headerlink" title="2. changeatom.py"></a>2. <code>changeatom.py</code></h4><p>需要更改的地方是产生结构的数量、以及替换的种类和位置</p><pre><code class="python">from pymatgen.core.structure import IStructure, Structurefrom pymatgen.io.vasp.inputs import Poscarfrom monty.io import zopenimport randomimport sys,os,timeimport numpy as npfrom pymatgen.core import Structurefrom pymatgen.analysis.energy_models import EwaldElectrostaticModelstrua = Structure.from_file(&quot;a.vasp&quot;)#需要考虑for i in range(10000):    print(i)    Cry_tp = strua.copy()    re_index = np.arange(0,512)    np.random.shuffle(re_index)    re_index1 = re_index[:7]    re_index2 = re_index[7:9]    replace_list = [ [re_index1, &#39;B&#39;],[re_index2,&#39;O&#39;] ]    for ele in replace_list:        for j in ele[0]:            Cry_tp.replace(j,ele[1])    Cry_tp.sort()    Vasp_Str = Poscar(Cry_tp)    Vasp_Str.write_file(&#39;%d.vasp&#39;%i)</code></pre><h4 id="3-multitask-sh-做一些文件夹-，提交产生结构的任务，提交计算ewald能量的任务"><a href="#3-multitask-sh-做一些文件夹-，提交产生结构的任务，提交计算ewald能量的任务" class="headerlink" title="3. multitask.sh :做一些文件夹 ，提交产生结构的任务，提交计算ewald能量的任务"></a>3. <code>multitask.sh</code> :做一些文件夹 ，提交产生结构的任务，提交计算ewald能量的任务</h4><p>需要注意的是，使用ewalds.x需要先source环境</p><pre><code class="shell">for i in $(seq 1 1 48)domkdir $icd $imkdir 1-random 2-lowcd ..cp changeatom.py $i/1-randomcp ewalds.x $i/1-randomcp a.vasp $i/1-randomcd $i/1-randomcat &gt; job.slurm &lt;&lt; liz#!/bin/sh#SBATCH  --job-name=opt #SBATCH  --output=log.out.%j#SBATCH  --error=log.err.%j#SBATCH  --partition=xieyu#SBATCH  --nodes=1#SBATCH  --ntasks=1#SBATCH  --cpus-per-task=1source activate lizpython changeatom.py &gt; log 2&gt;&amp;1lizsbatch job.slurmcd ..cd ..donesleep 1mfor i in $(seq 1 1 48)docd $i/1-randomcat &gt; ewaldenergy.slurm &lt;&lt;liz2#!/bin/sh#SBATCH  --job-name=opt #SBATCH  --output=log.out.%j#SBATCH  --error=log.err.%j#SBATCH  --partition=xieyu#SBATCH  --nodes=1#SBATCH  --ntasks=1#SBATCH  --cpus-per-task=1source /work/env/intel2020for j in \$(seq 0 1 9999);doecho -n \$j.vasp &gt;&gt; energy.dat./ewalds.x \$j.vasp 3 5 -2 &gt;&gt; energy.datdonesort -k3n energy.dat &gt; ewaldenergy.dathead -n 30 ewaldenergy.dat &gt; ../2-low/ewaldenergy.dathead -n 30 ewaldenergy.dat | awk &#39;&#123;print \$1&#125;&#39; | while read -r line; docp &quot;\$line&quot; ../2-low/doneliz2sbatch ewaldenergy.slurmcd ..cd ..done</code></pre><h4 id="4-后处理文件-get-all-sh-提取能量最低的结构"><a href="#4-后处理文件-get-all-sh-提取能量最低的结构" class="headerlink" title="4. 后处理文件 get-all.sh   提取能量最低的结构"></a>4. 后处理文件 <code>get-all.sh </code>  提取能量最低的结构</h4><pre><code class="shell">rm all-sorted.datfor i in $(seq 1 1 21)docd $ifor j in $(seq 1 1 48)docd $jcd 2-low#awk -v var=&quot;$j&quot; &#39;&#123; $1 = var &quot; &quot; $1 &#125; 1&#39; ewaldenergy.dat &gt; data.datawk -v var=&quot;$i&quot; -v var2=&quot;$j&quot; &#39;&#123; $1 = var &quot; &quot;  var2 &quot; &quot; $1 &#125; 1&#39; ewaldenergy.dat &gt; data.datcat data.dat &gt;&gt; ../../data.datrm data.datcd ..cd ..donecd ..donefor h in $(seq 1 1 21)docat $h/data.dat &gt;&gt; ./all.datrm $h/data.datdonesort -k5n all.dat  &gt; all-sorted.datrm all.datecho &#39;sucess1&#39;# 设置计数器count=1rm -r allmkdir all# 读取包含三列信息的文件head -n 100 all-sorted.dat | while read -r line; do  # 提取大目录、小目录和文件名  directory=$(echo &quot;$line&quot; | awk &#39;&#123;print $1&#125;&#39;)  subdirectory=$(echo &quot;$line&quot; | awk &#39;&#123;print $2&#125;&#39;)  filename=$(echo &quot;$line&quot; | awk &#39;&#123;print $3&#125;&#39;)  # 构建目标文件名  target_filename=&quot;$&#123;count&#125;_$&#123;directory&#125;_$&#123;subdirectory&#125;_$&#123;filename&#125;.vasp&quot;  # 复制文件到当前目录并重命名  cp &quot;$&#123;directory&#125;/$&#123;subdirectory&#125;/2-low/$&#123;filename&#125;&quot; &quot;./all/$&#123;target_filename&#125;&quot;  # 增加计数器  ((count++))doneecho &#39;sucess2&#39;</code></pre><h3 id="2-替换为B-3O和B-4O构型的方法（还需要手动做一些流程）"><a href="#2-替换为B-3O和B-4O构型的方法（还需要手动做一些流程）" class="headerlink" title="2. 替换为B_3O和B_4O构型的方法（还需要手动做一些流程）"></a>2. 替换为B_3O和B_4O构型的方法（还需要手动做一些流程）</h3><blockquote><ol><li>替换为特定构型的方法利用了pymatgen中寻找相邻原子的方法，基本的流程是</li></ol><p>  先随机找两个可能替换氧原子的位置</p><p>  检验氧原子的距离是否符合要求（在本例中设定两个氧原子不要靠的太近，以免产生O-B-O键</p><p>  查找两个位置附近的原子的位置</p><p>  替换附近原子为B</p><p>  检验相同结构</p><p>  计算静电能</p><ol start="2"><li>另一套流程是：(下文的流程)</li></ol><p>  先随机替换氧的位置</p><p>  检验氧原子距离</p><p>  检验氧的相同结构</p><p>  替换B</p><p>  检验相同结构</p><p>  计算静电能</p><p>  这样流程的好处是可以大大减少产生结构的数量，缺点是不能把算能量的步骤集成</p><ol start="3"><li>值得注意的一点是，在这次的产生结构的脚本中，是可以枚举O的所有可能情况的，所以最终结果是枚举的</li></ol></blockquote><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230612211658194.png" alt="image-20230612211658194"></p><h4 id="1-枚举氧的位置"><a href="#1-枚举氧的位置" class="headerlink" title="1. 枚举氧的位置"></a>1. 枚举氧的位置</h4><pre><code class="python">from pymatgen.core.structure import IStructure, Structurefrom pymatgen.io.vasp.inputs import Poscarfrom monty.io import zopenimport randomimport sys,os,timeimport numpy as npfrom pymatgen.core import Structurefrom pymatgen.analysis.energy_models import EwaldElectrostaticModelfrom itertools import combinationsstrua = Structure.from_file(&quot;a.vasp&quot;)hh=np.arange(512)combinations_list1 = list(combinations(hh, 2))print(len(combinations_list1))combinations_array1 = np.array(combinations_list1)numberbb = 0numberaa = 0for ar in combinations_array1:    ara=strua.copy()    numberbb +=1    print(numberbb)    if ara.get_distance(ar[0],ar[1])&gt;11 or ara.get_distance(ar[0],ar[1])&lt;3:        continue    numberaa +=1    replace_list = [[ar,&#39;O&#39;] ]    for ele in replace_list:        for j in ele[0]:            ara.replace(j,ele[1])    ara.sort()    Vasp_Str = Poscar(ara)    Vasp_Str.write_file(&#39;%d.vasp&#39;% numberaa)    </code></pre><h4 id="2-检验相同的结构"><a href="#2-检验相同的结构" class="headerlink" title="2. 检验相同的结构"></a>2. 检验相同的结构</h4><p>需要多次分批次检验，否则太慢了，有一个多任务脚本和一个py脚本</p><p>在不同文件夹中多次进行多脚本计算，会比较方便</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230612172111471.png" alt="image-20230612172111471"></p><p><code>cp  ../*new.vasp ./1-first</code></p><p>第一次检验</p><pre><code class="shell">for i in $(seq 0 1000 130000)docat &gt; job_$i.sh &lt;&lt; liz#!/bin/sh#SBATCH  --job-name=opt #SBATCH  --output=log.out.%j#SBATCH  --error=log.err.%j#SBATCH  --partition=xieyu#SBATCH  --nodes=1#SBATCH  --ntasks=1#SBATCH  --cpus-per-task=1source activate lizpython jianyan_$i.py &gt;&gt; jianyan_$i.dat 2&gt;&amp;1lizcat &gt; jianyan_$i.py &lt;&lt; lizimport osfrom pymatgen.core import Structurefrom pymatgen.io.vasp.sets import batch_write_input, MPRelaxSetfrom pymatgen.io.vasp.inputs import Poscarstandard_structures= []dir=&#39;/work/home/liz/workspace/3-temporary-duty/2-blue/4-zhengshi/3-B3O-B4O/4-xinzuo/1-替换O/1-str&#39;for j in range($i,$((i+1000))):    filename = &quot;&#123;&#125;.vasp&quot;.format(j)    filepath = os.path.join(dir, filename)    if not os.path.exists(filepath):        continue    print(filename)    structure = Structure.from_file(filepath)    standard_structures.append(structure)from pymatgen.analysis.structure_matcher import StructureMatchermatcher = StructureMatcher()groups = matcher.group_structures([d for d in standard_structures])print(len(groups))groupstructures = [x[0] for x in groups]  # 将嵌套列表的每个列表的第一个元素提取出来做成一个新列表from pymatgen.io.vasp.inputs import Poscarn = $ifor Cry_Str in groupstructures:    #print(Cry_Str)    Vasp_Str = Poscar(Cry_Str)    n = n+1    Vasp_Str.write_file(&#39;%dnew.vasp&#39;%n)lizsbatch job_$i.shdone</code></pre><p>第二次检验</p><pre><code class="python">for i in $(seq 0 10000 130000)docat &gt; job_$i.sh &lt;&lt; liz#!/bin/sh#SBATCH  --job-name=opt #SBATCH  --output=log.out.%j#SBATCH  --error=log.err.%j#SBATCH  --partition=xieyu#SBATCH  --nodes=1#SBATCH  --ntasks=1#SBATCH  --cpus-per-task=1source activate lizpython jianyan_$i.py &gt;&gt; jianyan_$i.dat 2&gt;&amp;1lizcat &gt; jianyan_$i.py &lt;&lt; lizimport osfrom pymatgen.core import Structurefrom pymatgen.io.vasp.sets import batch_write_input, MPRelaxSetfrom pymatgen.io.vasp.inputs import Poscarstandard_structures= []dir=&#39;/work/home/liz/workspace/3-temporary-duty/2-blue/4-zhengshi/3-B3O-B4O/4-xinzuo/2-去除相同结构/1-first&#39;for j in range($i,$((i+11000))):    filename = &quot;&#123;&#125;new.vasp&quot;.format(j)    filepath = os.path.join(dir, filename)    if not os.path.exists(filepath):        continue    print(filename)    structure = Structure.from_file(filepath)    standard_structures.append(structure)from pymatgen.analysis.structure_matcher import StructureMatchermatcher = StructureMatcher()groups = matcher.group_structures([d for d in standard_structures])print(len(groups))groupstructures = [x[0] for x in groups]  # 将嵌套列表的每个列表的第一个元素提取出来做成一个新列表from pymatgen.io.vasp.inputs import Poscarn = $ifor Cry_Str in groupstructures:    #print(Cry_Str)    Vasp_Str = Poscar(Cry_Str)    n = n+1    Vasp_Str.write_file(&#39;%dnew.vasp&#39;%n)lizsbatch job_$i.shdone      </code></pre><p>最后一步的检验</p><pre><code class="python">import osfrom pymatgen.core import Structurefrom pymatgen.io.vasp.sets import batch_write_input, MPRelaxSetfrom pymatgen.io.vasp.inputs import Poscarstandard_structures= []dir=&#39;/work/home/liz/workspace/3-temporary-duty/2-blue/4-zhengshi/3-B3O-B4O/4-xinzuo/2-去除相同结构/2-new&#39;for j in range(124000):    filename = &quot;&#123;&#125;new.vasp&quot;.format(j)    filepath = os.path.join(dir, filename)    if not os.path.exists(filepath):        continue    print(filename)    structure = Structure.from_file(filepath)    standard_structures.append(structure)from pymatgen.analysis.structure_matcher import StructureMatchermatcher = StructureMatcher()groups = matcher.group_structures([d for d in standard_structures])print(len(groups))groupstructures = [x[0] for x in groups]  # 将嵌套列表的每个列表的第一个元素提取出来做成一个新列表from pymatgen.io.vasp.inputs import Poscarn = 0for Cry_Str in groupstructures:    #print(Cry_Str)    Vasp_Str = Poscar(Cry_Str)    n = n+1    Vasp_Str.write_file(&#39;%dnew.vasp&#39;%n)        </code></pre><h4 id="3-替换B原子"><a href="#3-替换B原子" class="headerlink" title="3. 替换B原子"></a>3. 替换B原子</h4><blockquote><p>先替换B4，再替换B3</p></blockquote><pre><code class="python">from pymatgen.core.structure import IStructure, Structurefrom pymatgen.io.vasp.inputs import Poscarfrom monty.io import zopenimport randomimport sys,os,timeimport numpy as npfrom pymatgen.core import Structurefrom pymatgen.analysis.energy_models import EwaldElectrostaticModelfrom itertools import combinationsdir=&#39;/work/home/liz/workspace/3-temporary-duty/2-blue/4-zhengshi/3-B3O-B4O/4-xinzuo/2-去除相同结构/2-new&#39;counter = 0for j in range(124000):    filename = &quot;&#123;&#125;new.vasp&quot;.format(j)    filepath = os.path.join(dir, filename)    if not os.path.exists(filepath):        continue    print(filename)    structure = Structure.from_file(filepath)    o_indices = [i for i, site in enumerate(structure) if site.specie.name == &quot;O&quot;]    o_array = np.array(o_indices)    ara=structure.copy()    list1=ara.get_neighbors(ara[o_array[0]], r=2.0)    list2=ara.get_neighbors(ara[o_array[1]], r=2.0)    list1index=np.array([site.index for site in list1])    list2index=np.array([site.index for site in list2])    replace_list = [ [list1index, &#39;B&#39;] ]    for ele in replace_list:        for j in ele[0]:            ara.replace(j,ele[1])    combinations_list = list(combinations(list2index, 3))    combinations_array = np.array(combinations_list)    for br in combinations_array:        counter += 1        brb=ara.copy()        replace_listara = [ [br, &#39;B&#39;] ]        for ele in replace_listara:           for j in ele[0]:                 brb.replace(j,ele[1])        brb.sort()        Vasp_Str = Poscar(brb)        Vasp_Str.write_file(&#39;%d.vasp&#39;% counter)        print(counter)</code></pre><h4 id="4-再次检验相同结构"><a href="#4-再次检验相同结构" class="headerlink" title="4. 再次检验相同结构"></a>4. 再次检验相同结构</h4><pre><code class="python">import osfrom pymatgen.core import Structurefrom pymatgen.io.vasp.sets import batch_write_input, MPRelaxSetfrom pymatgen.io.vasp.inputs import Poscarstandard_structures= []dir=&#39;/work/home/liz/workspace/3-temporary-duty/2-blue/4-zhengshi/3-B3O-B4O/4-xinzuo/3-替换B&#39;for j in range(500):    filename = &quot;&#123;&#125;.vasp&quot;.format(j)    filepath = os.path.join(dir, filename)    if not os.path.exists(filepath):        continue    print(filename)    structure = Structure.from_file(filepath)    standard_structures.append(structure)from pymatgen.analysis.structure_matcher import StructureMatchermatcher = StructureMatcher()groups = matcher.group_structures([d for d in standard_structures])print(len(groups))groupstructures = [x[0] for x in groups]  # 将嵌套列表的每个列表的第一个元素提取出来做成一个新列表from pymatgen.io.vasp.inputs import Poscarn = 0for Cry_Str in groupstructures:    #print(Cry_Str)    Vasp_Str = Poscar(Cry_Str)    n = n+1    Vasp_Str.write_file(&#39;%dnew.vasp&#39;%n)</code></pre><h4 id="5-计算能量，整理结构"><a href="#5-计算能量，整理结构" class="headerlink" title="5. 计算能量，整理结构"></a>5. 计算能量，整理结构</h4><pre><code class="shell">rm energy.datfor i in $(seq 1 1 99);do echo -n $&#123;i&#125;new.vasp &gt;&gt; energy.dat./ewalds.x ../4-去除相同结构/$&#123;i&#125;new.vasp -1 0 2 &gt;&gt; energy.datdonesort -k3n energy.dat  &gt; sorted.datmkdir strcd strcount=1head -n 100 ../sorted.dat |while read -r line;dofilename=$(echo &quot;$line&quot; | awk &#39;&#123;print $1&#125;&#39;)target_filename=$&#123;count&#125;.vaspcp ../../4-去除相同结构/$&#123;filename&#125; ./$&#123;target_filename&#125;count=$((count+ 1))donecd ..</code></pre><h3 id="3-替换为B-2O和B-3O的方法"><a href="#3-替换为B-2O和B-3O的方法" class="headerlink" title="3. 替换为B_2O和B_3O的方法"></a>3. 替换为B_2O和B_3O的方法</h3><h4 id="1-枚举氧的结构和其他步骤"><a href="#1-枚举氧的结构和其他步骤" class="headerlink" title="1.枚举氧的结构和其他步骤"></a>1.枚举氧的结构和其他步骤</h4><h4 id="2-1-替换B原子-联合取代、完全枚举"><a href="#2-1-替换B原子-联合取代、完全枚举" class="headerlink" title="2-1. 替换B原子(联合取代、完全枚举)"></a>2-1. 替换B原子(联合取代、完全枚举)</h4><pre><code class="python">from pymatgen.core.structure import IStructure, Structurefrom pymatgen.io.vasp.inputs import Poscarfrom monty.io import zopenimport randomimport sys,os,timeimport numpy as npfrom pymatgen.core import Structurefrom pymatgen.analysis.energy_models import EwaldElectrostaticModelfrom itertools import combinationsdir=&#39;/work/home/liz/workspace/3-temporary-duty/2-blue/4-zhengshi/1-512-B-7-O-2/3-B2O-B3O/1-O-结构&#39;counter = 0filename = &quot;1new.vasp&quot;filepath = os.path.join(dir, filename)print(filename)structure = Structure.from_file(filepath)o_indices = [i for i, site in enumerate(structure) if site.specie.name == &quot;O&quot;]o_array = np.array(o_indices)c_indices = [i for i, site in enumerate(structure) if site.specie.name == &quot;C&quot;]c_array = np.array(c_indices)ara=structure.copy()list1=ara.get_neighbors(ara[o_array[0]], r=2.0)list2=ara.get_neighbors(ara[o_array[1]], r=2.0)list1index=np.array([site.index for site in list1])list2index=np.array([site.index for site in list2])combined_array = np.concatenate((list1index, list2index))c_array2 = np.setdiff1d(c_array, combined_array)combinations_list1 = list(combinations(list1index, 2))combinations_list2 = list(combinations(list2index, 3))combinations_list3 = list(combinations(c_array2, 2))array1 = np.array(combinations_list1)array2 = np.array(combinations_list2)array3 = np.array(combinations_list3)print(array3.shape)print(len(array1))print(len(array2))print(len(array3))for i in range(len(array1)):    for j in range(len(array2)):        for k in range(len(array3)):            brb = ara.copy()            counter += 1           # print(array1[i])           # print(array2[j])           # print(array3[k])            combined_array33=np.concatenate((array1[i], array2[j], array3[k]))            replace_listara = [ [combined_array33, &#39;B&#39;] ]            for ele in replace_listara:                for m in ele[0]:                   brb.replace(m,ele[1])            brb.sort()            Vasp_Str = Poscar(brb)            Vasp_Str.write_file(&#39;%d.vasp&#39;% counter)            print(counter)</code></pre><h4 id="2-2-先分类再替代"><a href="#2-2-先分类再替代" class="headerlink" title="2-2 先分类再替代"></a>2-2 先分类再替代</h4><pre><code class="python">from pymatgen.core.structure import IStructure, Structurefrom pymatgen.io.vasp.inputs import Poscarfrom monty.io import zopenimport randomimport sys,os,timeimport numpy as npfrom pymatgen.core import Structurefrom pymatgen.analysis.energy_models import EwaldElectrostaticModelfrom itertools import combinationsdir=&#39;/work/home/liz/workspace/3-temporary-duty/2-blue/4-zhengshi/1-512-B-7-O-2/3-B2O-B3O/1-O-结构&#39;counter = 0filename = &quot;1new.vasp&quot;filepath = os.path.join(dir, filename)print(filename)structure = Structure.from_file(filepath)o_indices = [i for i, site in enumerate(structure) if site.specie.name == &quot;O&quot;]o_array = np.array(o_indices)c_indices = [i for i, site in enumerate(structure) if site.specie.name == &quot;C&quot;]c_array = np.array(c_indices)ara=structure.copy()list1=ara.get_neighbors(ara[o_array[0]], r=2.0)list2=ara.get_neighbors(ara[o_array[1]], r=2.0)list1index=np.array([site.index for site in list1])list2index=np.array([site.index for site in list2])combined_array = np.concatenate((list1index, list2index))print(combined_array)c_array2 = np.setdiff1d(c_array, combined_array)combinations_list1 = list(combinations(list1index, 2))combinations_list2 = list(combinations(list2index, 3))combinations_list3 = list(combinations(c_array2, 2))array1 = np.array(combinations_list1)array2 = np.array(combinations_list2)array3 = np.array(combinations_list3)print(array3.shape)print(len(array1))print(len(array2))print(len(array3))standard_structures=[]for i in range(len(array1)):    for j in range(len(array2)):#        for k in range(len(array3)):            brb = ara.copy()           # print(array1[i])           # print(array2[j])           # print(array3[k])            combined_array33=np.concatenate((array1[i], array2[j]))#            print(combined_array33)            replace_listara = [ [combined_array33, &#39;B&#39;] ]            for ele in replace_listara:                for m in ele[0]:                   brb.replace(m,ele[1])            standard_structures.append(brb)from pymatgen.analysis.structure_matcher import StructureMatchermatcher = StructureMatcher()groups = matcher.group_structures([d for d in standard_structures])print(len(groups))groupstructures = [x[0] for x in groups]for straaa in groupstructures:    for k in range(len(array3)):        copy2=straaa.copy()        counter += 1        replace_listara = [ [array3[k], &#39;B&#39;] ]        for ele in replace_listara:            for m in ele[0]:                copy2.replace(m,ele[1])        copy2.sort()        Vasp_Str = Poscar(copy2)        Vasp_Str.write_file(&#39;%d.vasp&#39;% counter)        print(counter)</code></pre><h4 id="2-3-每个结构随机取样特定数目的结构"><a href="#2-3-每个结构随机取样特定数目的结构" class="headerlink" title="2-3 每个结构随机取样特定数目的结构"></a>2-3 每个结构随机取样特定数目的结构</h4><pre><code class="python">from pymatgen.core.structure import IStructure, Structurefrom pymatgen.io.vasp.inputs import Poscarfrom monty.io import zopenimport randomimport sys,os,timeimport numpy as npfrom pymatgen.core import Structurefrom pymatgen.analysis.energy_models import EwaldElectrostaticModelfrom itertools import combinationsdir=&#39;/work/home/liz/workspace/3-temporary-duty/2-blue/4-zhengshi/1-512-B-7-O-2/3-B2O-B3O/1-O-结构&#39;counter = 0for j in range(100):    filename = &quot;&#123;&#125;new.vasp&quot;.format(j)    filepath = os.path.join(dir, filename)    if not os.path.exists(filepath):        continue    print(filename)    structure = Structure.from_file(filepath)    o_indices = [i for i, site in enumerate(structure) if site.specie.name == &quot;O&quot;]    o_array = np.array(o_indices)    c_indices = [i for i, site in enumerate(structure) if site.specie.name == &quot;C&quot;]    c_array = np.array(c_indices)    ara=structure.copy()    list1=ara.get_neighbors(ara[o_array[0]], r=2.0)    list2=ara.get_neighbors(ara[o_array[1]], r=2.0)    list1index=np.array([site.index for site in list1])    list2index=np.array([site.index for site in list2])    combined_array = np.concatenate((list1index, list2index))    c_array2 = np.setdiff1d(c_array, combined_array)    combinations_list1 = list(combinations(list1index, 2))    combinations_list2 = list(combinations(list2index, 3))    combinations_list3 = list(combinations(c_array2, 2))    array1 = np.array(combinations_list1)    array2 = np.array(combinations_list2)    array3 = np.array(combinations_list3)    arr1=np.arange(len(array1))    arr2=np.arange(len(array2))    arr3=np.arange(len(array3))    for ww in range(5000):        np.random.shuffle(arr1)        np.random.shuffle(arr2)        np.random.shuffle(arr3)        brb = ara.copy()        counter += 1        combined_array33=np.concatenate((array1[arr1[1]], array2[arr2[1]], array3[arr3[1]]))        replace_listara = [ [combined_array33, &#39;B&#39;] ]        for ele in replace_listara:            for m in ele[0]:               brb.replace(m,ele[1])        brb.sort()        Vasp_Str = Poscar(brb)        Vasp_Str.write_file(&#39;%d.vasp&#39;% counter)        print(counter)</code></pre><h3 id="4-枚举-迭代器进行工作"><a href="#4-枚举-迭代器进行工作" class="headerlink" title="4.枚举+迭代器进行工作"></a>4.枚举+迭代器进行工作</h3><blockquote><p>可以是可以，但是现在太慢了，问题出在挨个去对比结构相似性，一个可行的方案是不断地细分到不同的结构特征集合，用结构特征做一个初筛</p></blockquote><pre><code class="python">from pymatgen.core.structure import IStructure, Structurefrom pymatgen.io.vasp.inputs import Poscarfrom monty.io import zopenimport randomimport sys,os,timeimport numpy as npfrom pymatgen.core import Structurefrom pymatgen.analysis.energy_models import EwaldElectrostaticModelfrom itertools import combinationsimport itertoolsfrom pymatgen.analysis.structure_matcher import StructureMatchermatcher = StructureMatcher()strua = Structure.from_file(&quot;a.vasp&quot;)hh=np.arange(16,112)combinations_generator = itertools.combinations(hh, 6)numberbb = 0numberaa = 0all_structure=[]for ar in combinations_generator:    ara=strua.copy()    numberbb +=1    print(numberbb)    remove_list = list(ar)    ara.remove_sites(remove_list)    ara.sort()    match_found =False    for aa in all_structure:        if matcher.fit(ara,aa):            match_found = True            break    if not match_found:        all_structure.append(ara)        print(&quot;%d structures &quot; %len(all_structure))        bb=0for aa in all_structure:        bb +=1    Vasp_Str = Poscar(aa)    Vasp_Str.write_file(&#39;%d.vasp&#39;% bb)    </code></pre><h3 id="5-枚举-使用静电能作为哈希值而不是fit"><a href="#5-枚举-使用静电能作为哈希值而不是fit" class="headerlink" title="5.枚举-使用静电能作为哈希值而不是fit"></a>5.枚举-使用静电能作为哈希值而不是fit</h3><blockquote><p>这一方法验证错误，因为两个不同的结构可能具有相同的静电能</p></blockquote><pre><code class="python">from pymatgen.core.structure import IStructure, Structurefrom pymatgen.io.vasp.inputs import Poscarfrom monty.io import zopenimport randomimport sys,os,timeimport numpy as npfrom pymatgen.core import Structurefrom pymatgen.analysis.energy_models import EwaldElectrostaticModelfrom itertools import combinationsimport itertoolsfrom pymatgen.analysis.structure_matcher import StructureMatcherstrua = Structure.from_file(&quot;a.vasp&quot;)hh = np.arange(16, 112)combinations_generator = itertools.combinations(hh, 6)data = &#123;&quot;Ca&quot;:6, &quot;H&quot;:-1&#125;structure_dict = &#123;&#125;  # 用于存储已处理的结构strua.add_oxidation_state_by_element(data)print(strua)aaa= 0for ar in combinations_generator:    aaa +=1    print(aaa)    ara = strua.copy()    remove_list = list(ar)    ara.remove_sites(remove_list)    ara.sort()        # 计算结构的哈希值作为字典的键    ara_hash = EwaldElectrostaticModel().get_energy(ara)        # 使用字典进行匹配检查    if ara_hash not in structure_dict:        structure_dict[ara_hash] = ara        print(&quot;New structure added! Total structures: %d&quot; % len(structure_dict))        for Cry_Str in structure_dict.values():    #print(Cry_Str)    Vasp_Str = Poscar(Cry_Str)    n = n+1    Vasp_Str.write_file(&#39;%d.vasp&#39;%n)        </code></pre><h3 id="6-可以分步骤来做，先替换四个，再替换两个-！"><a href="#6-可以分步骤来做，先替换四个，再替换两个-！" class="headerlink" title="6. 可以分步骤来做，先替换四个，再替换两个 ！"></a>6. 可以分步骤来做，先替换四个，再替换两个 ！</h3><p>先替换1个，再替换一个，再替换一个，再，，，，这样一定是可以做的</p><p>从上往下试，直到能够使用程序做了就停止（95–92），如果从下往上试（92—95）会面临文件数太多的困难</p><h2 id="5-检验"><a href="#5-检验" class="headerlink" title="5.检验"></a>5.检验</h2><h3 id="1-逐个检验相似性"><a href="#1-逐个检验相似性" class="headerlink" title="1. 逐个检验相似性"></a>1. 逐个检验相似性</h3><pre><code class="python">import numpy as npimport sys,os,timefrom pymatgen.core import Structurefrom pymatgen.analysis.structure_matcher import StructureMatchermatcher = StructureMatcher()all_str = []for i in range(1,100000):    file = f&#39;&#123;i&#125;.vasp&#39;    if not os.path.exists(file):       continue    print(file)    strua = Structure.from_file(file)    match_found = False    for str in all_str:        if matcher.fit(strua,str):           match_found = True           break    if not match_found:        all_str.append(strua)        print(&#39;%d structures&#39; % len(all_str))from pymatgen.io.vasp.inputs import Poscarn = 0for strua in all_str:    Vasp_Str = Poscar(strua)    n +=1    Vasp_Str.write_file(&#39;%dnew.vasp&#39;%n)</code></pre><h3 id="2-检验两个结构"><a href="#2-检验两个结构" class="headerlink" title="2. 检验两个结构"></a>2. 检验两个结构</h3><pre><code class="python">import numpy as npimport sys,os,timefrom pymatgen.core import Structurefrom pymatgen.analysis.structure_matcher import StructureMatchermatcher = StructureMatcher()aa = Structure.from_file(&#39;16.vasp&#39;)bb = Structure.from_file(&#39;4199.vasp&#39;)matcher.fit(aa,bb)</code></pre><h1 id="7-找出缺失的原子"><a href="#7-找出缺失的原子" class="headerlink" title="7.找出缺失的原子"></a>7.找出缺失的原子</h1><pre><code class="python">from pymatgen.core.structure import IStructure, Structurefrom itertools import combinationsstru_b=Structure.from_file(filename=&#39;supercell.vasp&#39;)frac_coords_b=stru_b.frac_coords.tolist()normalized_coords_b = [[x % 1 for x in coord] for coord in frac_coords_b]set2 = set(map(tuple, normalized_coords_b))for i in range(1, 1000001):    file = f&#39;&#123;i&#125;.vasp&#39;    stru_a=Structure.from_file(file)    # 检查文件是否存在    if not os.path.exists(file):        continue    frac_coords_a=stru_a.frac_coords.tolist()    normalized_coords_a = [[x % 1 for x in coord] for coord in frac_coords_a]    set1 = set(map(tuple, normalized_coords_a))    result= [list(i) for i in set2.difference(set1)]    print(result)    atom_indices=[]    for coord in result:        try:            index = normalized_coords_b.index(coord)            atom_indices.append(index)        except ValueError:          # 如果找不到匹配的坐标，可以添加一个标记，如-1，以表示未匹配的坐标            atom_indices.append(-1)    close_atom_pairs = []    combinations_of_missing_atoms = combinations(atom_indices, 2)    threshold_distance = 7    for pair in combinations_of_missing_atoms:        distance = stru_b.get_distance(pair[0], pair[1])        if distance &lt; threshold_distance:            close_atom_pairs.append(pair)    # 如果 close_atom_pairs 列表不为空，则表示存在距离小于阈值的原子对    if close_atom_pairs:        print(&quot;存在距离小于阈值的原子对：&quot;)        print(len(close_atom_pairs))    else:        print(&quot;不存在距离小于阈值的原子对。&quot;)</code></pre><h1 id="7-处理CaH6的333倍胞的问题（将324个H中的14个扣掉-可以枚举的方法"><a href="#7-处理CaH6的333倍胞的问题（将324个H中的14个扣掉-可以枚举的方法" class="headerlink" title="7. 处理CaH6的333倍胞的问题（将324个H中的14个扣掉-可以枚举的方法"></a>7. 处理CaH6的333倍胞的问题（将324个H中的14个扣掉-可以枚举的方法</h1><p>&#x3D;&#x3D;&#x2F;work&#x2F;home&#x2F;liz&#x2F;workspace&#x2F;3-temporary-duty&#x2F;3-zwb&#x2F;6-333&#x2F;1-kou3&#x2F;2&#x2F;1-2&#x2F;ee.py&#x3D;&#x3D;</p><pre><code class="python">from pymatgen.core.structure import IStructure, Structurefrom pymatgen.io.vasp.inputs import Poscarfrom monty.io import zopenimport randomimport sys,os,timeimport numpy as npfrom pymatgen.core import Structurefrom pymatgen.analysis.energy_models import EwaldElectrostaticModelfrom itertools import combinationsstrua = Structure.from_file(&quot;a.vasp&quot;)H_indice = [i for i, site in enumerate(strua) if site.species_string == &quot;H&quot;]H_indices=np.array(H_indice)distanceall=strua.distance_matrixdistance=distanceall[H_indices][:,H_indices]print(distance.shape)print(distance)N = distance.shape[0]two_dim_matrix = np.zeros((N, N), dtype=int)for i in range(N):    for j in range(N):        dist1 = distance[i][j]        if dist1 &lt;= 3.6:            two_dim_matrix[i][j] = 0        else:            two_dim_matrix[i][j] = 1allnumber = 0matching_columns = np.where(two_dim_matrix[0, 1:] == 1)[0]matching_columns = matching_columns  + 1print(matching_columns)for j in matching_columns:    print(j)    matching_columns2=np.where(two_dim_matrix[j, j+1:] == 1)[0]    matching_columns2 = matching_columns2 + j + 1    matching_columns2 = np.intersect1d(matching_columns2,matching_columns)   # print(len(matching_columns2))    for jj in matching_columns2:        matching_columns3=np.where(two_dim_matrix[jj, jj+1:] == 1)[0]        matching_columns3 = matching_columns3 + jj + 1        matching_columns3 = np.intersect1d(matching_columns2,matching_columns3)      #  print(len(matching_columns3))        for jjj in matching_columns3:            matching_columns4=np.where(two_dim_matrix[jjj, jjj+1:] == 1)[0]            matching_columns4 = matching_columns4 + jjj + 1            matching_columns4 = np.intersect1d(matching_columns3,matching_columns4)           # print(len(matching_columns4))            for jjjj in matching_columns4:                matching_columnsddd=np.where(two_dim_matrix[jjjj, jjjj+1:] == 1)[0]                matching_columnsddd = matching_columnsddd + jjjj + 1                matching_columnsddd = np.intersect1d(matching_columns4,matching_columnsddd)               # print(len(matching_columnsddd))                for gg in matching_columnsddd:                    matching_columns5=np.where(two_dim_matrix[gg, gg+1:] == 1)[0]                    matching_columns5 = matching_columns5 + gg + 1                    matching_columns5 = np.intersect1d(matching_columnsddd,matching_columns5)                   # print(len(matching_columns5))                    for ggg in matching_columns5:                        matching_columns6=np.where(two_dim_matrix[ggg, ggg+1:] == 1)[0]                        matching_columns6 = matching_columns6 + ggg + 1                        matching_columns6 = np.intersect1d(matching_columns5,matching_columns6)                       # print(len(matching_columns6))                        for gggg in matching_columns6:                            matching_columns7=np.where(two_dim_matrix[gggg, gggg+1:] == 1)[0]                            matching_columns7 = matching_columns7 + gggg + 1                            matching_columns7 = np.intersect1d(matching_columns6,matching_columns7)                           # print(len(matching_columns7))                            for dd in matching_columns7:                                matching_columns8=np.where(two_dim_matrix[dd, dd+1:] == 1)[0]                                matching_columns8 = matching_columns8 + dd + 1                                matching_columns8 = np.intersect1d(matching_columns7,matching_columns8)                               # print(len(matching_columns8))                                for ddd in matching_columns8:                                    matching_columns9=np.where(two_dim_matrix[ddd, ddd+1:] == 1)[0]                                    matching_columns9 = matching_columns9 + ddd + 1                                    matching_columns9 = np.intersect1d(matching_columns8,matching_columns9)                                   # print(len(matching_columns9))                                    for dddd in matching_columns9:                                        matching_columns10=np.where(two_dim_matrix[dddd, dddd+1:] == 1)[0]                                        matching_columns10 = matching_columns10 + dddd + 1                                        matching_columns10 = np.intersect1d(matching_columns9,matching_columns10)                                       # print(len(matching_columns10))                                        for ww in matching_columns10:                                            matching_columns11=np.where(two_dim_matrix[ww, ww+1:] == 1)[0]                                            matching_columns11 = matching_columns11 + ww + 1                                            matching_columns11 = np.intersect1d(matching_columns10,matching_columns11)                                           # print(len(matching_columns11))                                            for www in matching_columns11:                                                matching_columns12=np.where(two_dim_matrix[www, www+1:] == 1)[0]                                                matching_columns12 = matching_columns12 + www + 1                                                matching_columns12 = np.intersect1d(matching_columns11,matching_columns12)                                               # print(len(matching_columns12))                                                for wwww in matching_columns12:                                                    matching_columns13=np.where(two_dim_matrix[wwww, wwww+1:] == 1)[0]                                                    matching_columns13 = matching_columns13 + wwww + 1                                                    listaaa=[0,j,jj,jjj,jjjj,gg,ggg,gggg,dd,ddd,dddd,ww,www,wwww]                                                   # print(listaaa)                                                    allnumber += 1                                                    #print(allnumber)                                                   # print(listaaa)                                                    if allnumber % 100000 == 0:                                                       print(allnumber)                                                       print(listaaa)                                                       listbbb= H_indices[listaaa]                                                       print(listbbb)                                                       ara=strua.copy()                                                       for ele in listbbb:                                                           ara.replace(ele,&#39;O&#39;)                                                       ara.sort()                                                       Vasp_Str = Poscar(ara)                                                       Vasp_Str.write_file(&#39;%d.vasp&#39;% allnumber)                                                        #                                                   for wwwww in matching_columns14:#                                                        matching_columns15=np.where(two_dim_matrix[wwwww, wwwww+1:] == 1)[0] #                                                       matching_columns15 = matching_columns15 + wwwww + 1</code></pre><p><img src="/./../%E5%9B%BE%E7%89%87/image-20231028104117829.png" alt="image-20231028104117829"></p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20231028104128748.png" alt="image-20231028104128748"></p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20231028104147185.png" alt="image-20231028104147185"></p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20231028113559666.png" alt="image-20231028113559666"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;1-pymatgen检验相同结构&quot;&gt;&lt;a href=&quot;#1-pymatgen检验相同结构&quot; class=&quot;headerlink&quot; title=&quot;1.pymatgen检验相同结构&quot;&gt;&lt;/a&gt;1.pymatgen检验相同结构&lt;/h1&gt;&lt;p&gt;f</summary>
      
    
    
    
    <category term="模拟方法" scheme="http://example.com/categories/%E6%A8%A1%E6%8B%9F%E6%96%B9%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>固态离子学</title>
    <link href="http://example.com/2024/05/25/%E5%9B%BA%E6%80%81%E7%A6%BB%E5%AD%90%E5%AD%A6/"/>
    <id>http://example.com/2024/05/25/%E5%9B%BA%E6%80%81%E7%A6%BB%E5%AD%90%E5%AD%A6/</id>
    <published>2024-05-25T14:01:20.371Z</published>
    <updated>2024-05-26T06:06:22.017Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>始终没有搞懂离子迁移和昂萨格倒易关系、线性响应理论、涨落耗散、最小熵原理这些近平衡态、非平衡态的关系，以下列出比较好的帖子、书籍，可以学习一下</strong></p><p><a href="https://zhuanlan.zhihu.com/p/148164408">统计物理研究前沿总结与漫谈 - 知乎 (zhihu.com)</a></p><p><a href="https://www.zhihu.com/question/24636701"> 为什么谱定理又称作涨落耗散定理，它与「涨落」「耗散」是怎么联系起来的？涨落与耗散是怎样定义的呢？ - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/620689256">https://zhuanlan.zhihu.com/p/620689256</a></p><p><strong>目前知道的是，统计物理分为平衡态统计物理、近平衡态、非平衡态，平衡态就是热统中学习的系综等内容，而近平衡态和非平衡态了解很少</strong>，<strong>生命系统是典型的非平衡态系统</strong></p><p><strong>对于不同物理的学科，可以简单地从时间尺度和空间尺寸两个标准进行划分</strong></p><blockquote><p><strong>凝聚态物理和统计物理的区别？</strong></p><p><strong>凝聚态物理更加关注材料，更关注大系统内部的相互作用，而统计物理重视对大系统整体的描述</strong></p></blockquote><h1 id="1-理论研究"><a href="#1-理论研究" class="headerlink" title="1.理论研究"></a>1.理论研究</h1><h2 id="1-离子运动关联性"><a href="#1-离子运动关联性" class="headerlink" title="1.离子运动关联性"></a>1.离子运动关联性</h2><p>&#x3D;&#x3D;对这种关联性的讨论在本笔记中只是对不同事件的结果的分析，而不包括对其原因的探讨，即可以根据这样的方法判断运动事件的关联性，但是不能得到关联性背后的原因以及关联性的后果，要获得原因的判断，需要十分小心&#x3D;&#x3D;</p><blockquote><p>Dynamic Ion Correlations in Solid and Liquid Electrolytes: How Do They Affect Charge and Mass Transport?</p></blockquote><h3 id="1-Nernst-Einstein-equation（离子电导率和扩散系数的关联）"><a href="#1-Nernst-Einstein-equation（离子电导率和扩散系数的关联）" class="headerlink" title="1.Nernst-Einstein equation（离子电导率和扩散系数的关联）"></a><strong>1.Nernst-Einstein equation（离子电导率和扩散系数的关联）</strong></h3><p>$$<br>\sigma_{ion}&#x3D;\frac{F^2}{RTH_R}\sum_ic_iD_i^*<br>$$</p><blockquote><p><strong>$\sigma_{ion}$  ionic conductivity</strong> </p><p><em><em>$D_i^</em>$  &#x3D;&#x3D;self-diffusion coefficient&#x3D;&#x3D;</em>*</p><p><em>$z_i$ 离子带电荷量   $c_i$ 离子浓度</em>* </p><p><strong>$H_R$ Haven ratio</strong></p><p><em>$k_B$ 玻尔兹曼常数</em>* </p><p><strong>$T$ 温度</strong></p><p><em>$F$ 法拉第常数</em>*</p></blockquote><h3 id="2-自扩散系数与自相关作用"><a href="#2-自扩散系数与自相关作用" class="headerlink" title="2.自扩散系数与自相关作用"></a><strong>2.自扩散系数与自相关作用</strong></h3><blockquote><p>离子在这一步和下一步跳跃之间的关联性</p></blockquote><p><strong>热力学平衡状态下离子在材料中的输运可由自扩散系数描述：</strong><br>$$<br>D_\alpha^*&#x3D;\lim\limits_{t\to\infty}\frac{d}{dt}[\frac{1}{2dN_\alpha}(\sum_{i&#x3D;1}^{N_a}(\Delta\vec{R}_i(t))^2)]<br>$$</p><blockquote><p>$d$ 输运的维度</p><p>$N_\alpha$ 离子数目</p><p>$\Delta\vec{R}_i$  离子运动的向量</p></blockquote><p>$$<br>\Delta\vec{R}<em>i(t)&#x3D;\sum</em>{k&#x3D;1}^m\Delta\vec{r}_{i,k}(t)<br>$$</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230511162233156.png" alt="image-20230511162233156"></p><p>将$\Delta\vec{R}<em>i$ 带入得到<br>$$<br>\begin{array}{l}D</em>{\alpha}^{*}&#x3D;\frac{1}{2 d N_{\alpha}} \lim \limits_{t \rightarrow \infty} \frac{d}{d t} \ {\left[\sum_{i&#x3D;1}^{N_{a}}\left(\sum_{k&#x3D;1}^{m}\left(\Delta \vec{r}<em>{i, k}(t)\right)^{2}+\sum</em>{k&#x3D;1}^{m} \sum_{l \neq k} \Delta \vec{r}<em>{i, k}(t) \cdot \Delta \vec{r}</em>{i, l}(t) \mid\right)\right]}\end{array}<br>$$<br>$\Delta\vec{r}_{i,k}(t)^2$  是独立跳跃的长度，是与连续跳跃的方向相关性无关的量，而第二项与前后跳跃的方向是相关的（图中显示的是正交关系，但是实际中可以有各种夹角）</p><p>在左右两侧分别除以第一项</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230511165100589.png" alt="image-20230511165100589"></p><p>其中<br>$$<br>D_\alpha&#x3D;\frac{1}{2 d N_{a}} \lim \limits_{t \rightarrow \infty} \frac{d}{d t}\left[\sum_{i&#x3D;1}^{N_{a}} \sum_{k&#x3D;1}^{m}\left(\Delta \vec{r}_{i, k}(t)\right)^{2}\right]<br>$$<br>称作&#x3D;&#x3D;无关联的自扩散系数&#x3D;&#x3D;，而右侧{1+~}称为tracer correlation factor，标识为<em>f</em>。</p><p>&#x3D;&#x3D;如果同一个离子前后两次运动之间不存在方向相关性，那么<em>f</em>为1&#x3D;&#x3D;，因为对于随机的运动，其运动的方向的统计平均是均匀的，最终右侧分数的分子相加是0。(向量积不总是正数，有多少相同方向的就有多少相反方向的)</p><p>$D\alpha$和 <em>f</em> 可以在模拟中计算出来，需要计算一个大位移中每个小跳跃的位移，然后平方相加</p><p>&#x3D;&#x3D;在我现在的计算中，是考虑了自关联的因素的&#x3D;&#x3D;,因为并没有特意将单个位移分开</p><h3 id="3-电导率计算中出现的不同离子间的关联及-H-r"><a href="#3-电导率计算中出现的不同离子间的关联及-H-r" class="headerlink" title="3.电导率计算中出现的不同离子间的关联及$H_r$"></a>3.电导率计算中出现的不同离子间的关联及$H_r$</h3><blockquote><p>不同离子之间跳跃的关联性</p></blockquote><p>也就是固体电解质中的情形</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230511171618003.png" alt="image-20230511171618003"></p><blockquote><p>注意，计算离子电导率的公式和计算扩散系数的公式中对$\Delta\vec{R}_i(t)$的加和与平方的顺序是不同的，计算离子电导率是先加和再平方，而计算自扩散电导率是先平方再加和。&#x3D;&#x3D;两者之间的差别是：先加和再平方会比后者多出一些不同离子的交叉项，是不同离子间对扩散方向的影响&#x3D;&#x3D;</p></blockquote><p>计算电导率的公式完整版如下：</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20240524193235621.png" alt="image-20240524193235621"></p><p>根据</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230511213843702.png" alt="image-20230511213843702"></p><p>容易得到，在使用Nernst-Einstein公式计算离子电导率时，使用的离子扩散系数通常为：</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230511213949637.png" alt="image-20230511213949637"></p><p>也就是说，2中所使用的扩散系数的计算是更简化的</p><p>表示不同离子间关联性的函数是$H_R$</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230511214519699.png" alt="image-20230511214519699"></p><p>&#x3D;&#x3D;self部分是独立的，而distinct部分表示不同离子间的相互作用&#x3D;&#x3D;，&#x3D;&#x3D;如果不同的离子优先向相同的方向移动，那么distinct的值为正，$H_R$的值就小于1，也就是$D_\sigma$的值会大于计算的$D^*$&#x3D;&#x3D;.</p><h3 id="4-整体的关联系数-f-I"><a href="#4-整体的关联系数-f-I" class="headerlink" title="4.整体的关联系数$f_I$"></a>4.整体的关联系数$f_I$</h3><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230511215703315.png" alt="image-20230511215703315"></p><h2 id="2-在液体电解质中的情况"><a href="#2-在液体电解质中的情况" class="headerlink" title="2.在液体电解质中的情况"></a>2.在液体电解质中的情况</h2><h2 id="3-昂萨格倒易关系、Green-Kubo公式与速度自关联函数、扩散系数"><a href="#3-昂萨格倒易关系、Green-Kubo公式与速度自关联函数、扩散系数" class="headerlink" title="3.昂萨格倒易关系、Green-Kubo公式与速度自关联函数、扩散系数"></a>3.昂萨格倒易关系、Green-Kubo公式与速度自关联函数、扩散系数</h2><blockquote><p>Transport phenomena in electrolyte solutions: Nonequilibrium<br>thermodynamics and statistical mechanics</p></blockquote><h3 id="1-不同的扩散理论"><a href="#1-不同的扩散理论" class="headerlink" title="1. 不同的扩散理论"></a>1. 不同的扩散理论</h3><ol><li><p><strong>Stefan-Maxwell equations</strong>(力平衡理论,起源于气体动理论）</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230515160550000.png" alt="image-20230515160550000"></p></li></ol><p>左侧是作用在离子上的热力学力，右侧是离子与其他离子的摩擦力 </p><p>$\vec{u}_i$: 电化学势</p><ol start="2"><li><strong>经典的不可逆热力学过程（Onsager,Prigogine,Groot,Mazur)</strong></li></ol><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230515161146452.png" alt="image-20230515161146452"></p><p>翻译：利用内部熵产生率将热力学力与流使用输运系数矩阵连接起来</p><p>Onsager系数可以利用Breen-Kubo关系直接在分子模拟中计算出来</p><p>2.1 质量守恒定律 <a href="https://zhuanlan.zhihu.com/p/142394625">连续介质力学基础：动量守恒方程 - 知乎 (zhihu.com)</a></p><p>2.2 电荷守恒定律到麦克斯韦方程组   ：电荷守恒原理及其对四维时空坐标变换的不变性激发了第一对麦克斯韦方程组</p><p><a href="https://zhuanlan.zhihu.com/p/373965779">电荷守恒定律决定麦克斯韦方程组？ - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/389735662">由麦克斯韦方程组推导电荷守恒定律 - 知乎 (zhihu.com)</a></p><p><a href="https://www.zhihu.com/question/529304982/answer/2452939120">(23 封私信 &#x2F; 81 条消息) 能否用文字分别表述麦克斯韦方程组四个式子的意思？ - 知乎 (zhihu.com)</a></p><p>2.3 动量守恒</p><p>2.4 能量守恒</p><p>4 昂萨格回归假设：</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230516152352215.png" alt="image-20230516152352215"></p><p>线性响应理论</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230516153440498.png" alt="image-20230516153440498"></p><p>注意，响应函数是系统的内禀性质</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230516153619278.png" alt="image-20230516153619278"></p><h2 id="4-非平衡统计力学学习（非平衡统计力学-陈式刚）"><a href="#4-非平衡统计力学学习（非平衡统计力学-陈式刚）" class="headerlink" title="4.非平衡统计力学学习（非平衡统计力学 陈式刚）"></a>4.非平衡统计力学学习（非平衡统计力学 陈式刚）</h2><blockquote><p><strong>没有详细学习的必要，对重要的章节了解</strong></p></blockquote><h3 id="1-非平衡统计力学的发展概况与基本内容"><a href="#1-非平衡统计力学的发展概况与基本内容" class="headerlink" title="1. 非平衡统计力学的发展概况与基本内容"></a>1. 非平衡统计力学的发展概况与基本内容</h3><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230516150635873.png" alt="image-20230516150635873"></p><h2 id="5-缺陷运动的绝对速率理论、同位素效应"><a href="#5-缺陷运动的绝对速率理论、同位素效应" class="headerlink" title="5. 缺陷运动的绝对速率理论、同位素效应"></a>5. 缺陷运动的绝对速率理论、同位素效应</h2><blockquote><p>引用自 FREQUENCY FACTORS AND ISOTOPE EFFECTS IN SOLID STATE RATE PROCESSES</p></blockquote><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230619152518393.png" alt="image-20230619152518393"></p><ol><li><p>$\gamma &#x3D;ve^{-\Delta F&#x2F;kT}$</p><p>其中，$v$是沿着鞍点方向的振动频率</p></li></ol><h1 id="2-提升离子电导的经验观点"><a href="#2-提升离子电导的经验观点" class="headerlink" title="2. 提升离子电导的经验观点"></a>2. 提升离子电导的经验观点</h1><h2 id="1-跳跃频率和浓度对离子电导分别的影响-（跳跃几率，指前因子）"><a href="#1-跳跃频率和浓度对离子电导分别的影响-（跳跃几率，指前因子）" class="headerlink" title="1.跳跃频率和浓度对离子电导分别的影响 （跳跃几率，指前因子）"></a>1.跳跃频率和浓度对离子电导分别的影响 （跳跃几率，指前因子）</h2><blockquote><p>Hopping Rate and Migration Entropy as the Origin of Superionic Conduction within Solid-State Electrolytes</p><p>&#x3D;&#x3D;<strong>最新的结论：这篇文章的成立只是验证了焓熵关系的一个推论，即$\alpha &lt;\frac {1}{k_BT}时，活化能减少，跳跃次数增加，电导率升高$ 。比较好的一点是将电导率的升高依赖于跳跃次数的增加  $\omega _p&#x3D;\omega_0 exp(E_m(\frac{k_BbT-1}{k_BT}))$</strong>&#x3D;&#x3D;</p></blockquote><p><em><strong>结论：</strong></em>并不认同 ，&#x3D;&#x3D;但是一些推论可以作为理解MNR规则的源头，而且将晶格振动联系起来（跳跃次数的出现）&#x3D;&#x3D;</p><ol><li><p><em><strong>离子电导率和跳跃频率都遵循随着温度的阿伦尼乌斯公式，而载流子浓度保持为常数 (很正常，这一温度范围内载流子浓度并不会有很大变化，热激发能量变化不够）</strong></em></p></li><li><p><em><strong>相比载流子的浓度，载流子的迁移率对提升离子电导率更重要</strong></em></p></li></ol><h3 id="1-离子电导率随频率变化以及跳跃频率"><a href="#1-离子电导率随频率变化以及跳跃频率" class="headerlink" title="1. 离子电导率随频率变化以及跳跃频率"></a>1. 离子电导率随频率变化以及跳跃频率</h3><p>Jonscher universal power law</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230519103648585.png" alt="image-20230519103648585"></p><blockquote><p> <em><em>$\sigma</em>{dc}$是电导率的$d</em>.c_.$ 限制，$\omega$是角频率,A是与温度相关的系数__</p></blockquote><p>$\sigma_{dc}$和系数A的关系为</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230519104020863.png" alt="image-20230519104020863"></p><p>$\omega_p$是&#x3D;&#x3D;跳跃&#x3D;&#x3D;频率，将上面公式结合可得</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230519104127915.png" alt="image-20230519104127915"></p><p>因此，当测得的$\sigma_w&#x3D;2\sigma_{dc}$时，可以得到此时跳跃频率的值等于角频率</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230519104425493.png" alt="image-20230519104425493"></p><ul><li>&#x3D;&#x3D;借助实验手段，可以测得材料中离子的跳跃频率&#x3D;&#x3D;</li></ul><h3 id="2-离子电导率阿伦尼乌斯公式"><a href="#2-离子电导率阿伦尼乌斯公式" class="headerlink" title="2. 离子电导率阿伦尼乌斯公式"></a>2. 离子电导率阿伦尼乌斯公式</h3><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230519102034548.png" alt="image-20230519102034548"></p><p>阿伦尼乌斯公式的指前因子为</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230519102056764.png" alt="image-20230519102056764"></p><blockquote><p>$\omega_0 $ ： 尝试频率</p><p>$\Delta{S}_m$ : 迁移熵，应该是过渡态和基态的熵变</p><p>$\alpha_0$ : 跳跃距离</p><p>$z$：几何因子</p></blockquote><p>跳跃频率是热激活的</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230519102949980.png" alt="image-20230519102949980"></p><p>$E_m$:迁移活化能（扩散势垒）</p><p>&#x3D;&#x3D;这里需要注意的是，跳跃频率不止等于尝试频率*exp(-Em),而是等于尝试频率**exp(G)&#x3D;&#x3D;</p><p>&#x3D;&#x3D;通常测量的总的活化能$E_a$包括两部分：生成迁移离子需要的能量以及离子迁移的能量，即$E_a$包括了$E_m$，这里的Ea只特指跳跃前后的焓变。&#x3D;&#x3D;</p><blockquote><p> <strong>$\omega_p与电导率的关系$：</strong></p><p>​                                     $\sigma T&#x3D;\omega_p\frac{znq^2}{k_B}exp(-\frac{E_a-E_m}{k_BT})\alpha_0^2)$</p><p>而电导率$\sigma$与扩散系数的关系为</p><p>$\sigma T&#x3D;\frac{nq^2}{k_B}D$</p><p>因此可以计算$\omega_P$与扩散系数D的关系</p><p>$D&#x3D;z\omega_p\alpha_0^2exp(-\frac{E_a-E_m}{k_BT})$</p><p>$\omega_p$等价于$\mu_0exp(-\frac{E_a}{k_BT})$,说是跳跃频率是合理的,只是跳跃频率不再只和Ea有关，而是和G有关</p><p>将$w_p$的值带入得</p><p>$D&#x3D;z\alpha_0^2\omega_0exp(-\frac{Ea}{k_BT})exp(\frac{\Delta S_m}{k_B})$</p></blockquote><p>&#x3D;&#x3D;现在将电导率的公式展开来写就变成（展开的越详细各种效应越清晰：&#x3D;&#x3D;</p><p><strong>$\sigma T&#x3D;\frac{znq^2}{k_B}\alpha_0^2\omega_0exp(\frac{\Delta S_m}{k_B})exp(-\frac{E_a-E_m}{k_BT})exp(-\frac{E_m}{k_BT})$</strong></p><p>其中，迁移熵$\Delta{S}_m$是运动前后晶格振动的变化带来的。 </p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230519105218197.png" alt="image-20230519105218197"></p><p>依据公式</p><p>定义载流子浓度量为 </p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230519110601952.png" alt="image-20230519110601952"></p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230519105420194.png" alt="image-20230519105420194"></p><p>电导率据此等于</p><p>$\sigma T&#x3D;C\omega_p exp(-\frac{E_a-E_m}{k_BT})$</p><p>包括了生成载流子的活化能的影响</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230519110727812.png" alt="image-20230519110727812"></p><p>载流子的“浓度”随温度变化不大</p><h3 id="3-分析"><a href="#3-分析" class="headerlink" title="3.分析"></a>3.分析</h3><ol><li><p>文章亮点在于将可用实验验证的量$\omega_ p$使用起来，它最主要的关系还是和扩散系数D。这样$E_m$就有了，定义的浓度C也有了</p></li><li><p>主要的有用的地方是把跳跃频率从尝试频率中分开了</p></li><li><p>在温度变化过程中，主导的是跳跃频率这一物理量（这个是很明显，不用做实验都可以发现的，因为浓度不变，只有跳跃几率随温度变化）</p></li><li><p>最后的例子说明不了和浓度无关，有可能是浓度增加导致跳跃次数变多，因为跳跃次数是和浓度相关的。不能说明任何问题</p></li><li><p>而且关于浓度系数的计算不是十分认同，很明显，浓度应该有比较大的不同</p></li></ol><ul><li><p>从文章中得到的启发</p><ul><li><p>从Li3YCl6和Li3HoCl6的对比中可以得到，&#x3D;&#x3D;在Li-Cl这一体系中，跳跃频率越大，能垒越低，电导率越高，这三者是统一的。&#x3D;&#x3D;但是跳跃频率越大，并不能说明振动（或者尝试）频率越大，这同先前的-爱-公式并不矛盾（振动频率越大，势垒也越高）。&#x3D;&#x3D;这说明一点，能垒越低的地方，尽管其振动频率比较低，但是跳跃频率却是高的，电导率就更高&#x3D;&#x3D;。对于Li-Cl体系，不应该去找刚性的结构，而是柔性的结构（离子半径更大的结构）。</p></li><li><p>由于Li3HoCl6中Ho的离子半径更大，骨架结构更加柔软，因此可以得到更低的活化能，并且有更大的离子跳跃距离，这是必然的结果，比较意外的是Li3HoCl6的跳跃频率更大，&#x3D;&#x3D;这说明更加柔软的骨架结构尽管尝试频率变小，但是跳跃频率会增加。&#x3D;&#x3D;</p></li></ul><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230519170204452.png" alt="image-20230519170204452"></p><ul><li><p>一个问题就是，是否在氧化物，硫化物中，都遵循着这一结论（NYSO说明是的）</p></li><li><p>从Li-Cl体系的尝试频率和活化能也能看出，活化能越高，尝试频率也越大</p></li><li><p>由本文可知，在一些体系中，在下式中，$\omega_0$的值越小，后面的乘积越大，并且整体相乘是增加的。Em是减小的，而振动熵并不单调变化。</p></li></ul><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230519102949980.png" alt="image-20230519102949980"></p><p>​       怀疑振动熵和晶格振动相关，并且振动熵的变化很小</p><ul><li><p>由Meyer-Neldel 规则，活化能降低，指前因子降低，如果考虑Li-Y-Cl和Li-Ho-Cl</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230519102056764.png" alt="image-20230519102056764"></p><p>根据本文，$\sigma _0&#x3D;\frac{znq^2}{k_B}\alpha_0^2\omega_pexp(\frac{E_m}{k_BT})$</p><p>$E_m$ 下降时，$\omega_p$ 增加，但是两个相乘根据Meyer-Neldel又是降低的。</p></li></ul></li></ul><ol><li><p>浓度系数变化的根源（感觉应该不变才对）</p></li><li><p>&#x3D;&#x3D;没有给出为什么振动频率降低，跳跃频率反而增加&#x3D;&#x3D;</p></li><li><p>存在两种博弈，1.前置因子中，尝试频率和其他的博弈，2. 跳跃频率中，尝试频率与其他的博弈</p></li></ol><h2 id="2-Meyer-Neldel规则"><a href="#2-Meyer-Neldel规则" class="headerlink" title="2.Meyer-Neldel规则"></a>2.Meyer-Neldel规则</h2><h3 id="1-跳跃次数和活化能成反比是有限制的"><a href="#1-跳跃次数和活化能成反比是有限制的" class="headerlink" title="1.  跳跃次数和活化能成反比是有限制的"></a>1.  跳跃次数和活化能成反比是有限制的</h3><blockquote><p>&#x3D;&#x3D;需要满足一定的前置条件，才能达到上面的推论，而这一前置条件由结构决定&#x3D;&#x3D;</p></blockquote><blockquote><p>Rethinking the Design of Ionic Conductors Using Meyer–Neldel–Conductivity Plot</p></blockquote><ol><li><p>随着活化能的降低，前置因子也在降低</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230520100213374.png" alt="image-20230520100213374"></p><blockquote><p>对给定系列的化合物，$\alpha$和$\beta$是常数</p></blockquote></li></ol><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230520100605086.png" alt="image-20230520100605086"></p><blockquote><p>是$\alpha -\frac{1}{k_BT}$</p></blockquote><p>$\alpha 和\frac{1}{k_BT}$的关系决定了活化能降低能否带来电导率升高，决定能否带来跳跃次数增加  同结构的关系</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230520163051407.png" alt="image-20230520163051407"></p><p><del>最终决定的是最下面的式子（&#x3D;&#x3D;这就是焓熵关系。。。白整了&#x3D;&#x3D;）</del></p><p><del>如果振动熵的一连串式子大于活化能，那么活化能越高，相差越大，电导率越高，反之，如果振动熵的式子小于活化能，那么活化能越低，相差越小，跳跃次数越大，离子电导率越高。这样下面两个式子就统一了，下面这两个在说同一件事情。但是这样的结论的一个问题是温度在其中扮演了很重要的角色，因为温度决定了式子的变化，因此要么在实际中结构随温度变化真有一个临界点，要么有一个指数项，取消了温度的影响。</del></p><p><del>wp一定小于w0的啊，肯定有w0的参与。</del></p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230519102949980.png" alt="image-20230519102949980"></p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230520163653958.png" alt="image-20230520163653958"></p><p><strong>&#x3D;&#x3D;跳跃前后熵的变化和跳跃过程中的活化能的关系（是否由结构决定）&#x3D;&#x3D;</strong></p><h2 id="3-Meyer-Neldel-rule和焓熵关系"><a href="#3-Meyer-Neldel-rule和焓熵关系" class="headerlink" title="3. Meyer-Neldel rule和焓熵关系"></a>3. Meyer-Neldel rule和焓熵关系</h2><blockquote><p>Thermodynamic Interpretation of the Meyer-Neldel Rule Explains Temperature Dependence of Ion Diffusion in Silicate Glass</p></blockquote><h3 id="1-扩散系数的理论基础"><a href="#1-扩散系数的理论基础" class="headerlink" title="1. 扩散系数的理论基础"></a>1. 扩散系数的理论基础</h3><p>扩散系数                                                                   <img src="/./../%E5%9B%BE%E7%89%87/image-20230522155102889.png" alt="image-20230522155102889"></p><blockquote><p>$R_0$ 是尝试频率</p></blockquote><p>其中 $\Delta E_a$是两个状态的吉布斯自由能差</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230522155222366.png" alt="image-20230522155222366"></p><p>因此                                                                            <img src="/./../%E5%9B%BE%E7%89%87/image-20230522155236983.png" alt="image-20230522155236983"></p><p>a是一个常数</p><p>MNR规则的焓熵表述为 </p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230522155327270.png" alt="image-20230522155327270"></p><p>其中b是一个常数</p><p>通过定义一个量</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230522155436229.png" alt="image-20230522155436229"></p><p>可以得到</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230522155448375.png" alt="image-20230522155448375"></p><p>焓熵表述与下述表述等价</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230520100213374.png" alt="image-20230520100213374"></p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230519102056764.png" alt="image-20230519102056764"></p><p>&#x3D;&#x3D;这里的熵是过渡态与基态的熵变，也就是说，按照这个文章的说法，计算得到的是焓变，而不是真实的活化能。之间相差一个熵变，熵变就成为指前因子的一部分。而上一篇文章还说，焓变分两部分，一部分产生空位，一部分用来跳跃。而测量得到的只是跳跃的焓变即&#x3D;&#x3D;</p><p>$\Delta E_a&#x3D;\Delta G&#x3D;\Delta H-T\Delta S&#x3D;\Delta H_1+\Delta H_2-T\Delta S$</p><p>&#x3D;&#x3D;我自己的理解：可以暂时不区分焓变的两部分，计算NEB得到的的确没有熵的部分，而测量得到的既然也遵守MNR，那么测量得到的也只是跳跃过程，而不包括熵变，这里的熵是过渡态和基态的熵变，暂时理解为过渡态和基态的振动熵变。&#x3D;&#x3D;</p><h3 id="2-焓熵关系是本质"><a href="#2-焓熵关系是本质" class="headerlink" title="2. 焓熵关系是本质"></a>2. 焓熵关系是本质</h3><blockquote><p>通过焓熵关系可以得到上面的离子电导率随活化能变化的关系</p></blockquote><ol><li><p>$b&#x3D;\alpha$  上面的文章也就是在说，通过比较$b和k_BT的大小，可以确定增加电导率的策略$</p><p>b是一个熵与焓变的比例系数 ，有能量的量纲，那么kb的量纲为$ev^2&#x2F;K$</p><p>系数有一个临界点还是很有趣的</p><p>将下式改写</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230519102949980.png"></p><p>得到 $\omega _p&#x3D;\omega_0 exp(E_m(\frac{k_BbT-1}{k_BT}))$</p><p><del>这样似乎就推不出什么情况下w_p的值增加了</del></p></li></ol><p>​     &#x3D;&#x3D;第一篇文章和第二篇文章的含义是相同的：在$b&lt;\frac{1}{k_BT}$时，$E_m$越低，跳跃频率越大，电导率越高，第一篇文章只不过是这一种情况&#x3D;&#x3D;。但是当b &gt; $\frac {1}{k_BT}$时，文章一的结论就不成立了。第一个文章的局限性就是只有在第二个文章成立时，才成立。</p><ol start="2"><li><del>目的一：跳跃次数增加和电导率之间关系的理解，解决，就是焓熵关系的变形</del></li></ol><p>   <u>&#x3D;&#x3D;目的二&#x3D;&#x3D;：将结果与晶体结构联系起来，未解决，焓熵关系的系数b与结构的关系</u></p><p>   目的四：还是认为跳跃次数增加是MNR背后的物理含义 ，但是在焓熵关系描述下，这一规则被弱化了，这种想法是对的</p><p>   &#x3D;&#x3D;目的五&#x3D;&#x3D;：还是试图理解，为什么活化能降低，跳跃次数增加了，需要理解</p><p>   目的六：发现竞争关系，并且将竞争关系同结构、或者什么变为统一的关系</p><p>   目前一个新的竞争关系，b和E_m、w_0的竞争</p><p>​      目的七：跳跃次数增加和a-1&#x2F;k_bT&lt; 0之间有没有关系，有关</p><h2 id="4-推论"><a href="#4-推论" class="headerlink" title="4.推论"></a>4.推论</h2><ol><li><p>&#x3D;&#x3D;焓熵系数与 $k_B T$的大小决定了增加活化能，跳跃次数是否增加，离子电导率是否增加。&#x3D;&#x3D;</p></li><li><p>问题在于如何直观得理解增加活化能与跳跃次数增加间的关系，与晶格振动的关系，这涉及到熵和吉布斯自由能的变化</p></li><li><p>&#x3D;&#x3D;跳跃次数是隐含在焓熵关系中的，当$b&lt;\frac{1}{k_BT}$ 时，活化能越小，跳跃次数越大，电导率越高；当$b&gt;\frac{1}{k_BT}$时，活化能越大，跳跃次数越大，电导率越高&#x3D;&#x3D;</p></li><li><p>&#x3D;&#x3D;扩散势垒和熵变相关，对一类材料，熵变越大，势垒越大（势垒越大，熵变越大）。这个关系还决定了跳跃次数的增减（跳跃几率），&#x3D;&#x3D;</p></li><li><p>对势垒相同的材料，熵增越大，b值越大，跳跃次数越多（对b&lt;kbT和b&gt;kbT都适用）</p></li></ol><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230522212936365.png" alt="image-20230522212936365"></p><p>是焓与熵的竞争，熵越大，吉布斯自由能变化量越少，并不是势垒越低越好，还有熵的影响。真实的跳跃是吉布斯自用能势能面的平滑，而不是扩散势垒的平滑。</p><p>&#x3D;&#x3D;！！！增加熵是增加离子电导率的一个有效方向&#x3D;&#x3D;</p><ol start="7"><li><p>&#x3D;&#x3D;$\Delta G_A&#x3D;\Delta H_A-Tkb\Delta H_A&#x3D;\Delta H_A(1-Tkb)$ ，如果$b&lt;\frac{1}{k_BT}$ ,$\Delta G&gt;0$ ，反之，小于0&#x3D;&#x3D;</p></li><li><p>为什么会有$\Delta G &lt;0$的材料，正常，因为正常是焓在起作用，而不是熵和焓一起。对于b&gt;1&#x2F;kBT的材料，是否存在实验和计算晶格占据点不同的！！！感觉b小于才是正常的，这也是为什么大多数见到的都是活化能越小，电导率越高。计算的都是焓最低的结构。计算中有没有出现在一些点停留比较久而不是能量最低的时候。做一下计算，分子动力学能否考虑熵</p></li><li><p>&#x3D;&#x3D;<strong>b与结构的关系，以及为什么和b与k_BT的关系会影响到跳跃次数，用语言解释</strong>&#x3D;&#x3D;，&#x3D;&#x3D;为什么有焓熵关系&#x3D;&#x3D;。</p></li><li><p>如果知道玻璃化转变温度，就能得到b的值</p></li><li><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230523091203327.png" alt="image-20230523091203327"></p><p>根据这个式子，要求$\omega _0 &gt;\omega_p$，也就是要求后面的式子小于1，也就是</p><p>$exp(\frac{T\Delta S_m-E_m}{k_BT})&lt;1$</p><p>也就是$T\Delta S_m-E_m&lt; 0 $ ，也就是$\Delta G  $大于0 (可以和第七条连起来)</p><p>&#x3D;&#x3D;那么，在$b&gt;\frac {1}{k_BT}$的材料中，$\Delta G$&lt;0，$\omega _0 &lt;\omega_p$，也就是跳跃频率多于尝试频率。问题是这样的材料真实存在，难道跳跃频率不止来源于尝试频率，还有熵驱动&#x3D;&#x3D;</p></li><li><p>迁移熵<img src="/./../%E5%9B%BE%E7%89%87/image-20230523095425635.png" alt="image-20230523095425635"></p></li><li><p>存在两个矛盾，</p><ol><li>吉布斯自由能变化量为负，跳跃频率会高于尝试频率，随着Ea增加，电导率增加</li><li>最新文章计算出的熵居然是负数</li></ol></li></ol><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230523100827766.png" alt="image-20230523100827766"></p><ol start="14"><li><p><u>为什么扩散到过渡态的过程是熵增的过程？这种熵增和结构的关系</u></p></li><li><p>k_BT是随温度变化的，所以和b的比较并不固定</p></li><li><p><u>&#x3D;&#x3D;$b&gt;\frac {1}{k_BT}$ 意味着 $\frac{\Delta H _A}{\frac{\Delta S_A}{k}}&lt; k_BT$，也就是说需要跳跃的势垒除以一个常数小于热激发的能量。或者已经高于玻璃化转变温度了。这个时候还是跳跃吗，就像高压高温下的东西，已经不能说是跳跃了，而是和液体一样流动。统一了高压下近熔化区和离子电导。wp&gt;w0，有些非尝试频率的振动也会引起跳跃&#x3D;&#x3D;,</u></p><p><strong>但是没有完全小于</strong></p></li><li><p>那些反常的材料到底是怎么回事 。离子跳跃只与几种特定的振动模相关和振动熵的联系</p></li><li><p>在田艺帆的高温高压质子电导中，虽然已经没有了空位，但是离子</p></li><li><p>当b&#x3D;1&#x2F;k_BT时，具有相同b值的所有的离子电导相等，扩散系数相交于一点</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230524104714644.png" alt="image-20230524104714644"></p></li></ol><p>高温下熵起作用，低温下，焓起作用。</p><p>20.熵如何与特定的晶格振动支联系起来，为什么是一个熵增的过程，什么样的晶格振动有助于降低b。b与活化能调控效果的关系</p><p>为什么现有的并没有达到水的效果。NYSO的这个关系。</p><ol start="21"><li><u>这种熵和角共享的关系</u></li><li>通过加压测电导率可以很快速的获得b的值</li><li><img src="/./../%E5%9B%BE%E7%89%87/image-20230520100605086.png" alt="image-20230520100605086"></li></ol><p>当b&lt; 时，b值越小，e指数上面的括号内差值越大，改变Ea带来的效果越好 ；当b&gt;时，b值越大，改变Ea带来的效果越好</p><p>有熵的项并不影响离子电导率和1&#x2F;T成反比，也就是不影响活化能的计算，但是影响最终离子电导率</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230524140047855.png" alt="image-20230524140047855"></p><p>&#x3D;&#x3D;因此，如果要找室温电导率好的，不但要关注现有的结构的电导率，还要看b值大小，有了b值，就可以确定当活化能变为多少时，离子电导率的值大小为多少，定性的进行评估，可以给一类结构制定一个上限。&#x3D;&#x3D;这样可以给一类一类材料进行评估。考虑一类材料在什么温度下有作为固态电解质的潜力，是否适合做。</p><p>问题在于如何获得活化能，这个活化能不是NEB计算的活化能。活化能与晶格振动的关系。</p><p>24.一种材料的b是固定的，不固定的是温度 </p><ol start="25"><li><p><del>如果没有熵的效应，那么通过优化得到的是一系列的平行线，而不会有交点</del></p><p>有了熵的效应，导致相交点不在T–0，而在中间一个点</p></li></ol><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230524135356318.png" alt="image-20230524135356318"></p><p>$ln(R)&#x3D;ln(a)-\frac {\Delta H_A}{kT}+b {\Delta H_A}$</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230524135701005.png" alt="image-20230524135701005"></p><p>绘制这样的log图像仍然是可以的，只不过纵轴有b的作用，不同的材料，在纵轴的截距就不同了，否则，所有的截距是相同的。</p><ol start="26"><li>理论上知道系统的活化能，只需要算一个高温温度点就可以了。难点在于活化能的确定</li><li>和指前因子随活化能线性增加是一致的。如果是完美符合MNR关系，那指前因子应该是完美的线性关系，但是实际上大部分并不是。但是对于给一些压强，是这样的。</li></ol><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230525162530034.png" alt="image-20230525162530034"></p><p>说明压强能够很好的表示出结构的特征，大部分并不是严格的线性关系</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230525162724780.png" alt="image-20230525162724780"></p><p>指前因子的其他部分未必是相等的</p><ol start="28"><li><p>$\omega _p&#x3D;\omega_0 exp(E_m(\frac{k_BbT-1}{k_BT}))$  w_p有一个最大值,即T趋近无穷大时，$w_p &#x3D;w_0exp(bE_m)$，可以用来说明离子电导的潜力</p></li><li><p>跳跃次数   $\omega _p&#x3D;\omega_0 exp(E_m(\frac{k_BbT-1}{k_BT}))$</p></li></ol><p>​      电导率     $\sigma T&#x3D;\frac {nq^2}{k_B}a^2w_p$        可以看出电导率和跳跃次数的变化是相同的（假设每次跳跃距离不变）</p><ol start="30"><li><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230526153028288.png" alt="image-20230526153028288">  </p><p>&#x3D;&#x3D;这是来自于自己的结论。&#x3D;&#x3D;</p><p>氧化物的交点都比较大，因为单个声子的能量比较大，MEE模型中的熵就小（排列组合少），b值小，T_MN就大，对氧化物，软化晶格，能比软化硫化物晶格获得更大的收益，软化后的单个声子能量就小了，动力学熵增加（是否也需要一个度呢）</p><p>是否软化晶格的度（晶格能被软化的程度）与结构构型、绳子带心、这些有关，能证明这件事很有意义</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230918111106469.png" alt="image-20230918111106469"></p><p>Phonon–Ion Interactions: Designing Ion Mobility Based on Lattice Dynamics</p></li><li><p>通过得到b值，可以粗略估计什么温度下达到什么样的电导率需要什么样的活化能</p></li></ol><h2 id="5-目前关注问题"><a href="#5-目前关注问题" class="headerlink" title="5.目前关注问题"></a>5.目前关注问题</h2><ol><li><p>为什么有焓熵关系（熵变为什么随焓变化，是什么熵，为什么会在过渡态增加，跳跃次数）（组合熵）</p></li><li><p>b与结构的关系(关系到不同种类的结构，角共享，晶格振动)，非谐效应在其中起到什么样的作用</p></li><li><p>为什么是一个熵增的过程，这种熵增不同结构类型间的差异，如何判断 （组合熵，组合种类）</p></li><li><p>能为寻找高离子电导率材料带来什么启发（应该寻找哪种材料，是否可以据此给出一个预测的最高离子电导率值，关系到同一种类结构的调控，推论30，提升离子电导率，找什么系列）</p></li><li><p>温度升高，更容易跳过去，如何从能量上和振动上分别理解，吉布斯自由能是不同结构间的比较，振动模型是$k_BT$。表象是振动，内涵是能量吗</p><p> 温度升高，离子振动频率是不变的（晶格体积不变时）或者频率降低（考虑热膨胀）</p><blockquote><p>吉布斯自由能的差值代表了基态和过渡态的能量差，也就是势垒，温度升高，振动熵的部分也随之增加，那么势垒本身是在降低的，但是存在一个问题，现在的计算考虑的只是焓的变化，而不考虑振动熵的影响。&#x3D;&#x3D;振动熵是比原来理解中更加重要的，因为表象是振动，内涵是能量&#x3D;&#x3D;</p><p>另一方面，离子振动的能量$k_BT$也在增加，跨越势垒的能力变大$e^\frac{-E_a}{k_BT}$变大。但是，存在一个问题，只要活化能$E_a$不等于0，那么就是一个跳跃几率，是跳跃模型。活化能为0，才意味着是熔化，是自由的流动</p><p>晶格振动方面，温度越高，振动频率越大，振幅应该是固定的吗</p></blockquote></li><li><p>对同一个结构，温度升高，在体积不变的情况下，振动模式频率没有变化（力常数没有变化），但是声子在同一个振动模式上的数量增加了（玻色爱因斯坦分布）；这样导致振幅增加了，在振动上看，更加容易跳过去。声子在某个频率上的增加，意味着这一模式的振幅的增加。</p></li><li><p>振动熵确实会随着温度增加而变化！！</p></li><li><p>对同一个结构，不同温度下的焓熵关系是固定的吗，因为焓是随温度不变的，熵是随着温度增加而改变的，那么不同温度下，必然存在不同的焓熵关系了。</p><p> &#x3D;&#x3D;并不对，真实活化能是变化的，但是在公式里不存在&#x3D;&#x3D;$T\delta S$ 项，&#x3D;&#x3D;因此显示在图像中的仍然只是表观的&#x3D;&#x3D;$\delta H$</p></li><li><p>同一个结构中，不同的元素类型（元素配比）会对振动熵产生什么影响；结构的振动熵和化学组分的关系。</p></li><li><p>加入尝试频率、单次跳跃距离</p></li><li><p>如何跳跃的</p></li><li><p>振动熵与组分的关系，振动熵与结构的关系</p></li><li><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230526200356585.png" alt="image-20230526200356585"></p><pre><code>这里的$\Delta G_A $是两个构型的吉布斯自由能差，应该要包括通常零温下计算不包括的振动能和振动熵，&gt; 振动能、振动熵&gt;&gt; 构型能量差</code></pre></li><li><p>电导率公式中的Ea就是$\Delta H$,考虑熵之后因为分母也有T，所以温度的影响被忽略了。</p><pre><code> 像那种发生高温相变的结构，$\Delta H$发生变化，但是还是大于0的，这和自己理解的高温下占据点的变化是不同的。  问题是当$\Delta G$&lt;0时，会发生什么，因为随着温度升高，必然存在这样的现象，那么变化之后，还如何考虑离子的跳跃过程，如何解释LiPSClBr,自由能对离子的影响比较直观，但是熵就很不明确。  实验中到底测量的是什么，是如何测量的，实验原理是什么</code></pre></li><li><p>能否通过结构原型的特征（振动特征或者其他的特征）给出结构的b值（和迁移离子的低能声子模、晶格框架的特定振动模、非谐效应应该存在唯一的关系，振动本身包含了晶格的结构信息、也就是孔径的大小）</p></li><li><p>这种焓熵关系在协同扩散中的表现是什么样的</p></li><li><p>对相同的$\Delta H$,$\Delta S$越小，b越小,$T_{MN}$越大，降低活化能带来的室温离子电导率收益越大。b小这意味着，单个声子的能量越大的材料，降低活化能带来的好处更大</p></li></ol><h2 id="6-当前关注的因素"><a href="#6-当前关注的因素" class="headerlink" title="6.当前关注的因素"></a>6.当前关注的因素</h2><ol><li><p>从化学角度讲，软硬酸碱理论可以判断结构的稳定性</p><p>另一方面，如果根据软硬酸碱理论，Li、Na、K、都是硬碱，而硫化物比氧化物更加软，也可以解释为什么硫化物比氧化物的离子电导率更强，因为硬酸对硬碱，软酸对软碱，Li和较软的硫化物的成键是更弱的，而和更硬的氧化物成键是更强的，</p><p>相比之下，Na比Li更软，更软的碱更适合匹配更硬的氧化物，这样结合更加不紧密，离子电导率更高。问题在于Na是否是足够软，能够使得氧化物比硫化物更占据优势（从电负性上考虑，确实也是这样，硫的电负性更低，对锂离子的作用更弱，而氧的电负性更高，这样的对比下，电负性是更根本的的，软硬酸碱是更容易用来做问题的）</p></li><li><p>我仍然相信晶格振动是最终的描述离子跳跃的答案（除了协同扩散，直觉上已经不是跳跃的模型了），晶格振动的简谐、非谐如何刻画结构的离子电导率的特征</p><p>是否是一些文章中探讨的 框架的特定振动模式或者跳跃离子的特定范围振动模式起到主要作用</p></li><li><p>还有爱因斯坦关系中表述的，势垒越大，振动的振幅越小，频率越高，与晶格振动应该是一脉相承的</p></li><li><p>还有之前提到的，势垒越低，振动频率减小，有效的跳跃频率反而增加了，这与我现在了解的MNR rule的结果一致，但是原理不同（现在的解释认为MNR应该具有高的势垒才能触发动力学过程中的动力学熵，明显是不同的）</p></li><li><p>成键、极化对晶格振动的影响</p></li><li><p>结构特征扮演了什么角色，硫化物和氧化物需要的结构特征现在看是不同的，从MNR角度考虑，单个激发得能量越小，激发过程中的熵越大，不知道与结构特征是否有直接的关系</p></li><li><p>对于多元化合物，鲍林规则也有一些比较经验具体的规则指定特定的多面体拼接方式，这与软硬酸碱理论是不是有冲突，还是统一的（比如倾向于共角而不是共面、共线的理论）</p></li><li><p>晶格软化也有具体的文章来讨论，怎么把晶格振动和离子极化性这样物理和化学的概念链接起来</p></li></ol><p>结构-势垒-振动-跳跃-离子半径-极化（晶格、离子）最大的问题是，这些应该是统一的，而不是各自为战</p><ol start="9"><li><p>还有一些新的振动模式，能否纳入到相同的理论框架中，这一点值得怀疑</p><p>增加离子数目的作用，也仍旧无法给出完整的定性的理论描述</p></li><li><p>对于最终的离子电导率的调控，像太极一样的方式是必然的，而不会是头痛医治头，脚痛医治脚的方式来解决痛点。</p></li><li><p>高温还是低温，对材料本身是并没有区别的，有必要详细考虑温度对特定晶格结构的作用，为什么随着温度增加，不同结构的电导率增长模式是不同的，这可能涉及到了阿伦尼乌斯公式中势垒的问题，但是阿伦尼乌斯公式只是一个经验公式，它在振动模型中的底层理论是什么样子的，这个也会是一个突破口</p><p>温度对极化性、或者什么本质东西的作用（氧化物的离子电导率在高温下是并不弱的）</p></li><li><p>跳跃的离子本身和框架是强耦合还是弱耦合的（强耦合就是不同热力学状态间的变化，过渡态理论？）</p></li><li><p>是否软化晶格的度（晶格能被软化的程度）与结构构型、声子带心、这些有关，能证明这件事很有意义，能够串联</p></li><li><p>电子-成键  离子-晶格动力学 </p><p>静态-热力学 势垒、动态-动力学 动力学过程</p><p>强耦合系统</p></li><li><p>阿伦尼乌斯公式的起源：跳跃的概率取决于能跳跃的微观态占总微观态的比例，也就是只要到了能跳跃的微观态，就能跳跃，在宏观上上帝不掷色子，表观的结构上和隐含的能量上</p></li></ol><p>物理机理-调控材料</p><h1 id="3-焓熵补偿关系"><a href="#3-焓熵补偿关系" class="headerlink" title="3. 焓熵补偿关系"></a>3. 焓熵补偿关系</h1><ol><li><p>焓增加的过程也是熵增加的过程（按照对这种熵的理解，熵并不指的结构的熵，而是对应于$E_a$的组合熵)</p></li><li><p>仅根据化学组分计算振动熵和振动能</p></li></ol><blockquote><p>How Chemical Composition Alone Can Predict Vibrational Free Energies and Entropies of Solids</p></blockquote><ol><li><p>焓熵关系可以理解为：在做NEB时，移动一个离子到过渡态，能量上过渡态的能量大于平衡态，但是在移动过程中也有熵的增加，因为真实的是有温度的，而不是0K 。焓熵关系也就是在构型的能量增加时，熵也在增加。</p><p>&#x3D;&#x3D;一个问题就变成：有没有办法计算包括振动能、振动熵、高温下的NEB&#x3D;&#x3D;</p><p>&#x3D;&#x3D;也说明一件事，在温度下，有可能会发生离子向吉布斯自由能增大的方向移动。而吉布斯能小的位置反而更稳定。这肯定不对吧，因为离子总是要呆在能量更低的位置，说明有可能高温下和低温下离子的位置不同。&#x3D;&#x3D;是不是被最开始的文章误导了，不会存在b&gt;1&#x2F;k_BT的情况。那那篇文章是为什么呢，为什么实验上能做出那样的结果。   </p><p>&#x3D;&#x3D;吉布斯能和这种组合熵没有关系&#x3D;&#x3D;</p><p>实验上做的肯定是最真实的，都考虑了</p><p>随着温度增加，离子的最稳定位点会发生改变。因此在构建结构时需要考虑温度的影响</p><p>焓熵关系不仅可以用在算离子跃迁，也可以用在结构优化、平衡的各个方面。</p><p>令人困惑的是为什么高温高压下的实验文章，跨过b点时没有什么斜率的变化呢。实验测的是焓值？而不是吉布斯自由能值</p><p>经常观察到的，离子电导率斜率的变化，是否和这个有关。</p><p>构型熵也应该考虑</p><p>分子动力学和热力学的巨大鸿沟</p><p>&#x3D;&#x3D;为什么吉布斯自由能增加的非自发过程是可以进行的。&#x3D;&#x3D;确实是有问题的</p><p>第一性原理分子动力学中，不同温度下的结构能量不同</p></li><li><p>晶格振动能和振动熵：晶格振动能实际上包含在对温度的考虑中了，温度升高，振动能并不会带来能量序列的变化。没有考虑到的是振动熵，振动熵并没有考虑在温度之中。</p><p>考虑温度能否带来能量序列的变化，为什么会带来变化 ，因为考虑晶格振动能和熵吗</p></li></ol><p>​      温度和晶格振动能得关系是啥</p><ol start="3"><li><p>高通量就是指批量化的计算，计算速度并不增加</p></li><li><p>振动熵和振动能和化学组分具有高的相关性，给定化学组分，可以定性评估振动熵。</p></li></ol><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230529171309781.png" alt="image-20230529171309781"></p><p>​       振动频率的算数平均和加权平均</p><h2 id="2-晶格振动与MNR关系（一篇综述）"><a href="#2-晶格振动与MNR关系（一篇综述）" class="headerlink" title="2.晶格振动与MNR关系（一篇综述）"></a>2.晶格振动与MNR关系（一篇综述）</h2><blockquote><p>Phonon–Ion Interactions: Designing Ion Mobility Based on Lattice Dynamics</p></blockquote><ol><li><p>考虑非对称的跳跃势垒</p></li><li><p>结构因子 z 包括了关联系数H_R </p></li><li><p>测量的势垒事实包括两部分，缺陷的形成焓和跳跃过程中的焓，通常 忽略了缺陷的形成焓</p></li><li><p>改性方法：</p><blockquote><p>静态</p><ol><li>三维扩散路径</li><li>降低扩散势垒 （替代、应变改变电荷间相互作用、迁移机制、平滑势能面、传导路线的几何形状）</li><li>异价掺杂  （改变晶格尺寸、改变载流子浓度）</li></ol><p>动态</p><ol><li>软化的、极化性强的阴离子亚晶格（降低键的极性，弱化移动离子和阴离子的成键相互作用，进一步降低活化能</li></ol></blockquote></li></ol><p><img src="F:\同步空间\markdown\图片\image-20230602151435463.png" alt="image-20230602151435463"></p><p>爱因斯坦模型中，谐振子振幅和爱因斯坦频率的关系</p><p><img src="F:\同步空间\markdown\图片\image-20230602151705928.png" alt="image-20230602151705928"></p><h3 id="3-1-离子极化与离子电导（非谐）"><a href="#3-1-离子极化与离子电导（非谐）" class="headerlink" title="3.1 离子极化与离子电导（非谐）"></a>3.1 离子极化与离子电导（非谐）</h3><p> 离子的跳跃与非简谐性相关，<u>而非简谐性与离子极化能力相关</u>。</p><p>离子在一个简谐势中振动的图像忽视了离子的极化，离子极化指的是形成瞬时偶极子的能力，在元素中可以用元素尺寸和带电荷代表。与Pearson的强&#x2F;弱 酸碱的概念对应</p><p>在考虑成键相互作用时，可看作电负性差异或者键的极性，通过改变极性可以改变共价键的强度。较少极化的阳离子和较多极化的阴离子将最终形成更多的共价键相互作用，而较多极化的阳离子和较少极化的阴离子则表现出极性的离子相互作用</p><p>低频区 离子极化对晶格振动起到重要作用</p><p>&#x3D;&#x3D;通过增加成键的共价性，降低离子性，可以降低成键强度，降低活化能，增加离子跳跃频率&#x3D;&#x3D;</p><p>离子的跳跃代表非谐事件</p><h3 id="3-2-德拜频率（尝试频率）将软化的晶格与低的活化能联系起来"><a href="#3-2-德拜频率（尝试频率）将软化的晶格与低的活化能联系起来" class="headerlink" title="3.2 德拜频率（尝试频率）将软化的晶格与低的活化能联系起来"></a>3.2 德拜频率（尝试频率）将软化的晶格与低的活化能联系起来</h3><p>尝试频率与活化能的关系：</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230602160643922.png" alt="image-20230602160643922"></p><p>尝试频率与特定声子模式 （尝试频率与德拜频率）</p><p>德拜频率与声速测量相关联。</p><h3 id="3-3-将特定声学支与活化势垒联系起来"><a href="#3-3-将特定声学支与活化势垒联系起来" class="headerlink" title="3.3 将特定声学支与活化势垒联系起来"></a>3.3 将特定声学支与活化势垒联系起来</h3><p>德拜频率的测量完全忽视了光学声子对材料的影响</p><p>不同材料中，对尝试频率贡献的晶格振动模式是不同的</p><h2 id="3-迁移熵的具体形式"><a href="#3-迁移熵的具体形式" class="headerlink" title="3.迁移熵的具体形式"></a>3.迁移熵的具体形式</h2><blockquote><p>FREQUENCY FACTORS AND ISOTOPE EFFECTS IN   SOLID STATE RATE PROCESSES</p></blockquote><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230619161109340.png" alt="image-20230619161109340"></p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230619161124079.png" alt="image-20230619161124079"></p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230619161139047.png" alt="image-20230619161139047"></p><p>&#x3D;&#x3D;$v^*$是有效频率&#x3D;&#x3D;</p><p>在之前的计算中，一直认为$v*e^{\Delta S&#x2F;k_BT}$是常数</p><p>&#x3D;&#x3D;对于同一种材料不同的温度点，这确实是一个常数，因为不同温度下鞍点和平衡位置处的晶体结构没有变化，因此这个值也没有变化，&#x3D;&#x3D;</p><p>&#x3D;&#x3D;值得注意的是，焓熵关系中的熵并不是振动熵的变化，而是和振动相关的，鞍点和平衡点熵的变化。&#x3D;&#x3D;</p><p>在不同材料中，会得到不同的有效频率</p><p>&#x3D;&#x3D;目前明确了与振动相关的熵的含义，下一步需要明确的是这个熵与活化能之间的关系。&#x3D;&#x3D;</p><p>maybe可以考虑非谐</p><p>&#x3D;&#x3D;重要的一点是直接定义出了尝试频率的值！！！&#x3D;&#x3D;</p><p>给出了答案：这里的熵是什么、为什么是熵增的过程（虽然还没看懂）、熵与振动的关系</p><h2 id="4-焓熵补偿关系的来源-和晶格振动"><a href="#4-焓熵补偿关系的来源-和晶格振动" class="headerlink" title="4.. 焓熵补偿关系的来源 和晶格振动"></a>4.. 焓熵补偿关系的来源 和晶格振动</h2><blockquote><p>Multi-excitation entropy: its role in thermodynamics and kinetics</p></blockquote><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230819155311822.png" alt="image-20230819155311822"></p><p>晶格振动中的声子代表了离子跃迁吸收的能量，因此，晶格振动和活化能也是密不可分的，这里的熵是动力学过程中的熵，而不是热力学上的熵</p><p>&#x3D;&#x3D;一定注意区分，这里指的是动力学过程，而不是热力学过程&#x3D;&#x3D;</p><p>&#x3D;&#x3D;多激发熵的概念是热力学中不能得到的&#x3D;&#x3D;</p><h3 id="section-2"><a href="#section-2" class="headerlink" title="section 2"></a>section 2</h3><ol><li><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230819155655619.png" alt="image-20230819155655619"></p><p>其中w的含义是能够导致同一个宏观热力学状态的不同的微观状态的数量。对于微观粒子，这一图像是没有含义的，因为对于微观粒子，处在什么能级上是确定的（不懂这句话）</p></li></ol><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230819160116757.png" alt="image-20230819160116757"></p><p>​      对于热力学有比较好的描述，但是对于动力学过程并不完善，动力学过程中，很多现象是热激活的，遵循阿伦尼乌斯公式</p><p> <img src="/./../%E5%9B%BE%E7%89%87/image-20230819160355348.png" alt="image-20230819160355348"></p><p>​       还有一些其他的理论（WLF 1955）</p><ol start="2"><li><p>二十世纪化学&#x3D;&#x3D;动力学&#x3D;&#x3D;在稳步发展</p><p>势垒和化学反应需要跨过的的过渡态相关</p><p>势垒的大小对应初态与过渡态的&#x3D;&#x3D;热力学&#x3D;&#x3D;自由能差</p><p>过渡态理论：</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230819161327126.png" alt="image-20230819161327126"></p></li></ol><p>​                           &#x3D;&#x3D;其中的熵可以解释为导致反应发生的状态数与总的状态数的比值&#x3D;&#x3D;</p><blockquote><p>能否用热力学微观状态数的观点解释多激发熵的含义</p><p>个人理解，&#x3D;&#x3D;不能完全用势能面上的移动来理解动力学中的问题，比如势能用势能面的起伏简单地表示&#x3D;&#x3D;，在微观下势能面的变化是不能被忽视的</p><p>跳跃过程包括两部分熵，&#x3D;&#x3D;一部分是初末态的能量差中的熵变，另一部分来源于动力学过程中的熵&#x3D;&#x3D;。(化学家的看法)</p></blockquote><ol start="3"><li>如果活化能远大于声子的能量，那么要使这个过程发生，要求有多个激发（声子）的参与。（根据玻色爱因斯坦分布，温度越高，声子数越多，熵越大？）猜测多激发熵应该是如何获得这么多的声子的过程，而不是过程后的振幅增加这一个结果</li></ol><p>​       有大量的方式去收集大量的激发，这会带来熵</p><ol start="4"><li><p>对动力学过程中的熵忽略的原因是难以计算</p><p>强耦合</p></li></ol><h3 id="section-4"><a href="#section-4" class="headerlink" title="section 4"></a>section 4</h3><ol><li>补偿关系，等速规则（某一个T处值相等），Meyer-Neldel rule</li></ol><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230619211216763.png" alt="image-20230619211216763"></p><p>最早在1920s报道</p><p>1937年 Meyer Neldel用于描述无序材料中的传导过程</p><p>1990s，化学家们把这种动力学上的关系转换到热力学上</p><p>一个单位转换表</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230619212011552.png" alt="image-20230619212011552"></p><ol start="2"><li>化学家们认为这种规则由熵导致，其原因在于</li></ol><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230819165652131.png" alt="image-20230819165652131"></p><p>在这样的Eyring 方程中，熵是自然而然存在的。只不过，现在看，这种熵是只在动力学过程中存在的</p><ol start="3"><li><p>&#x3D;&#x3D;多激发熵的存在必然会导致热力学上活化能的含义的变化，并且导致了活化能数值的改变&#x3D;&#x3D;</p></li><li><p>&#x3D;&#x3D;存在熵变、焓变为负数的情况&#x3D;&#x3D;</p></li><li><p>在离子扩散的数据中，高的活化能更能表现出MNR rule</p></li><li><p>figure 7 有些异常</p></li><li><p>MNR的存在是十分广泛的，并不局限在离子跳跃的过程中（必要条件是由热激发的）</p></li><li><p>利用场效应可以在单个半导体样品中观察到补偿效应。通过改变压力，也可以在单个材料中观察到补偿效应。在地质学中存在作用</p></li><li><p>出现MNR的条件在于活化能相比系统和温度的激发足够大</p></li><li><p>对于这一规律的真实性存在一些争议，本文通过理论认为MNR必然存在</p></li></ol><h3 id="section-5-核心"><a href="#section-5-核心" class="headerlink" title="section 5(核心)"></a>section 5(核心)</h3><h4 id="5-1-各种表象模型"><a href="#5-1-各种表象模型" class="headerlink" title="5.1 各种表象模型"></a>5.1 各种表象模型</h4><ol><li><p>&#x3D;&#x3D;如果能垒$\Delta E$ 比$hw&#x2F;2\pi$和$k_BT $都大很多，那么需要许多激发的组合才能使得跨越势垒的事件发生&#x3D;&#x3D;</p></li><li><p>当需要大量的激发组合来克服势垒时，有很多种组合的方式</p><blockquote><p> 这取决于单个激发的大小和势垒的大小，&#x3D;&#x3D;单个激发越小，势垒越大，那熵越大&#x3D;&#x3D;</p><p>对应到晶格振动中，如果对于相同的势垒，单个激发越小， 那么熵越大，</p><p>$\Delta G$ 越小，那么单个激发越小的一类材料，越有利于扩散</p><p>&#x3D;&#x3D;这样可以用来对比不同结构原型的材料，这很重要&#x3D;&#x3D;</p></blockquote></li><li><p>&#x3D;&#x3D;MEE(多激发熵、活化熵)导致当活化能增加时，并不会导致活化过程的概率必然降低&#x3D;&#x3D;</p></li><li><p>机械模型</p><ol><li>1949 指前因子与空位熵相关</li><li>1950 $T_{iso}$对应一个局部融化或者局部无序的温度</li><li>多激发熵的概念使得MNR规则摆脱了对结构细节的依赖敏感性，而变成一个通用的模型</li><li>1949年的空位熵模型也说明活化熵与系统的基本性质相关，系统的基本性质会导致不同的活化熵，因此获得活化熵只需要考虑系统的基本性质</li></ol></li><li><ol><li>1957 激发熵与&#x3D;&#x3D;活化体积&#x3D;&#x3D;的关系（压力）</li></ol><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230820122623051.png" alt="image-20230820122623051"></p><blockquote><p>$\alpha_p$ : 体积膨胀等压系数</p><p>$\beta$ : 等温压缩率</p></blockquote><ol start="2"><li><p>1958 活化体积与活化能（$\Delta H$ )的关系 （现象学公式）</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230820123121674.png" alt="image-20230820123121674"> </p><blockquote><p>k ：一个常数</p></blockquote></li><li><p>1960  <img src="/./../%E5%9B%BE%E7%89%87/image-20230820123216494.png" alt="image-20230820123216494"></p></li></ol></li><li><p>还有一些不以熵为基础的讨论模型</p></li></ol><h4 id="5-2-多激发熵模型"><a href="#5-2-多激发熵模型" class="headerlink" title="5.2 多激发熵模型"></a>5.2 多激发熵模型</h4><ol><li><p>1960 年 ，Miller-Abrahams近似指出低能的过程的发生依赖于所需能量大小的声子的湮灭，其中低能的声子没有作用，高能的声子湮灭的概率随能量呈指数下降</p><p>低能过程中，Miller–Abrahams (1960) approximation 成立，即需要通过声子湮灭来促使过程发生。但是当所需能量要高于声子的能量时，就无法通过单个声子湮灭实现了（声子湮灭的含义，为了发生需要减小振幅？）</p><p>&#x3D;&#x3D;1974年 ， Mott  $T^{1&#x2F;4}$  规则对于低温下无序材料的跳跃适用&#x3D;&#x3D;</p><p>&#x3D;&#x3D;1982 n个声子的组合方式包含在激发态的态密度&#x3D;&#x3D;</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230821143837475.png" alt="image-20230821143837475"></p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230821143859933.png" alt="image-20230821143859933"></p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230821143912580.png" alt="image-20230821143912580"></p><p>1983 Khait short-lived large energy fluctuations </p><p>1987 化学上同样提出指前因子的变化来源于多个激发的组合</p><p>1990 本文作者 熵的概念</p></li><li><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230821145520660.png" alt="image-20230821145520660"></p><blockquote><p>其中n指的是需要穿越势垒所需要的激发的数量 </p><p>hw是激发的平均能量</p></blockquote><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230821145814028.png" alt="image-20230821145814028"></p><blockquote><p>玻尔兹曼熵，后面一项是方案数量</p></blockquote><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230821145947626.png" alt="image-20230821145947626"></p><blockquote><p>满足限定条件下，使用stirling近似得到式子</p><p>&#x3D;&#x3D;这里有疑问，怎么推也推不过去&#x3D;&#x3D;</p></blockquote></li><li><p>1996 已经预言和观测到关联的运动</p><p>1982  熵项可以精确得到</p></li></ol><h4 id="5-3-适用范围"><a href="#5-3-适用范围" class="headerlink" title="5.3 适用范围"></a>5.3 适用范围</h4><ol><li>活化能要足够大于激发的能量和$k_BT$</li></ol><h4 id="5-4-过渡态理论和长程的电子输运"><a href="#5-4-过渡态理论和长程的电子输运" class="headerlink" title="5.4 过渡态理论和长程的电子输运"></a>5.4 过渡态理论和长程的电子输运</h4><h3 id="section-6"><a href="#section-6" class="headerlink" title="section 6"></a>section 6</h3><p><strong>关于补偿关系的其他理论解释-与熵无关</strong></p><ol><li><p>费米能移动的理论</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230831164544200.png" alt="image-20230831164544200"></p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230831164554964.png" alt="image-20230831164554964"></p></li></ol><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230831164603864.png" alt="image-20230831164603864"></p><ol start="2"><li>活化能的e指数分布带来MNR</li><li>竞争过程</li></ol><h3 id="section-7"><a href="#section-7" class="headerlink" title="section 7"></a>section 7</h3><p><strong>活化熵&#x2F;多激发熵模型的证据</strong></p><ol><li>分子动力学模拟FCC金属表面的扩散，并不存在dos或者e指数分布，但是MNR规则自然而然地出现，后续计算认为必定是由于MEE模型</li></ol><h3 id="section-8"><a href="#section-8" class="headerlink" title="section 8"></a>section 8</h3><p><strong>关于活化能较低的情况下MNR仍然成立但是MEE model无法解释</strong></p><ol><li>在活化能比较小的情况下，MNR规则并不成立？ </li><li>作者认为只有在高的活化能之下才能观察到MNR，在低活化能下无法观察到MNR规则的存在</li></ol><h3 id="section-9"><a href="#section-9" class="headerlink" title="section 9"></a>section 9</h3><p><strong>活化熵带来的结果</strong></p><ol><li><p>多一个指数因子项，不同的理论解释这一指数因子的来源是不同的</p></li><li><p>当存在一个大的活化能时，会影响载流子在不同能级上的分布，分布会增加一个指数项</p></li><li><p>当考虑到单粒子的态密度的分布时，如果存在较大的活化能，那么活化熵的指数因子和态密度的指数分布是相同的含义</p></li></ol><h3 id="section-10"><a href="#section-10" class="headerlink" title="section 10"></a>section 10</h3><p><strong>激发的总熵</strong></p><h4 id="10-1-高于等速温度的系统的行为"><a href="#10-1-高于等速温度的系统的行为" class="headerlink" title="10.1 高于等速温度的系统的行为"></a>10.1 高于等速温度的系统的行为</h4><ol><li><p>弱耦合下，在靠近$T_{iso}$的区域MNR失效</p><p>强耦合下</p></li></ol><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230915160306025.png" alt="image-20230915160306025"></p><p>​      只有当$\Delta S_B$   （系统本身的熵为负数时，才会发生阿伦尼乌斯曲线相交于$T_{iso}$的情况，因为</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230915160652712.png" alt="image-20230915160652712"></p><p>​       如果大于0，就不存在活化能$\Delta G$了</p><p>​       低耦合常数对应大的$T_{iso}$  大耦合常数对应小的</p><h2 id="5-高压中发现的反常现象-日本人的讲座中关于反钙钛矿的研究"><a href="#5-高压中发现的反常现象-日本人的讲座中关于反钙钛矿的研究" class="headerlink" title="5.高压中发现的反常现象&#x2F;日本人的讲座中关于反钙钛矿的研究"></a>5.高压中发现的反常现象&#x2F;日本人的讲座中关于反钙钛矿的研究</h2><p>随着压力升高活化能反而降低</p><blockquote><p>Superionic iron oxide–hydroxide in Earth’s deep  mantle</p></blockquote><h1 id="4-晶格动力学与超离子导体"><a href="#4-晶格动力学与超离子导体" class="headerlink" title="4. 晶格动力学与超离子导体"></a>4. 晶格动力学与超离子导体</h1><h2 id="1-晶格振动与键极性的关系"><a href="#1-晶格振动与键极性的关系" class="headerlink" title="1.晶格振动与键极性的关系"></a>1.晶格振动与键极性的关系</h2><blockquote><p>Lattice Dynamics and Bond Polarity of Be-Chalcogenides A New Class of II±VI Materials</p></blockquote><h2 id="2-快离子导体的低热导率与离子电导率的关系—非谐"><a href="#2-快离子导体的低热导率与离子电导率的关系—非谐" class="headerlink" title="2. 快离子导体的低热导率与离子电导率的关系—非谐"></a>2. 快离子导体的低热导率与离子电导率的关系—非谐</h2><blockquote><p>Extreme phonon anharmonicity underpins superionic diffusion and ultralow thermal conductivity in argyrodite Ag8SnSe6</p></blockquote><ol><li>超离子材料通常具有较低的热导率</li><li>和其他的超离子中声子的作用有什么不同，是递进关系吗，还是平行的</li><li>给结构的设计能带来什么样的启示呢，同结构的什么特征相关</li></ol><h2 id="3-综述：晶格动力学角度的超离子导体"><a href="#3-综述：晶格动力学角度的超离子导体" class="headerlink" title="3. 综述：晶格动力学角度的超离子导体"></a>3. 综述：晶格动力学角度的超离子导体</h2><blockquote><p>Phonon–Ion Interactions: Designing Ion Mobility Based on Lattice Dynamics</p></blockquote><hr><ul><li><p>考察超离子导体中的晶格振动，可以有不同的视角</p><ul><li>把所有的原子的振动当作一个整体来考</li><li>把超离子导体中的原子分为两个部分，一个是移动的离子，一个是其他原子组成的结构框架，其中移动的离子和刚性的框架是强耦合的</li></ul></li><li><p>对于超离子导体中的晶格振动的描述，依附在特定的结构框架上，同一晶格框架中，晶格振动应该有相似性，具有相似高电导率的不同晶格框架，其晶格振动也应该存在相似性。晶格振动应该是描述离子运动的根本特征</p><p>与之对应的是化学中的鲍林规则等对多面体晶体结构的结构描述</p></li><li><p>晶格振动的整体所有分支或特定分支的作用的考虑是不同的，需要把特定的分支与晶体的特定结构结合</p></li></ul><hr><p>超离子导体的应用：引文4-8</p><ul><li>理论上可以对一个静态的结构构建出一个二维的能量山峰图</li></ul><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230918151013994.png" alt="image-20230918151013994"></p><p>​          这里的z值中包括了关联离子跃迁的Haven ratio系数等</p><ul><li><img src="/./../%E5%9B%BE%E7%89%87/image-20230918151154441.png" alt="image-20230918151154441"></li></ul><p>​        增加阴离子的极化能够增加晶格的软度，增加离子电导率，从化学的角度也可以理解，软硬酸碱理论告诉我们，与锂离子这种硬离子成键的离子越软，成键越不稳定，应该是更利于运动</p><p>​        对于与软离子成键的软离子（共价键）其成键是稳定的，这类材料的晶格是什么样的，软还是硬？</p><ul><li><p>爱因斯坦关系</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230918151831254.png" alt="image-20230918151831254"></p></li></ul><p>​         振幅与振动频率的关系</p><ul><li><p>晶格极化与超离子导体</p><ul><li>晶格中离子的跳跃必然是一个非谐的事件，极化在非谐中起到作用。极化和非谐是什么关系？非谐的来源与物理图像是什么？</li><li>硫比氧的半径更大，电荷的空间分布更广，极化性更强。软硬酸碱理论-电负性理论-键的极性都是相似的</li></ul></li><li><p>软晶格和低活化能  德拜频率</p><ul><li><img src="/./../%E5%9B%BE%E7%89%87/image-20230918153020516.png" alt="image-20230918153020516"></li><li>尝试频率的含义的不同观点：1.特定的声子振动模 2. 德拜频率  </li><li>谐振子的结合强度越大，振动频率越高，成键越强。</li></ul></li><li><p>特定的声子频率与活化能</p><ul><li>德拜频率完全忽视了材料的光学声子模</li><li>声学支、光学支与物理结构的具体关联图像，振动不同支之间的关联。</li><li>活化能与低频光学支也存在关联</li></ul></li><li><p>平均声子频率和声子带心</p><ul><li>考察的是晶格的整体的振动特征以及移动的离子的单独的振动特征</li><li>降低振动的频率能够促进超离子态的产生</li></ul></li><li><p>晶格的旋转模-Paddle Wheel 机制</p></li><li><p>作者支持解释MNR的MEE模型</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230918154311261.png" alt="image-20230918154311261"></p><p>尝试频率的改变不足以解释在改变晶格极化时指前因子几个数量级的变化，因为尝试频率只在一个数量级内改变，而指前因子改变了三个数量级</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230918154527580.png" alt="image-20230918154527580"></p><p>   硫化物的$\delta_0$值要高于氧化物，也就是说T_MN要低于氧化物，那么氧化物降低晶格的硬度能够获得更高的离子电导率的收益</p></li><li><p>对一个结构构型，晶格到底最多可以软化到什么程度还保持稳定，应该是晶格动力学决定的？</p></li><li><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230918154902794.png" alt="image-20230918154902794"></p><p> 很明显，极化性更强的阴离子具有更低的振动频率，这也可以理解</p></li><li><p>作者认为，热电的研究中包含许多对非谐效应的理解，可以从中借鉴得到基本的概念</p></li></ul><h2 id="4-非谐阳离子与阴离子耦合在硫化物固态电解质中的作用"><a href="#4-非谐阳离子与阴离子耦合在硫化物固态电解质中的作用" class="headerlink" title="4. 非谐阳离子与阴离子耦合在硫化物固态电解质中的作用"></a>4. 非谐阳离子与阴离子耦合在硫化物固态电解质中的作用</h2><blockquote><p>Anharmonic Cation–Anion Coupling Dynamics Assisted<br>Lithium-Ion Diffusion in Sulfide Solid Electrolytes</p></blockquote><ul><li>对论文引言的翻译，引言写的很全面</li></ul><blockquote><p>离子电导率是最重要的性能指标之一，深入了解现有电解质中快速离子传输的物理起源是进一步设计先进超离子导体的关键。之前的开创性工作主要集中在三个方面来帮助理解Li(或Na)在这些材料中的扩散机制:&#x3D;&#x3D;晶体结构或静态力学性能，[6-8]协同阳离子扩散，[9,10]和离子晶格相互作用动力学。[11 - 22]对于离子-晶格相互作用，分别讨论了桨轮效应[13 - 15,22]、软声子相关效应[11,17,21]和非谐效应&#x3D;&#x3D;[16,23,24]。</p><p>1972年，有人提出了一个模型，将α-Li2SO4[25]中Li离子的高离子电导率与α-Li2SO4中聚阴离子的旋转无序性在≈635 ~ 790℃的温度范围内联系起来。该模型提出，四面体SO4 2−聚阴离子的旋转可以拓宽锂离子跳跃的扩散途径，最终提高锂离子的电导率，这也被称为“桨轮”机制。[26,27]随后用中子衍射实验在650℃下观察了SO4 2−聚阴离子的旋转行为[28] 虽然在高或中温范围内具有快速碱金属离子传导的其他硫酸盐和硼氢化物相中也报道了类似的效应，如LiNaSO4， [29] LiAgSO4， [29] LiBH4， [30] Li2B12H12，[31]和Na2B12H12，[31,32]，实际上，关于这种影响，特别是硫酸盐的影响，有过激烈的辩论，[33-36]部分原因是在原子尺度上直接观察这种超快动态效应在实验和计算上都具有挑战性。例如，从头算分子动力学(ab initio molecular dynamics, AIMD)模拟虽然在模拟中观察到聚阴离子的旋转，但无法同时找到足够多的Li跳变事件与SO4旋转事件良好相关。[36]同时，这篇工作还讨论了Li2SO4中除聚阴离子旋转外晶格动力学的复杂性，并指出了非弹性中子衍射对进一步研究的重要性。</p><p>此外，最近对硫化物电解质中桨轮现象的研究大多是在具有大自由体积的多阴离子旋转的高温晶相中，如Li3.25P0.75Si0.25S4[14]和Na3PS4[22]，尽管有一篇报道在室温下对玻璃0.75Li2S-0.25P2S5[13]有影响。此外，虽然x射线和中子衍射等实验可以检测到聚阴离子旋转的存在，但旋转与锂离子跳变事件的直接关联更具挑战性，往往不得不求助于AIMD。我们注意到，在讨论桨轮效应时，Li3.25P0.75Si0.25S4[14]的AIMD结果在&gt;600 K, Na11Sn2PX12 (X &#x3D; S和Se)[15]的AIMD结果在&gt;500K。对于这些超离子导体的结晶相，高温相中原子的大自由体积和&#x2F;或大动能可能使旋转突出。然而，在该领域广泛讨论的是，外推高温计算来预测室温行为可能会导致问题。[37]虽然对于某些类型的材料，聚阴离子的旋转可以持续到低温(≈0-300 K)，但[14,15]，在这个低温范围内，旋转是否有助于锂离子的扩散，这一研究较少，与固态电池的应用更相关。换句话说，利用室温附近的效应仍然是一个巨大的挑战</p><p>另一方面，近年来的一些研究强调软声子对活化能势垒和阳离子传导的影响，主要是基于低温(≈0-300 K)的测量和计算。较软的晶格动力学或较高的晶格极化率使得锂声子中心态密度(DOS)的频率较低，这与li3po4基LISICON、Li6PS5X (X &#x3D; Cl, Br, I)基银柱石和Na3PS4 - xSex家族中较小的活化能垒和较高的锂离子电导率有很好的相关性。[11,17 - 19,21]值得注意的是，据我们所知，还没有发现基于桨轮效应的这种依赖于物质的描述符。在Meyer-Neldel规则范围内进一步讨论了软声子效应[12,19,21]，[38]强调了熵和晶格振动谱对离子扩散的重要性和复杂性。特别是，软声子增加了阳离子振荡幅度以获得更高的跳变概率[11,18,39]，同时软晶格也降低了跳变事件的振荡频率和尝试频率。[17,21]与这种复杂的权衡效应相关，一项研究还表明，在研究了更广泛的电解质家族之后，描述符应该用于结构和化学上相似的导体。[12]例如，虽然硫化物通常比卤化物表现出更好的离子电导率，&#x3D;&#x3D;但发现硫化物通常也比卤化物表现出更高的锂声子带中心频率&#x3D;&#x3D;</p><p>虽然晶体的非谐通常被认为等同于晶格的柔软性，但它们强调的是不同的方面。特别是，非谐波声子耦合效应可以在较宽的频率范围内耦合不同的模式，如最近在铜超导体的强相关晶体材料中讨论的那样。[40-42]对于超离子导体，Delaire等人最近强调了非调和声子效应对Cu离子、[24]Ag离子、[23]和Na离子[16]电解质中离子和热传导的重要性，在室温和低温下通过非弹性中子散射测量观察到几meV的低频宽峰，这归因于阳离子(即Cu、Ag或Na离子)的复杂运动。对于Na3PS4[16]，他们的AIMD模拟提出了Na离子扩散与PS4单元旋转以外的其他运动耦合的可能性，因为他们发现PS4的冻结旋转对计算的Na声子DOS影响很小，而冻结PS4的所有运动确实对DOS有显著的变化。此外，在这些非旋转运动中，特别提到了PS4的一类低频摆动运动。</p><p>在这项工作中，借用最近开发的用于计算强相关材料中的非调和耦合效应的从头计算方法[40,41]，我们能够直接研究超离子导体在0 K时的所有非谐声子耦合，这使我们能够首次阐明这些电解质材料中的模式耦合类型。进一步结合AIMD对离子电导率和300 K下振动声子DOS (VDOS)的评估，我们得到了与这些材料在固态电池中的实际应用更相关的温度范围的理解。我们揭示了几种具有代表性的硫化物和卤化物固体电解质中非谐波声子与锂离子电导的关系，包括Li7P3S11, Li10GeP2S12， β-Li3PS4, Li3YBr6(空间群:C2&#x2F;c)和Li3ErCl6(空间群:P321)。具体来说，我们发现对于硫化物基锂超离子导体，&#x3D;&#x3D;Li扩散的活化能势垒越小，往往与Li VDOS在与高频阴离子拉伸或弯曲模式的非谐波耦合驱动下更多地向低频振动方向重新分布有关，而不是低频旋转模式&#x3D;&#x3D;。通过这种非谐波声子耦合，Li离子被向扩散通道移动的模式推动，以减少扩散屏障。相比之下，在我们评估的卤化物电解质中，这种再分配在很大程度上是向高频和低频方向对称的。沿着这一方向的进一步了解可能为设计用于固态电池的具有更高碱性离子电导率的超离子导体提供新的途径。</p></blockquote><ul><li>低频的离子运动倾向于穿过瓶颈，而高频的离子声子倾向于沿着边或角，不贡献扩散，这是可以理解的。能够快速跳跃的一个前提是包围离子的多面体内有足够大的空间，才有利于低频的振动 &#x3D;&#x3D;和晶体的晶格特征联系起来了&#x3D;&#x3D;</li><li>卤化物与硫化物之间的区别，在于阴阳离子耦合给硫化物的低频方向提供更多模式，低频Li与高频阴离子的耦合也更加大，相比之下，卤化物耦合后低频与高频增加的模式数相当，且高频锂振动与低频阴离子旋转振动耦合更强，因此卤化物的势垒更高。</li><li>低频的阴离子旋转是有害的，而不是有利的</li><li>要提高离子扩散，应该增加高频的阴离子拉伸，而不是低频的阴离子旋转</li></ul><h2 id="5-非谐-声子声子相互作用-阻尼振动"><a href="#5-非谐-声子声子相互作用-阻尼振动" class="headerlink" title="5. 非谐-声子声子相互作用-阻尼振动"></a>5. 非谐-声子声子相互作用-阻尼振动</h2><h1 id="5-软硬酸碱理论-键极性和电负性"><a href="#5-软硬酸碱理论-键极性和电负性" class="headerlink" title="5. 软硬酸碱理论&#x2F;键极性和电负性"></a>5. 软硬酸碱理论&#x2F;键极性和电负性</h1><blockquote><p>Correlation among electronegativity, cation polarizability, optical basicity and single bond strength of simple oxides</p></blockquote><blockquote><p>软硬酸碱理论经验规则的原因探讨</p></blockquote><p>软酸软碱理论：体积小，正电荷数高，可极化性低的中心原子称作硬酸 反之，称之为软酸；碱性有相同的定义</p><p>其中，软酸和软碱的结合比较强，硬酸和硬碱的结合比较强，导致稳定性比较强</p><p>&#x3D;&#x3D;软硬酸碱理论的物理根源是什么？？&#x3D;&#x3D;</p><p>电子对的受授来定义酸和碱，将电子对的受体定义为酸(Lewis酸)，而将电子对的给体定义为碱(Lewis碱)</p><p>该理论定义电荷密度高、半径小的物质，即离子势大的物质为“硬”，而将电荷密度低、半径大的、也就是离子势小的物质定义为“软”</p><p>分子的LUMO轨道的能量外在表现为电子亲和能，而分子的HOMO轨道的能量以电离能方式呈现。同时，如果电子发生了完全转移，轨道间的电子得失也能够与物质的氧化、还原能力相关联。硬酸的特点是带正电荷多、半径小，其被原子核吸引较强，LUMO的能量相对较高，软酸由于正电荷小、半径大，较弱的原子核吸引导致其LUMO轨道的能量则相对较低；硬碱持有价电子的能<br>力强、半径小，故而其HOMO上的电子更稳定、能量低，软碱的HOMO上的电子稳定性较低、能量则较高。当硬酸与硬碱之间发生相互作用是，由于硬酸LUMO的能量远高于硬碱HOMO的能量，相互作用轨道的较大能级差导致它们间相互作用的结果主要是形成离子键(图1A)；软酸LUMO的能量与软碱HOMO的能量相对接近，它们间的作用更容易导致共价键的形成(图1B)。</p><p><a href="https://www.zhihu.com/question/38390728/answer/76221290">(18 封私信 &#x2F; 66 条消息) 怎样理解化学中的「软亲软，硬亲硬」规则？ - 知乎 (zhihu.com)</a></p><p>高压会把离子变得更硬还是更软</p><h1 id="6-化学预压缩与实际压缩的关系"><a href="#6-化学预压缩与实际压缩的关系" class="headerlink" title="6.化学预压缩与实际压缩的关系"></a>6.化学预压缩与实际压缩的关系</h1><blockquote><p>替换除了带来压缩外，还有什么别的效应，虽然替换后体积都是减小的，但是除了减小体积，离子本身的重量在增加，导致晶格振动并不会因为压缩而变得更大，但是通道内的宽度、离子极化性确实是有变化的。</p><p>压缩带来的更本质的变化是什么嘞</p><p>温度带来的体积膨胀效应、化学压缩、和加压，带来的体积变化，三者是否相通</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>分子动力学理解及可利用的计算</title>
    <link href="http://example.com/2024/05/25/%E5%88%86%E5%AD%90%E5%8A%A8%E5%8A%9B%E5%AD%A6%E7%90%86%E8%A7%A3%E5%8F%8A%E5%8F%AF%E5%88%A9%E7%94%A8%E7%9A%84%E8%AE%A1%E7%AE%97/"/>
    <id>http://example.com/2024/05/25/%E5%88%86%E5%AD%90%E5%8A%A8%E5%8A%9B%E5%AD%A6%E7%90%86%E8%A7%A3%E5%8F%8A%E5%8F%AF%E5%88%A9%E7%94%A8%E7%9A%84%E8%AE%A1%E7%AE%97/</id>
    <published>2024-05-25T14:01:20.369Z</published>
    <updated>2024-05-25T12:00:48.657Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="1-分子动力学本身的理论"><a href="#1-分子动力学本身的理论" class="headerlink" title="1.分子动力学本身的理论"></a>1.分子动力学本身的理论</h1><h2 id="1-关于温度波动与smass值"><a href="#1-关于温度波动与smass值" class="headerlink" title="1. 关于温度波动与smass值"></a>1. 关于温度波动与smass值</h2><blockquote><p><strong><a href="http://staff.ustc.edu.cn/~zqj/posts/NVT-MD/">http://staff.ustc.edu.cn/~zqj/posts/NVT-MD/</a></strong></p></blockquote><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230531161007404.png" alt="image-20230531161007404"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230710142226751.png" alt="image-20230710142226751"></p><h1 id="2-理论理解"><a href="#2-理论理解" class="headerlink" title="2. 理论理解"></a>2. 理论理解</h1><p>参考文献：</p><p> <a href="https://mp.weixin.qq.com/s?__biz=MzkyODI1MDkzMQ==&mid=2247483732&idx=1&sn=dcf54d4949081f3f373e83e94e41926c&chksm=c21aec08f56d651ea88b5bbc7b88dc871d0bea4a4c76a1b54229715ef318512810915d921b62&scene=21#wechat_redirect">第一性原理计算能量，我们忽略了什么？ (qq.com)</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzkyODI1MDkzMQ==&mid=2247483745&idx=1&sn=6d778b432d19423188077b703dd2dca1&chksm=c21aec3df56d652bc30408adaed234b6d1cc0bc7c23bfc816251ab5775cbbb999b6c8ab76cdb&scene=21#wechat_redirect">声子零点振动能（ZPE）和吉布斯自由能的理论推导及VASP计算实操（一） (qq.com)</a></p><h2 id="1-能量的区分"><a href="#1-能量的区分" class="headerlink" title="1.能量的区分"></a>1.能量的区分</h2><blockquote><p><a href="https://mp.weixin.qq.com/s/wg2cKE9KDRvCXM4f-1RrtA">https://mp.weixin.qq.com/s/wg2cKE9KDRvCXM4f-1RrtA</a></p></blockquote><ol><li>能量分为体系的内能U、焓H、吉布斯自由能G</li></ol><p>其中</p><p>$G&#x3D;U+PV-TS$</p><p>$H&#x3D;U+PV$</p><ol start="2"><li><p>内能等于</p><p>$U&#x3D;E_{electron}+ZPE$</p><blockquote><p>其中，E_electron是电子总能，ZPE是声子的零点振动能</p><p>&#x3D;&#x3D;vasp中，使用grep withoutentropy OUTCAR得到的能量就只是电子总能&#x3D;&#x3D;</p><p>因为第一性原理计算没有温度，所以不包括体系的动能项</p></blockquote><p>零点振动能对于较轻元素的体系（H He Li)的体系需要考虑，对于较重的元素，ZPE远远小于E_electron，通常不考虑</p></li><li><p>讨论吉布斯自由能</p><p>吉布斯自由能中有熵</p><p>$S&#x3D;S_k+S_{vib}+S_{elec}$</p></li></ol><p>其中S_k是构型熵，S_vib是振动熵（一般温度下贡献较小，第一性原理计算中未考虑），S_elec是电子熵</p><h2 id="2-声子振动能和振动熵、零点振动能"><a href="#2-声子振动能和振动熵、零点振动能" class="headerlink" title="2. 声子振动能和振动熵、零点振动能"></a>2. 声子振动能和振动熵、零点振动能</h2><blockquote><p><a href="https://mp.weixin.qq.com/s/Eq9Iug3tnkCy5eFXaBLAFQ">https://mp.weixin.qq.com/s/Eq9Iug3tnkCy5eFXaBLAFQ</a></p></blockquote><blockquote><p>声子作为准粒子来看，借助玻尔兹曼分布和准粒子的概念</p></blockquote><ol><li><p>一个材料体系，可以看作是由声子和电子组成，材料体系的总能是电子总能与声子总能之和</p><p>电子总能包括电子间相互作用能，原子核对电子的作用，范德华相互作用（均包括在grep without OUTCAR）中，和电子熵对总能的贡献（未包括）</p><p>第一性原理计算不能包括振动的能量</p><p>声子总能包括声子内能（振动能）和振动熵的贡献，零点振动能是声子总能的一部分（从下面的推导中可见）。第一性原理计算通常只能计算出声子的本征振动模（振动频率），而声子的ZPE和吉布斯自由能需要结合统计力学处理得到。</p></li><li><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230529093355268.png" alt="image-20230529093355268"></p></li></ol><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230529093446648.png" alt="image-20230529093446648"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230529093557533.png" alt="image-20230529093557533"></p><h2 id="3-vasp计算声子振动能和振动熵"><a href="#3-vasp计算声子振动能和振动熵" class="headerlink" title="3.vasp计算声子振动能和振动熵"></a>3.vasp计算声子振动能和振动熵</h2><blockquote><p>vasp可以直接计算出材料的振动熵</p><p><a href="https://mp.weixin.qq.com/s/2uJtj6wEKAAqYwAMgvTi1A">https://mp.weixin.qq.com/s/2uJtj6wEKAAqYwAMgvTi1A</a></p></blockquote><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230529094334669.png" alt="image-20230529094334669"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230529094401003.png" alt="image-20230529094401003"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230529094511167.png" alt="image-20230529094511167"></p><h2 id="4-构型熵的计算"><a href="#4-构型熵的计算" class="headerlink" title="4. 构型熵的计算"></a>4. 构型熵的计算</h2><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230529094748544.png" alt="image-20230529094748544"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230529094820635.png" alt="image-20230529094820635"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230529094857420.png" alt="image-20230529094857420"></p><h1 id="3-可以利用的计算"><a href="#3-可以利用的计算" class="headerlink" title="3.可以利用的计算"></a>3.可以利用的计算</h1><h2 id="1-振动熵"><a href="#1-振动熵" class="headerlink" title="1. 振动熵"></a>1. 振动熵</h2><blockquote><p>Influence of Lattice Dynamics on Na+ Transport in the Solid Electrolyte Na3PS4−xSex</p><p>How Chemical Composition Alone Can Predict Vibrational Free Energies and Entropies of Solids</p></blockquote><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230529085044405.png" alt="image-20230529085044405"></p><h2 id="2-声子带心（phonon-band-center-标识平均振动频率"><a href="#2-声子带心（phonon-band-center-标识平均振动频率" class="headerlink" title="2.声子带心（phonon band center) (标识平均振动频率)"></a>2.声子带心（phonon band center) (标识平均振动频率)</h2><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230529085819657.png" alt="image-20230529085819657"></p><h2 id="3-配分声子DOS和总声子DOS-速度自关联函数的的傅里叶变换"><a href="#3-配分声子DOS和总声子DOS-速度自关联函数的的傅里叶变换" class="headerlink" title="3. 配分声子DOS和总声子DOS -速度自关联函数的的傅里叶变换"></a>3. 配分声子DOS和总声子DOS -速度自关联函数的的傅里叶变换</h2><blockquote><p>Extreme phonon anharmonicity underpins superionic diffusion and ultralow thermal conductivity in argyrodite Ag8SnSe6</p></blockquote><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230529090207571.png" alt="image-20230529090207571"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;1-分子动力学本身的理论&quot;&gt;&lt;a href=&quot;#1-分子动力学本身的理论&quot; class=&quot;headerlink&quot; title=&quot;1.分子动力学本身的理论&quot;&gt;&lt;/a&gt;1.分子动力学本身的理论&lt;/h1&gt;&lt;h2 id=&quot;1-关于温度波动与sma</summary>
      
    
    
    
    <category term="分子动力学" scheme="http://example.com/categories/%E5%88%86%E5%AD%90%E5%8A%A8%E5%8A%9B%E5%AD%A6/"/>
    
    <category term="分析方法" scheme="http://example.com/categories/%E5%88%86%E5%AD%90%E5%8A%A8%E5%8A%9B%E5%AD%A6/%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>关于钙钛矿结构</title>
    <link href="http://example.com/2024/05/25/%E5%85%B3%E4%BA%8E%E9%92%99%E9%92%9B%E7%9F%BF%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2024/05/25/%E5%85%B3%E4%BA%8E%E9%92%99%E9%92%9B%E7%9F%BF%E7%BB%93%E6%9E%84/</id>
    <published>2024-05-25T14:01:20.368Z</published>
    <updated>2024-05-24T11:51:00.181Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/./../%E5%9B%BE%E7%89%87/image-20230706105442697.png" alt="image-20230706105442697"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/./../%E5%9B%BE%E7%89%87/image-20230706105442697.png&quot; alt=&quot;image-20230706105442697&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="文章阅读" scheme="http://example.com/categories/%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>VDOS and band center</title>
    <link href="http://example.com/2024/05/25/VDOS%20and%20band%20center/"/>
    <id>http://example.com/2024/05/25/VDOS%20and%20band%20center/</id>
    <published>2024-05-25T14:01:20.366Z</published>
    <updated>2024-05-25T12:00:58.765Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h1><blockquote><p>VDOS : vibrational density of states , 定义了单位振动模式范围内的模式数量</p></blockquote><blockquote><p>band center :定义了平均振动模式的强度</p><p>来源：Accurate description of ion migration in solid-state ion conductors from machine-learning molecular dynamics</p></blockquote><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20240513103609076.png" alt="image-20240513103609076"></p><h1 id="2-优点"><a href="#2-优点" class="headerlink" title="2.优点"></a>2.优点</h1><p>室温AIMD模拟的VDOS包括非谐和温度效应，反映了正负离子耦合动力学，通常在传统声子计算中不特别考虑非谐效应时不包括</p><h1 id="3-计算方法"><a href="#3-计算方法" class="headerlink" title="3. 计算方法"></a>3. 计算方法</h1><ol><li><p>VDOS</p><p>分子动力学中速度自相关函数的傅里叶变换</p></li></ol><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20240513103224551.png" alt="image-20240513103224551"></p><ol start="2"><li><p>band center</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20240513103302607.png" alt="image-20240513103302607"></p></li></ol><h1 id="4-应用"><a href="#4-应用" class="headerlink" title="4. 应用"></a>4. 应用</h1><ol><li>通过固定或者不限制离子振动来考虑阴阳离子耦合效应</li></ol><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20240513161744874.png" alt="image-20240513161744874"></p><p>阴阳离子耦合效应增加了低频和高频，降低了中频的模式</p><p>2. </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;1-定义&quot;&gt;&lt;a href=&quot;#1-定义&quot; class=&quot;headerlink&quot; title=&quot;1. 定义&quot;&gt;&lt;/a&gt;1. 定义&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;VDOS : vibrational density of stat</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>元素价态</title>
    <link href="http://example.com/2024/05/25/%E5%85%83%E7%B4%A0%E4%BB%B7%E6%80%81/"/>
    <id>http://example.com/2024/05/25/%E5%85%83%E7%B4%A0%E4%BB%B7%E6%80%81/</id>
    <published>2024-05-25T14:01:20.366Z</published>
    <updated>2024-05-25T12:01:03.001Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20230822111337455.png" alt="image-20230822111337455"></p><p>掺杂、替换 </p><ol><li><p>同价态掺杂、&#x3D;&#x3D;改变离子半径-改变晶体形貌-改变势垒    改变离子质量-改变晶格振动-改变跳跃几率-改变MNR&#x3D;&#x3D;</p></li><li><p>同价态替换    改变离子半径-改变晶体形貌-改变势垒    改变离子质量-改变晶格振动-改变跳跃几率-改变MNR</p></li><li><p>不同价态掺杂  &#x3D;&#x3D;改变迁移离子的浓度&#x3D;&#x3D;、改变质量、改变离子半径</p></li><li><p>电子结构角度：成键与极化、软硬酸碱</p><p>价态与配位应该与原材料相匹配，不能原来是四价4配位，改成5价六配位，可以改成5价4配位</p><p>先同价替换找单元素最高，在单元素最高基础上掺杂、替换</p><p>掺杂的比例应该控制得当，比如按照一定的数列规则</p></li></ol><blockquote><p>Si (0.26) </p><p>同价替换  找最合适的尺寸  Ti (0.42) Hf(0.58)  Zr(0.59)  Ge(0.39) Cr(0.41)  Mn(0.39)  Co(0.4)  Sn (0.55) Pb(0.65) Te(0.66)</p><p>同价掺杂   </p><p>异价掺杂  3价（增加离子浓度） Fe(0.49) B(0.11) Al(0.39) Ga(0.47) In(0.62)</p><p>​                  5价  (降低离子浓度)   V (0.46) Nb(0.48)  Cr(0.345)  Mo(0.46)  Mn(0.33)   P(0.17) As(0.335)</p></blockquote><blockquote><p>Y (3)  0.9  </p><p>同价替换 La(1.032) Ce(1.01)  Pr(0.99) Nd(0.983) Pm(0.97)Eu(0.947) Sm(0.958)Gd(0.938)Tb(0.923)   Dy(0.912) Ho(0.901)   Er (0.89) Tm(0.88)  Yb(0.868) Sc (0.745)  Lu(0.861)  Ti(0.67)  V(0.64) Nb(0.72)  Ta(0.72)  Cr(0.615)  Mo(0.69)  Mn(0.58)  Fe(0.55)  Ru(0.68)  Co(0.61)  Rh(0.665) Ir(0.68)  Ni(0.6)  Pd(0.76)  Cu(0.54)  B(0.27)  Al(0.535)  Ga(0.62) In(0.8)  N(0.16) P(0.44)  Sb(0.76) Bi(1.03) </p><p>文献中已有的实验数据，其中比Y低的元素包括 Er Lu Sc Fe Tm</p></blockquote><p><img src="/./../../%E5%9B%BE%E7%89%87/aa.jpg" alt="aa"></p><blockquote><p>同价掺杂    </p><p>异价掺杂   2价 Mg(0.72)  Ca(1) Sr(1.18)  Ba(1.35)  Ti(0.86)  V(0.79)   Cr(0.73)  Mn(0.67 0.83)  Fe(0.61 0.78)  Co(0.65 0.75)  Ni(0.69)  Pd(0.86)  Pt(0.8)  Cu(0.73)  Zn(0.74)  Cd(0.95)  Ge(0.73)  Pb(1.19) </p><p>​                   4价   Ti(0.605)  Zr(0.72)  Hf(0.71)  V(0.58) Nb(0.68)  Ta(0.68)  Cr(0.55) Mo(0.65) W(0.66)  Mn(0.53)  Re(0.63)  Fe(0.585) Ru(0.62)  Os(0.63)  Co(0.53)  Rh(0.6)  Ir(0.625)  Ni(0.48)  Pd(0.615)  Pt(0.625)  Ge(0.53) Si(0.4)  C(0.16) Sn(0.69) Pb(0.775)  S(0.37)  Se(0.5)  Te(0.97) </p></blockquote><p>&#x3D;&#x3D;要搞清楚掺杂、替换本质在做什么，改变了什么&#x3D;&#x3D;</p><p>**Si (0.26) **</p><p>&#x3D;&#x3D;<strong>同价替换 &#x2F;掺杂</strong>&#x3D;&#x3D;</p><p><strong>Ti (0.42) Hf(0.58)  Zr(0.59)  Ge(0.39) Cr(0.41)  Mn(0.39)  Co(0.4)  Sn (0.55) Pb(0.65) Te(0.66)</strong></p><p>&#x3D;&#x3D;<strong>异价掺杂</strong>&#x3D;&#x3D;   <strong>3价（增加离子浓度） Fe(0.49) B(0.11) Al(0.39) Ga(0.47) In(0.62)</strong></p><p>​                  <strong>5价  (降低离子浓度)   V (0.46) Nb(0.48)  Cr(0.345)  Mo(0.46)  Mn(0.33)   P(0.17) As(0.335)</strong></p><p>**Y  0.9  **</p><p>&#x3D;&#x3D;<strong>同价替换&#x2F;掺杂</strong>&#x3D;&#x3D;</p><p>**La(1.032) Ce(1.01)  Pr(0.99) Nd(0.983) Pm(0.97)Eu(0.947) Sm(0.958)Gd(0.938)Tb(0.923)   Dy(0.912) Ho(0.901)   Er (0.89) Tm(0.88)  Yb(0.868) Sc (0.745)  Lu(0.861)  Ti(0.67)  V(0.64) Nb(0.72)  Ta(0.72)  Cr(0.615)  Mo(0.69)  Mn(0.58)  Fe(0.55)  Ru(0.68)  Co(0.61)  Rh(0.665) Ir(0.68)  Ni(0.6)  Pd(0.76)  Cu(0.54)  B(0.27)  Al(0.535)  Ga(0.62) In(0.8)  N(0.16) P(0.44)  Sb(0.76) Bi(1.03) **</p><p>&#x3D;&#x3D;<strong>异价掺杂</strong>&#x3D;&#x3D;   **2价 Mg(0.72)  Ca(1) Sr(1.18)  Ba(1.35)  Ti(0.86)  V(0.79)   Cr(0.73)  Mn(0.67 0.83)  Fe(0.61 0.78)  Co(0.65 0.75)  Ni(0.69)  Pd(0.86)  Pt(0.8)  Cu(0.73)  Zn(0.74)  Cd(0.95)  Ge(0.73)  Pb(1.19) **</p><p>​                  <strong>4价   Ti(0.605)  Zr(0.72)  Hf(0.71)  V(0.58) Nb(0.68)  Ta(0.68)  Cr(0.55) Mo(0.65) W(0.66)  Mn(0.53)  Re(0.63)</strong>  **Fe(0.585) Ru(0.62)  Os(0.63)  Co(0.53)  Rh(0.6)  Ir(0.625)  Ni(0.48)  Pd(0.615)  Pt(0.625)  Ge(0.53) Si(0.4)  C(0.16) Sn(0.69) Pb(0.775)  S(0.37)  Se(0.5)  Te(0.97) **</p><h1 id="2-运动模式"><a href="#2-运动模式" class="headerlink" title="2.运动模式"></a>2.运动模式</h1><p>在沿着c轴方向的一个通道中，有两个稳定的位置，呈长条状</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20231009163427080.png" alt="image-20231009163427080"></p><p>长条就像是树的枝干，延伸出连接不同水平方向位置的枝条</p><p>neb的计算结果显示，在树木的同一长条内的运动更容易，但是在不同长条间的运动更加困难</p><p>沿着c轴通道的运动，需要跨过SiO4组成的不同的环，需要跨过两个正对的SiO4四面体的区域，带来大的势垒，增加Y位置的尺寸，确实会拓宽通道</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20231009165744856.png" alt="image-20231009165744856"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20231009170307586.png" alt="image-20231009170307586"></p><p>使用主动学习分子动力学是十分有必要的，-否则数据不够线性</p><ol start="3"><li><p>离子的运动是离不开在长条内的运动的，因为需要在不同的长条位置迁移。</p><p>针对长条中的离子扩散，降低离子的迁移势垒，目前有几种方案：</p><ol><li>拓宽空间、2. 降低Si的价态 3. 增加或者减少离子</li></ol><p>需要考察高压下的离子扩散行为，为什么会增加电导率</p></li><li><p>NEB有两种形貌，左凸型和右凸型，左凸型的通道内的势垒曲线是瀑布型，其相邻x方向的离子受到束缚更少，看上去更松散，两类离子可以运动。右凸型的通道内的势垒曲线是山峰型，相邻x方向的离子受到束缚更大，看上去更紧密，只有通道内可以运动</p><p>左凸型</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20231024151802427.png" alt="image-20231024151802427"></p></li></ol><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20231024151820150.png" alt="image-20231024151820150"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20231024151845466.png" alt="image-20231024151845466"></p><p>右凸型</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20231024151904025.png" alt="image-20231024151904025"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20231024151920099.png" alt="image-20231024151920099"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20231024151930172.png" alt="image-20231024151930172"></p><p>右凸型</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20231024155036248.png" alt="image-20231024155036248"></p><p>左凸和右凸在结构优化之后就已经确定了，左凸的中心不对齐，右侧凸的中心对齐</p><p>左凸起的结构的八面体起伏更大，原子共线更差，右凸起的结构原子共线更好</p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20231024164534314.png" alt="image-20231024164534314"></p><p><img src="/./../../%E5%9B%BE%E7%89%87/image-20231024164556175.png" alt="image-20231024164556175"></p><p>和元素种类相关？和半径或者化合价相关？</p><p>可能水平面内的运动依赖于非共线的形成，</p><p>4.周边位置的Na的作用很明显，瀑布型的能垒曲线的末态周边原子已经占领了中心通道的位置</p><p>非晶化    确实是个很好的问题 。Na中Y的非晶化要更难、Sm的非晶化更容易、Li的非晶化容易  用结构的扭曲程度来表征非晶化的可能性</p><p>找非晶化提升离子电导率的机制、有没有其他非晶化的例子</p><p>Na为什么测出来不是直线：正常</p><p>非晶化是不是结构破坏，是的，但是还是不知道为什么非晶化之后离子电导率会增加</p><p>相比于日本小组，做出来的晶体更纯，微晶玻璃中微晶的存在会抑制电导率</p><p>总结领域内新兴的方向，做热点的方向，卤化物固态电解质</p><p>算XRD 和实验来比较，</p><p>加速分子动力学（meta)，可以加速发现相变发生的过程和非晶化的过程 ，可以给sm和Li分别做一做 </p><p>1.为什么非晶化能够提升离子电导率 </p><ol start="2"><li>有没有其他的非晶化可能的材料（硫化物、氧化物）</li></ol><p>PPT的问题：让人知道下一步要做啥，因为是新的发现</p><p>1.neb形状的起因 其他钠离子的影响</p><p>2 元素更加紧密的原因 元素</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/./../../%E5%9B%BE%E7%89%87/image-20230822111337455.png&quot; alt=&quot;image-20230822111337455&quot;&gt;&lt;/p&gt;
&lt;p&gt;掺杂、替换 &lt;/p&gt;
&lt;ol&gt;
&lt;li</summary>
      
    
    
    
    <category term="课题研究" scheme="http://example.com/categories/%E8%AF%BE%E9%A2%98%E7%A0%94%E7%A9%B6/"/>
    
    <category term="MYSiO" scheme="http://example.com/categories/%E8%AF%BE%E9%A2%98%E7%A0%94%E7%A9%B6/MYSiO/"/>
    
    
  </entry>
  
  <entry>
    <title>vasp使用教程</title>
    <link href="http://example.com/2024/05/25/vasp%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>http://example.com/2024/05/25/vasp%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</id>
    <published>2024-05-25T14:01:20.364Z</published>
    <updated>2024-05-25T12:01:05.617Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="1-计算方法、流程与输入文件"><a href="#1-计算方法、流程与输入文件" class="headerlink" title="1.计算方法、流程与输入文件"></a>1.计算方法、流程与输入文件</h1><h2 id="1-结构优化——something-new"><a href="#1-结构优化——something-new" class="headerlink" title="1.结构优化——something new"></a>1.结构优化——something new</h2><ul><li><p>使用收敛的参数不会出现优化后的结构拿去自洽后能量变化的问题，也不会有优化后的结构再拿去cp CONTCAR POSCAR后优化还可以继续优化的问题，所以归根结底是收敛的参数的问题</p><p>用于验证的目录：五洲</p></li><li><p>一次使用收敛的高精度优化和多次递进参数优化得到的能量结果是相同的，所以是两种策略，一步高精度或者多步递进</p></li><li><p>高精度和低精度优化出来的结构会有体积的变化，即高低精度优化得到的不止能量上的差别，还有结构上的差别，因此使用高精度是必要的。</p></li><li><p>ENCUT和KSPACING比较方便，ENCUT通常1.3倍ENCUT是不够的，需要加大，而KSPACING比想象中更容易收敛，用0.2即可。</p></li><li><p>一定要优化到足够的精度，力的收敛标准不要吝啬 0.001，例如，优化不到位在算不同扩胞方式下表面的能带时差别会比较大</p></li></ul><p>&#x3D;&#x3D;优化增加ENCUT!!!!&#x3D;&#x3D; 不然算出来的能量是不准确的 </p><p>&#x2F;work&#x2F;home&#x2F;xieyu&#x2F;workplace&#x2F;liz&#x2F;1K-Y-Si-O-pymatgen&#x2F;B-2&#x2F;1-opt&#x2F;1</p><p>可以在优化后做一个自洽来看下能量</p><p>一步优化往往是不对的，需要再优化一次，可能在再次优化的时候结构还会变化。</p><p>优化收敛后往往需要再优化一遍才能得到准确的结构，网格的原因，优化中的网格没有变化，重新优化会对结构产生新的网格</p><p>Q1 为什么在收敛后再优化还是能继续优化</p><p>Q2为什么自洽和优化的能量不一样</p><p>&#x3D;&#x3D;策略&#x3D;&#x3D;多步优化，分步优化  就算第一步收敛了也要再做一次优化</p><p>&#x3D;&#x3D;先粗优化后精优化不只是优化的策略，而是必须要做的事&#x3D;&#x3D;</p><p><strong>&#x3D;&#x3D;D:\4-work\1-project-PPT\M-2-软件-计算方法&#x2F;结构优化精度对比.pptx&#x3D;&#x3D;</strong></p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20240109222800271.png" alt="image-20240109222800271"></p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20240109222815206.png" alt="image-20240109222815206"></p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20240109222829651.png" alt="image-20240109222829651"></p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20240109222853989.png" alt="image-20240109222853989"></p><p>自洽判断结构能量次序的没有测，留到以后测吧！！！</p><h2 id="1-结构优化"><a href="#1-结构优化" class="headerlink" title="1.结构优化"></a>1.<span id="123">结构优化</span></h2><pre><code class="shell"> SYSTEM=Li             PREC = Accurate      NELM = 60 （#电子自洽迭代最大步数，默认为60NELMIN = 2 #电子自洽迭代最小步数，默认为2EDIFF = 1e-5 #电子自洽收敛标准，当两步总能小于该值时，电子自洽终止，默认为1e-4**NSW = 200 #原子弛豫最大步数，默认为0  EDIFFG = -0.01 #原子弛豫收敛标准，两步总能之差小于该值时，弛豫终止，设为负值时，表示力的收敛，一般负值是比较好的标准**POTIM =  0.5 #原子每步移动的距离，IBRION=1 2 3 时，默认为0.5，IBRION=0时，跑MD,需要手动输入****IBRION = 2 #不同的原子能量下降方式，-1表示不移动，2表示共轭梯度法，默认当NSW = 0或1时为-1，为其他值时是0****ISIF = 3 #结构优化哪些部分，IBRION=0时默认为0，其他默认为2****ENCUT = 600 #截断能，默认为POTCAR文件里的ENMAX   *****ISPIN =2******#SYSTEM PREC EDIFF NSW IBRION EDIFFG POTIM ENCUT ISIF ISMEAR SIGMA ISTART ICHARG)****#当NSW=0 IBRION = -1时，ISIF=2或者ISIF=3是没有差别的，并不会优化晶格常数**</code></pre><h2 id="2-测k点-直接测KSPACING"><a href="#2-测k点-直接测KSPACING" class="headerlink" title="2.测k点 &#x2F;直接测KSPACING"></a><strong>2.测k点</strong> &#x2F;直接测KSPACING</h2><pre><code class="shell">for i in 1 2 3 4 5 6 7 8 9do  for j in 1 2 3 4 5 6 7 8 9 do  for k in 1 2 3 4 5 6 7 8 9cat &gt; KPOINTS &lt;&lt;lizhaohenshuai     Automatic generation     0     Monkhorst-pack     $i $j $k     0 0 0lizhaohenshuaimpirun  -np 48 vasp路径 &gt;vasp.log 2&gt;&amp;1cp CONTCAR CONTCAR_$icp OUTCAR OUTCAR_$idone</code></pre><p>&#x3D;&#x3D;<strong>测试k点，截断能本质上是在测赝势（<code>POTCAR</code>),用自洽来保证能量算准然后再进行优化才有意义。</strong>&#x3D;&#x3D;</p><h2 id="3-ISMEAR与SIGMA"><a href="#3-ISMEAR与SIGMA" class="headerlink" title="3.ISMEAR与SIGMA"></a><strong>3.<code>ISMEAR与SIGMA</code></strong></h2><p>**<code>ISMEAR</code>  </p><ul><li><p><strong>对半导体或者绝缘体，使用<code>ISMEAR=-5</code>（一定不能用<code>&gt;0</code>),如果胞比较大（即使用的<code>K</code>点数目很小，如一两个，）使用<code>ISMEAR=0,SIGMA=0.05</code>;</strong></p></li><li><p><strong>对金属弛豫使用<code>ISMEAR=1</code>或者<code>2</code>，和一个比较好的<code>SIGMA</code>(默认为<code>0.2</code>，需要测试）</strong></p></li><li><p>&#x3D;&#x3D;<strong>对半导体和绝缘体不要用<code>ISMEAR&gt;0</code>；</strong>&#x3D;&#x3D;</p></li><li><p><strong>对于计算<code>DOS</code>,自洽（不需要弛豫时，不涉及力）时一律使用<code>ISMEAR=-5</code>；声子谱计算用<code>ISMEAR&gt;0</code>；计算能带时不同，详细见能带）</strong></p></li><li><p><strong>1.测<code>SIGMA  ISMEAR&gt;0时</code></strong></p></li></ul><pre><code class="shell">for i in 0.1 0.12 0.14 0.16 0.18 0.20 0.22 0.24 0.26 0.28 0.30   do  cat &gt; INCAR &lt;&lt; lizhaohenshuai  SYSTEM=Li  PREC = Accurate  ENCUT = 600  EDIFF = 1e-6  IBRION = 2  ISIF = 3  NSW = 200  ISMEAR = 1  SIGMA = $i  POTIM = 0.2  EDIFFG = -0.001  lizhaohenshuaimpirun -np 48 vasp路径 &gt; vasp.log 2&gt;&amp;1cp CONTCAR CONTCAR_$pcp OUTCAR OUTCAR _$pdone  </code></pre><ul><li><strong>2.提取熵值</strong></li></ul><p><strong>选择熵值最小的<code>SIGMA</code>，最高不能高于每原子大于<code>1mev</code></strong></p><hr><pre><code class="shell"> for i in 0.1 0.12 0.14 0.16 0.18 0.20 0.22 0.24 0.26 0.28 0.30 echo -n $i &gt;&gt; energy.dat  grep  EENTRO OUTCAR_</code></pre><p>&#x3D;&#x3D;<strong>总结</strong>&#x3D;&#x3D;</p><ol><li><strong>对结构弛豫（需要计算力），半导体&#x2F;绝缘体小胞用<code>ISMEAR=-5</code>，大胞用<code>ISMEAR=0</code>;金属用<code>ISMEAR=1或2</code>，需要测<code>SIGMA</code></strong></li><li>*<strong>对<code>dos</code>,由于自洽与非自洽都不需要计算力，统一使用<code>ISMEAR=-5</code>;</strong></li><li><strong>对能带，由于<code>ISMEAR=-5</code>不能识别线性的<code>kpoints</code>,因此半导体&#x2F;绝缘体用<code>ISMEAR=0</code>,金属用<code>ISMEAR=1或2</code></strong></li><li><strong>对声子谱，用<code>ISMEAR&gt;0</code></strong>**</li></ol><h2 id="4-计算dos与band"><a href="#4-计算dos与band" class="headerlink" title="4.计算dos与band"></a><strong>4.计算<code>dos</code>与<code>band</code></strong></h2><h3 id="1-DOS费米能级问题"><a href="#1-DOS费米能级问题" class="headerlink" title="1. DOS费米能级问题"></a>1. DOS费米能级问题</h3><ul><li><p>计算dos时，有时会发现dos步的费米能级和scf步的费米能级不同，这是因为dos使用了不同的k点，对于不同空间群的结构，使用的k点不恰当，可能会导致k点取不到价带顶，使得填充电子的时候，填充到了价带底。</p></li><li><p>计算dos时，第一步自洽会出现的问题：不同的k点数量得到的费米能级的值不同，</p><p>比如学校机&#x2F;data&#x2F;home&#x2F;mym&#x2F;workplace&#x2F;xieyu&#x2F;liz&#x2F;3-article&#x2F;3-K5YSi4O12&#x2F;3-dos&#x2F;2-dos 中，就发现使用444的k点无法判断准确的费米能级而333就可以，这个原因同上，直接改掉dos中的费米能级就行</p></li><li><p>也可能会遇到dos的费米能级比能带要低，导致能带的价带顶高于费米能级，原因是DOS的k点密度不够大，使得计算不够，可以加大计算dos的k点，（vaspkit里102设置成0.01），能够解决这个问题</p></li><li><p>vaspkit算完能带后会输出band_gap文件，里面的VBM按理说应该就是费米能级的位置，看这个值和dos里面doscar的费米能级哪个更小用哪个做费米能级</p></li><li><p>大体系应该减少在能带路径上的插值</p></li><li><p>计算能带、dos，结构的键长等参数有小的变化也会引起结果比较大的不同，可能差100meV。需要把结构优化到足够的精度，尤其是带真空层的</p></li></ul><h3 id="2-真空中三维-二维材料的能带路径问题"><a href="#2-真空中三维-二维材料的能带路径问题" class="headerlink" title="2. 真空中三维&#x2F;二维材料的能带路径问题"></a>2. 真空中三维&#x2F;二维材料的能带路径问题</h3><p>真空层的三维   能带结构用二维的k点路径 因为真空层厚度大，倒空间0 0 0.5 和0 0 0 没什么区别</p><blockquote><ul><li>记得加自旋  变得光滑用NEDOS   (<a href="https://www.bigbrosci.com/2017/10/30/ex08/?highlight=%E6%B0%A7">https://www.bigbrosci.com/2017/10/30/ex08/?highlight=%E6%B0%A7</a>)</li><li>自旋极化什么时候加： 单原子的计算，O2分子，自由基相关计算，含 Fe Co Ni 的体系，体系有磁性，关注电子性质</li><li>查看体系磁矩 加上ISPIN&#x3D;2后在OSICAR中查看mag的数值</li></ul></blockquote><h3 id="3-重要的参数"><a href="#3-重要的参数" class="headerlink" title="3.重要的参数"></a>3.重要的参数</h3><ol><li><p>LORBIT</p><p>LORBIT控制PROCAR的产生</p></li></ol><h3 id="4-步骤"><a href="#4-步骤" class="headerlink" title="4.步骤"></a>4.步骤</h3><h4 id="1-结构优化-1"><a href="#1-结构优化-1" class="headerlink" title="1.结构优化"></a>1.<a href="#123">结构优化</a></h4><h4 id="2-静态自洽"><a href="#2-静态自洽" class="headerlink" title="2.静态自洽"></a>2.<strong>静态自洽</strong></h4><p>&#x3D;&#x3D;<strong>自洽得到准确的基态电子密度，然后固定电子密度，进行非自洽，dos进行两步的目的是更加精确；能带进行两步第二步是为了获得特定k点的能量和本征值</strong>&#x3D;&#x3D;</p><blockquote><p>LORBIT 控制PROCAR的产生</p></blockquote><pre><code class="shell">IBRION = -1NSW = 0LWAVE = .TRUE  #默认为True,输出WAVECARLCHARGE =.TRUE #默认为True,输出CHGCARISTART = 0#当WAVECAR存在时，默认值为1，读取WAVECAR，其他情况默认为0，从头开始构建轨道ICHARG = 2#ISTART为0时默认为2，等于11时，从给定的CHGCAR读取本征值ISMEAR = -5 #非常重要ISPIN = 2</code></pre><h4 id="3-计算DOS的非自洽"><a href="#3-计算DOS的非自洽" class="headerlink" title="3.计算DOS的非自洽"></a><strong>3.计算DOS的非自洽</strong></h4><p>&#x3D;&#x3D;<strong>加大k点计算更准确的电子态密度，<code>ISMEAR=-5</code></strong>&#x3D;&#x3D;</p><pre><code class="shell">NSW = 0IBRION = -1ISTART =1ICHARG = 11LORBIT = 11ISMEAR = -5NEDOS = 3000ISPIN = 2#增加K点网络  cp自洽的电荷密度 CHG CHGCAR  波函数 WAVECAR**</code></pre><h4 id="4-使用HSE计算DOS"><a href="#4-使用HSE计算DOS" class="headerlink" title="4**.使用HSE计算DOS**"></a>4**.使用<code>HSE</code>计算<code>DOS</code>**</h4><pre><code class="shell">#在非自洽计算时，INCAR加上SYSTEMISMEAR = -5LORBIT =10ISTART = 1ICHARG = 11LHFCALC = .TRUE.  #采用杂化泛函计算HFSCREEN = 0.2     #0.2代表HSE06，0.3代表HSE03ALGO = All   #Damped更容易收敛TIME = 0.4    PRECFOCK = FastNKRED = 2</code></pre><h4 id="5-计算能带"><a href="#5-计算能带" class="headerlink" title="5**.计算能带**"></a>5**.计算能带**</h4><blockquote><ul><li><strong>金属用<code>ISMEAR=1</code>, 半导体或绝缘体，用<code>ISMEAR=0</code>(能带就是不同k点上本征值连成的线,因为<code>ISMEAR=-5</code>正四面体法无法识别线性的<code>k-points</code></strong></li><li><strong>非自洽:非自洽就是在给定基态电子密度下的一次电子自洽，获得特定k点的能量本征值,给定电子密度下，计算特定k点的本征值，即本征能级（<code>EIGENVAL</code>文件）连起来获得能带</strong></li><li>不需要读取WAVECAR 即ISTART &#x3D; 0就可以，也不需要输出WAVECAR，即LWAVE &#x3D; .FALSE.</li><li>关于费米能级，认为dos&#x2F;自洽算出来的费米能级是准确的。通过看能带的OUTCAR对应费米能级的占据，可以检查是否是金属还是绝缘体</li></ul></blockquote><hr><pre><code class="shell">SYSTEM PREC=AccurateEDIFF =1e-5NSW = 0IBRION = -1ISIF = 2 ENCUT = 1000ISTART =1ICHARG =11 ISMEAR= 1SIGMA = 0.2NBANDS = 同自洽用的NBANDS/可以多设置一些，1.5倍吧#k点要变化，cp自洽的电荷密度（和计算态密度比差别主要在k点）cp电子密度 波函数#能带k点（特定高对称点间）（要先导入对称性 build-build symmetry)  k-points along high symmetry lines   20 ！20 intersections   Line-mode   rec（倒空间，cart笛卡尔空间）    0 0 0 ! gamma    0 0 1 ! X        * * * ! X    * * * !      #dos和band画图：交换坐标轴，合并图片，右侧；绘图完成右侧锯齿可使线条更加平滑</code></pre><ul><li><p>测试一个金属</p><p>ISMEAR &#x3D; -5的结果</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230603154355515.png" alt="image-20230603154355515"></p><p>ISMEAR &#x3D; 1 SIGMA &#x3D; 0.2的结果</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230603154452378.png" alt="image-20230603154452378"></p><p>ISMEAR &#x3D; 0 SIGMA &#x3D; 0.05的结果</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230603154524087.png" alt="image-20230603154524087"></p><p>ISMEAR &#x3D; 0 SIGMA &#x3D; 0.05 调高k点密度的结果</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230603154903386.png" alt="image-20230603154903386"></p><h4 id="6-作图"><a href="#6-作图" class="headerlink" title="6. 作图"></a>6. 作图</h4><p>&#x3D;&#x3D;自洽的费米能级是准确的，能带和dos使用同一个费米能级 需要把能带和dos里的DOSCAR的费米能级改成自洽的费米能级&#x3D;&#x3D;</p><p>&#x3D;&#x3D;自洽不要用太高密度的k点 数值误差&#x3D;&#x3D;</p></li></ul><h2 id="5-测试NCORE和KPAR"><a href="#5-测试NCORE和KPAR" class="headerlink" title="5. 测试NCORE和KPAR"></a>5. <strong>测试NCORE和KPAR</strong></h2><blockquote><p><strong>为了便于对比</strong></p><ol><li><strong>可以使用ISTART &#x3D; 1 ICHARG &#x3D; 11的方式，统一一个离子步的电子步个数，进而计算单个离子步所用时长</strong></li><li><strong>可以通过设置NELM 和NELMIN来固定电子步个数</strong></li></ol></blockquote><ul><li>1.产生INCAR</li></ul><pre><code class="shell">ncores=(1 2 4 8 12 16 18 24 )kpars=(1 2 4 8 12 16 20 24)# Create directories for each combination of parametersfor ncore in &quot;$&#123;ncores[@]&#125;&quot;; do    for kpar in &quot;$&#123;kpars[@]&#125;&quot;; do        dir=&quot;ncore$&#123;ncore&#125;-kpar$&#123;kpar&#125;&quot;        mkdir -p $dir        cp INCAR POSCAR POTCAR xiugai.sh $dir        sed -i &quot;s/NCORE = .*/NCORE = $ncore/&quot; $dir/INCAR        sed -i &quot;s/KPAR = .*/KPAR = $kpar/&quot; $dir/INCAR    donedone</code></pre><ul><li>2.计算（将所有任务提到一个节点上）</li></ul><pre><code class="shell">#!/bin/sh#SBATCH  --job-name=vasp_job  #SBATCH  --output=log.out.%j#SBATCH  --error=log.err.%j#SBATCH  --partition=xieyuib#SBATCH  --nodes=4#SBATCH  --ntasks=192source /work/env/oneapi-2022.2.0srun hostname | sort | uniq &gt;&gt; /tmp/nodefile.$$NP=`srun hostname | wc -l`ncores=(1 2 4 8 12 16 18 24 )kpars=(4 8 )# Run VASP in each directory and save the outputfor dir in $(ls -d ncore*-kpar*); do    cd $dir    echo &quot;Running VASP with NCORE = $(grep &quot;NCORE&quot; INCAR | awk &#39;&#123;print $3&#125;&#39;), KPAR = $(grep &quot;KPAR&quot; INCAR | awk &#39;&#123;print $3&#125;&#39;)&quot;#mpirun -genv I_MPI_FABRICS shm:ofa -machinefile /tmp/nodefile.$$ -n $NP /work/software/vasp.6.1.0/vasp_std  &gt; vasp.log 2&gt;&amp;1mpirun -genv I_MPI_FABRICS shm:ofa -machinefile /tmp/nodefile.$$ -n $NP /work/software/vasp.6.1.0-oneapi2022.2.0/vasp.6.1.0/bin/vasp_std  &gt; vasp.log 2&gt;&amp;1#/work/software/vasp.6.1.0-oneapi2022.2.0/vasp.6.1.0/bin/vasp_std  &gt; vasp.log 2&gt;&amp;1#mpirun -n 48 /work/software/vasp6.1-intel2018/vasp_std &gt; vasp.log 2&gt;&amp;1    cd ..donerm -rf /tmp/nodefile.$$</code></pre><ul><li>3.提取数据</li></ul><pre><code class="shell">for dir in $(ls -d ncore*-kpar*); do    echo &quot;Running VASP with NCORE = $(grep NCORE $dir/INCAR), KPAR = $(grep &quot;KPAR&quot; $dir/INCAR)&quot;  &gt;&gt; dat    grep LOOP $dir/OUTCAR |tail -n 10 &gt;&gt; dat    done</code></pre><h2 id="6-关于扩三倍胞"><a href="#6-关于扩三倍胞" class="headerlink" title="6.关于扩三倍胞"></a>6.关于扩三倍胞</h2><ul><li><ol><li>扩胞是如何进行的</li></ol></li></ul><p><strong>from vesta</strong> </p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230513153714264.png" alt="image-20230513153714264"></p><p><strong>即</strong>$[a,b,c]P&#x3D;[a_1,b_1,c_1]$，新的a是旧有的a,b,c按照旋转矩阵第一列组合而来，依此类推。</p><p>&#x3D;&#x3D;<strong>注意：vesta在扩胞后会进行一步旋转</strong>，<strong>来得到晶格常数矩阵为下三角的晶格矩阵</strong>&#x3D;&#x3D;</p><p>只要保证扩胞矩阵的行列式为3，那么扩出来的胞就是三倍胞吗，一定不是</p><p>旋转矩阵1<br>$$<br>\begin{matrix}3&amp;0&amp;0\0&amp;1&amp;0\0&amp;0&amp;1\end{matrix}<br>$$<br>和旋转矩阵2<br>$$<br>\begin{matrix}3&amp;1&amp;0\0&amp;1&amp;0\0&amp;0&amp;1\end{matrix}<br>$$<br>行列式都是3，但是矩阵1乘出来是$[3a,b,c]$,而矩阵2乘出来是$[3a,a+b,c]$体积是不同的，非对角元</p><h2 id="7-构建POTCAR"><a href="#7-构建POTCAR" class="headerlink" title="7. 构建POTCAR"></a>7. 构建POTCAR</h2><pre><code class="python"># 字典：元素对应的赝势文件路径base_pseudo_path = &#39;/work/home/liz/vasp_pot/potpaw_PBE/&#39;pseudo_paths = &#123;    &#39;H&#39;: &#39;H/POTCAR&#39;,    &#39;Li&#39;: &#39;Li_sv/POTCAR&#39;,    &#39;Be&#39;: &#39;Be_sv/POTCAR&#39;,    &#39;B&#39;: &#39;B/POTCAR&#39;,    &#39;C&#39;: &#39;C/POTCAR&#39;,    &#39;N&#39;: &#39;N/POTCAR&#39;,    &#39;O&#39;: &#39;O/POTCAR&#39;,    &#39;F&#39;: &#39;F/POTCAR&#39;,    &#39;Ne&#39;: &#39;Ne/POTCAR&#39;,    &#39;Na&#39;: &#39;Na_pv/POTCAR&#39;,    &#39;Mg&#39;: &#39;Mg_pv/POTCAR&#39;,    &#39;Al&#39;: &#39;Al/POTCAR&#39;,    &#39;Si&#39;: &#39;Si/POTCAR&#39;,    &#39;P&#39;: &#39;P/POTCAR&#39;,    &#39;S&#39;: &#39;S/POTCAR&#39;,    &#39;Cl&#39;: &#39;Cl/POTCAR&#39;,    &#39;K&#39;: &#39;K_sv/POTCAR&#39;,    &#39;Ca&#39;: &#39;Ca_sv/POTCAR&#39;,    &#39;Sc&#39;: &#39;Sc_sv/POTCAR&#39;,    &#39;Ti&#39;: &#39;Ti_pv/POTCAR&#39;,    &#39;V&#39;: &#39;V_pv/POTCAR&#39;,    &#39;Cr&#39;: &#39;Cr_pv/POTCAR&#39;,    &#39;Mn&#39;: &#39;Mn_pv/POTCAR&#39;,    &#39;Fe&#39;: &#39;Fe_pv/POTCAR&#39;,    &#39;Co&#39;: &#39;Co/POTCAR&#39;,    &#39;Ni&#39;: &#39;Ni_pv/POTCAR&#39;,    &#39;Cu&#39;: &#39;Cu_pv/POTCAR&#39;,    &#39;Zn&#39;: &#39;Zn/POTCAR&#39;,    &#39;Ga&#39;: &#39;Ga_d/POTCAR&#39;,    &#39;Ge&#39;: &#39;Ge_d/POTCAR&#39;,    &#39;As&#39;: &#39;As/POTCAR&#39;,    &#39;Se&#39;: &#39;Se/POTCAR&#39;,    &#39;Br&#39;: &#39;Br/POTCAR&#39;,    &#39;Kr&#39;: &#39;Kr/POTCAR&#39;,    &#39;Rb&#39;: &#39;Rb_sv/POTCAR&#39;,    &#39;Sr&#39;: &#39;Sr_sv/POTCAR&#39;,    &#39;Y&#39;: &#39;Y_sv/POTCAR&#39;,    &#39;Zr&#39;: &#39;Zr_sv/POTCAR&#39;,    &#39;Nb&#39;: &#39;Nb_pv/POTCAR&#39;,    &#39;Mo&#39;: &#39;Mo_pv/POTCAR&#39;,    &#39;Tc&#39;: &#39;Tc_pv/POTCAR&#39;,    &#39;Ru&#39;: &#39;Ru_pv/POTCAR&#39;,    &#39;Rh&#39;: &#39;Rh_pv/POTCAR&#39;,    &#39;Pd&#39;: &#39;Pd/POTCAR&#39;,    &#39;Ag&#39;: &#39;Ag/POTCAR&#39;,    &#39;Cd&#39;: &#39;Cd/POTCAR&#39;,    &#39;In&#39;: &#39;In_d/POTCAR&#39;,    &#39;Sn&#39;: &#39;Sn_d/POTCAR&#39;,    &#39;Sb&#39;: &#39;Sb/POTCAR&#39;,    &#39;Te&#39;: &#39;Te/POTCAR&#39;,    &#39;I&#39;: &#39;I/POTCAR&#39;,    &#39;Xe&#39;: &#39;Xe/POTCAR&#39;,    &#39;Cs&#39;: &#39;Cs_sv/POTCAR&#39;,    &#39;Ba&#39;: &#39;Ba_sv/POTCAR&#39;,    &#39;La&#39;: &#39;La/POTCAR&#39;,    &#39;Ce&#39;: &#39;Ce/POTCAR&#39;,    &#39;Pr&#39;: &#39;Pr_3/POTCAR&#39;,    &#39;Nd&#39;: &#39;Nd_3/POTCAR&#39;,    &#39;Pm&#39;: &#39;Pm_3/POTCAR&#39;,    &#39;Sm&#39;: &#39;Sm_3/POTCAR&#39;,    &#39;Eu&#39;: &#39;Eu/POTCAR&#39;,    &#39;Gd&#39;: &#39;Gd/POTCAR&#39;,    &#39;Tb&#39;: &#39;Tb_3/POTCAR&#39;,    &#39;Dy&#39;: &#39;Dy_3/POTCAR&#39;,    &#39;Ho&#39;: &#39;Ho_3/POTCAR&#39;,    &#39;Er&#39;: &#39;Er_3/POTCAR&#39;,    &#39;Tm&#39;: &#39;Tm_3/POTCAR&#39;,    &#39;Yb&#39;: &#39;Yb_2/POTCAR&#39;,    &#39;Lu&#39;: &#39;Lu_3/POTCAR&#39;,    &#39;Hf&#39;: &#39;Hf_pv/POTCAR&#39;,    &#39;Ta&#39;: &#39;Ta_pv/POTCAR&#39;,    &#39;W&#39;: &#39;W_pv/POTCAR&#39;,    &#39;Re&#39;: &#39;Re_pv/POTCAR&#39;,    &#39;Os&#39;: &#39;Os_pv/POTCAR&#39;,    &#39;Ir&#39;: &#39;Ir/POTCAR&#39;,    &#39;Pt&#39;: &#39;Pt/POTCAR&#39;,    &#39;Au&#39;: &#39;Au/POTCAR&#39;,    &#39;Hg&#39;: &#39;Hg/POTCAR&#39;,    &#39;Tl&#39;: &#39;Tl_d/POTCAR&#39;,    &#39;Pb&#39;: &#39;Pb_d/POTCAR&#39;,    &#39;Bi&#39;: &#39;Bi/POTCAR&#39;,    &#39;Th&#39;: &#39;Th/POTCAR&#39;,    &#39;Pa&#39;: &#39;Pa/POTCAR&#39;,    &#39;U&#39;: &#39;U/POTCAR&#39;,    &#39;Np&#39;: &#39;Np/POTCAR&#39;,    &#39;Pu&#39;: &#39;Pu/POTCAR&#39;,# 添加其他元素和对应的赝势路径&#125;for element, relative_path in pseudo_paths.items():    full_path = f&quot;&#123;base_pseudo_path&#125;&#123;relative_path&#125;&quot;    pseudo_paths[element] = full_path# 读取 POSCAR 文件def read_poscar(poscar_path):    with open(poscar_path, &#39;r&#39;) as f:        lines = f.readlines()        elements = lines[5].split()        return elements# 创建大的 POTCAR 文件def create_big_potcar(elements, pseudo_paths, output_path):    with open(output_path, &#39;w&#39;) as f_out:        for element in elements:            if element in pseudo_paths:                pseudo_path = pseudo_paths[element]                with open(pseudo_path, &#39;r&#39;) as f_pseudo:                    f_out.write(f_pseudo.read())            else:                print(f&quot;赝势文件不存在或未定义：&#123;element&#125;&quot;)if __name__ == &quot;__main__&quot;:    poscar_path = &quot;POSCAR&quot;  # 输入文件名    output_potcar_path = &quot;POTCAR&quot;  # 输出的大 POTCAR 文件名    elements = read_poscar(poscar_path)    create_big_potcar(elements, pseudo_paths, output_potcar_path)    print(&quot;大的 POTCAR 文件已创建&quot;)</code></pre><h3 id="批量运行"><a href="#批量运行" class="headerlink" title="批量运行"></a>批量运行</h3><pre><code class="shell">for folder in */; do    if [ -d &quot;$folder&quot; ]; then        cp pot.py &quot;$folder&quot;        cd &quot;$folder&quot;        python pot.py &amp;        sleep 10        cd ..    fidone</code></pre><h2 id="8-计算声子谱"><a href="#8-计算声子谱" class="headerlink" title="8.计算声子谱"></a>8.计算声子谱</h2><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230918191143087.png" alt="image-20230918191143087"></p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230918191349568.png" alt="image-20230918191349568"></p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230918191431912.png" alt="image-20230918191431912"></p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230918191456663.png" alt="image-20230918191456663"></p><blockquote><p> phonopy.yaml and phonopy_disp.yaml  : 创建有限位移 </p></blockquote><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230918194211441.png" alt="image-20230918194211441"> </p><ul><li><p>为什么要扩胞 （减小周期性的影响，大于100个原子即可？）</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230918201329823.png" alt="image-20230918201329823"></p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230918202023049.png" alt="image-20230918202023049"></p></li></ul><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230918201605726.png" alt="image-20230918201605726"></p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230918202413543.png" alt="image-20230918202413543"></p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230918202447854.png" alt="image-20230918202447854"></p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230918202455356.png" alt="image-20230918202455356"></p><p>phonopy-bandplot –gnuplot band.yaml &gt; phono.dat   保存数据</p><h2 id="9-HSE06-计算能带"><a href="#9-HSE06-计算能带" class="headerlink" title="9. HSE06 计算能带"></a>9. HSE06 计算能带</h2><p><a href="http://vaspkit.cn/index.php/29.html">杂化泛函计算能带 - VASPKIT与量化软件</a></p><p><a href="https://www.vasp.at/wiki/index.php/IALGO">IALGO - Vaspwiki</a>  推荐用ALGO&#x3D;Damped或者All</p><p><a href="https://www.vasp.at/wiki/index.php/LHFCALC">LHFCALC - Vaspwiki</a></p><blockquote><p>可以直接一步算，也就是直接用HSE06的方法算能带，但是对大体系可能会比较慢</p><p>可以分两步算，先使用PBE算CHG CHGCAR （需要注意的是PBE计算时KPOINTS要删掉不带权重的部分）然后copy CHG …等，使用HSE06计算能带 ，这样应该会更快点</p><p>两种算出来的有些许差别，在误差范围内，不同的初猜电荷密度和波函数会带来结果细微不同</p></blockquote><p>&#x3D;&#x3D;算能带第一步自洽就是得到电荷密度和波函数，普通算能带直接用ISTART &#x3D; 1 读WAVECAR和ICHARGE &#x3D; 11读CHGCAR就可以了。是给算能带的电荷密度和波函数给一个初猜值。ICHARGE&#x3D;11还有一个功能是固定住了电荷密度不变。&#x3D;&#x3D;</p><p>&#x3D;&#x3D;但是在HSE计算中，如果分两步来做，第二步的ICHARG不能固定住，需要用ICHARGE&#x3D;1,这样电荷密度可以迭代，读取的只是一个初猜值，因为HSE杂化泛函和普通的不同&#x3D;&#x3D;</p><p>&#x3D;&#x3D;最终建议：直接用一步法来做，省事又省时间&#x3D;&#x3D;</p><p>&#x3D;&#x3D;需要注意的点：计算HSE06的能带不能用ISMEAR &#x3D;-5，因为不识别，可用ISMEAR&#x3D;0&#x3D;&#x3D;</p><p>&#x3D;&#x3D;师弟遇到过一个问题：一步法得到的本征值和用HSE06自洽得到的本征值不同，因此建议是算一个自洽的本征值，如果和HSE06的结果一样，那就说明没问题，如果不一样，就要先HSE自洽，再读-算能带&#x3D;&#x3D;</p><p>1.结构优化</p><p>2.产生HSE06特用的KPOINTS</p><p>包括两部分，带权重的部分和不带权重的部分，其中带权重的部分是均匀撒点的，不带权重的能带的k点路径</p><p>均匀撒点是构建一个用于后面的良好的势，然后进行后面的计算，有没有pbe自洽的初猜值对最终的影响并不大</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20231011185414503.png" alt="image-20231011185414503"></p><p>3.进行PBE自洽计算(不能用ISMEAR &#x3D;-5)</p><p>需要使用均匀洒点的kpoints，可以直接把上面的kpoints不带权重的部分删除，然后把k点数目修改掉</p><p>注意：不能使用不带权重的部分，否则算出来的带隙和直接使用HSE06计算不同</p><p>4.进行HSE06能带计算(复制CHG CHGCAR WAVECAR…)</p><p>SYSTEM &#x3D; Te<br>PREC &#x3D; Normal<br>EDIFF &#x3D; 1e-6<br>ENCUT &#x3D; 300<br>NELM &#x3D; 500<br>IBRION &#x3D; -1<br>ISIF &#x3D; 2<br>ISMEAR &#x3D; 0<br>SIGMA &#x3D; 0.05<br>PSTRESS &#x3D; 0.001<br>ISTART &#x3D; 0<br>ICHARG &#x3D;2<br>NPAR &#x3D; 12<br>ALGO &#x3D; Damped</p><p>！HSE参数</p><p>LHFCALC&#x3D;.TRUE.<br>HFSCREEN &#x3D; 0.2<br>TIME &#x3D; 0.4<br>LMAXFOCK &#x3D; 4<br>PRECFOCK&#x3D;Normal</p><blockquote><p>SIGMA &#x3D; 0. 05</p><p>&#x3D;&#x3D;处理数据产生能带时vaspkit不能用常规的，要用HSE特有的，252&#x3D;&#x3D;</p></blockquote><p>EIGENVAL 是本征值文件，可以看每个k点的本征值</p><h2 id="9-自旋轨道耦合计算能带"><a href="#9-自旋轨道耦合计算能带" class="headerlink" title="9.自旋轨道耦合计算能带"></a>9.自旋轨道耦合计算能带</h2><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230926195529367.png" alt="image-20230926195529367"></p><p>一个HSE06+SOC的能带计算</p><pre><code>SYSTEM = TePREC = NormalEDIFF = 1e-6ENCUT = 300NELM = 500IBRION = -1ISIF = 2ISMEAR = 0SIGMA = 0.05PSTRESS = 0.001ISTART = 1ICHARG =0NPAR = 12ALGO = Damped(收敛快，vaspwiki LHFCALC关键词下推荐的,all或者damped,算出来能带比较放心)#HSE06参数LHFCALC=.TRUE.HFSCREEN = 0.2TIME = 0.4LMAXFOCK = 4PRECFOCK=Normal#SOC参数ISPIN = 2LSORBIT = .TRUE.LORBMOM  = TMAGMOM   = 9*0 给定每个原子每个方向（xyz)方向的磁矩，这里是3个原子，可以先按默认值给初猜，最后OUTCAR会输出每个方向的磁矩LORBIT = 11ISYM = -1#使用GGA时的修正GGA = PSGGA_COMPAT = .FALSE.</code></pre><blockquote><p>使用LDA比PBE要更容易收敛，LDA不需要GGA和GGA_COMPAT</p></blockquote><h2 id="10-做异质结"><a href="#10-做异质结" class="headerlink" title="10 .做异质结"></a>10 .做异质结</h2><p>&#x3D;&#x3D;记住，构建完优化时要用固定晶格的优化&#x3D;&#x3D;</p><p>&#x3D;&#x3D;要加范德华力&#x3D;&#x3D;</p><p>[利用Materials Studio构建异质结的详细攻略 - 知乎 (zhihu.com)](<a href="https://zhuanlan.zhihu.com/p/291117500#:~:text=%E6%89%93%E5%BC%80Build">https://zhuanlan.zhihu.com/p/291117500#:~:text=打开Build</a> -Bulid,Layers，在Define Layers界面上导入slab1和slab2；然后点击Matching界面，检查两组参数a1、b1与a2、b2是否相近；选择Layer1、Layer2或者average合并晶胞，点击build按钮即可生成异质结结构。)</p><p>层状材料 是不应该加vdw的，只要是有周期性的材料都不应该加vdw</p><p>例子：PdSe   &#x2F;data&#x2F;home&#x2F;mym&#x2F;workplace&#x2F;xieyu&#x2F;liz&#x2F;2-cal&#x2F;8-PbSe2&#x2F;1-opt-PdSe2</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20231113153952705.png" alt="image-20231113153952705"></p><p>加vdw后与文献不符合</p><h2 id="11-做差分电荷密度"><a href="#11-做差分电荷密度" class="headerlink" title="11.做差分电荷密度"></a>11.做差分电荷密度</h2><p><a href="https://blog.shishiruqi.com/2019/07/12/chgdiff/">https://blog.shishiruqi.com/2019/07/12/chgdiff/</a></p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20231115105059098.png" alt="image-20231115105059098"></p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20231115105111192.png" alt="image-20231115105111192"></p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20231115105127103.png" alt="image-20231115105127103"></p><h2 id="12-如何加U"><a href="#12-如何加U" class="headerlink" title="12. 如何加U"></a>12. 如何加U</h2><p>[DFT+U理论及“一步”完成DFT+U多步计算 - 知乎 (zhihu.com)](<a href="https://zhuanlan.zhihu.com/p/349419162#:~:text=02">https://zhuanlan.zhihu.com/p/349419162#:~:text=02</a> 、如何加U%3F DFT计算时输入文件的U值由以下参数确定 ： LDAU %3D.TRUE.|.FALSE.：开启%2F关闭%2BU功能，默认值为.FALSE.； LDAUTYPE %3D1|2|4指的是%2BU的类型，默认值是2；其中1为Liechtenstein等提出的旋转不变LSDA%2BU方法；2为,LSDA%2BU方法；4与1类似%2C 但不考虑LSDA交换劈裂； LDAUL %3D-1|1|2|3分别对应不加U、p、d、f轨道加U； LDAUU、LDAUJ 分别指定电子库伦相互作用项和交换相互作用项（U和J值）； LMAXMIX %3D2%2F4%2F6：默认为2，加U计算时该值需大于轨道量子数，对于含有d轨道或f轨道电子的体系需对应增加至4或6。)</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20240131093236149.png" alt="image-20240131093236149"></p><h2 id="13-磁性"><a href="#13-磁性" class="headerlink" title="13. 磁性"></a>13. 磁性</h2><p>材料的磁性对应的微观电子结构为<strong>电子自旋的方向并不均匀分布</strong>。</p><p>绝大多数的磁性材料计算中，电子的自旋只会平行排列（磁各向同性，是共线磁矩 </p><p>不考虑自旋的占据态能级自旋向上的能级和向下的能级相同，由同一个能级表示。</p><p>考虑共线磁矩时，自旋向上和自旋向下的能级分别输出，每个能级的电子占据数为1，共同计算费米能级。</p><p>由于自旋上和下能级大小不同，如果费米能级以下的不同自旋指标的能级数量不同，将导致体系整体出现磁矩。</p><p>对于反铁磁的情况，体系的磁密度呈现整体无磁矩，局部有磁矩的情况。</p><p>非共线磁矩</p><p>有的体系中，电子的自旋会沿不同方向排列（磁各向异性），这时磁密度通过x y z三个方向的投影表示</p><h1 id="2-关于并行参数"><a href="#2-关于并行参数" class="headerlink" title="2. 关于并行参数"></a>2. 关于并行参数</h1><p><a href="https://zhuanlan.zhihu.com/p/485153538">vasp并行参数设置 - 知乎 (zhihu.com)</a></p><p><a href="https://scc.ustc.edu.cn/zlsc/jsrj/201810/W020181016364157753668.pdf">VASP应用运行优化 (ustc.edu.cn)</a></p><p>&#x3D;&#x3D;解释&#x3D;&#x3D;</p><p>第一性原理的计算过程是计算一个体系的不同k点上许多不同的电子态，不同的电子态也称为带&#x2F;band，每个k点有很多要计算的带</p><p>假设一个场景，用一个cpu核计算一个体系，那么这个体系会先计算这个体系的第一个k点的第一个带，再计算第一个k点的第二个带，依次往后，计算第二个k点的第一个带。。。</p><p>并行指的是用多个cpu核同时计算多个任务。对一个计算而言，可以分为带并行和k点并行，也就是同时跑多少个k点，同时跑一个k点的多少个带。设置不同的并行参数，会分配给每个k点，每个k点的不同带cpu核心数。这两个并行并不是平行的，先对k点并行，然后给一个k点的带分配核数。</p><p>KPOINT 并行属于外层的并行，BAND 并行属于较内层的并行</p><p>比如一共有48核，一个k点要算的带数目为4，如果设置k点并行为6，带并行为4，那么就是同时计算6个k点，每个k点用48&#x2F;6&#x3D;8个核心来计算，同时计算一个k点的4个带，每个k点的每个带用2个核心计算。</p><p>如果一个k点要算的带数目一共只有3个呢，（当然最好设置带并行为3），假设设置带并行为2（设置为4会有一些核不进行计算），那么单个k点用48&#x2F;6&#x3D;8个核心，每个带用4个核心，同时计算2个带，但是这时候，会有一个带没有计算，在计算完一个带后，才会计算另一个k点，此时还会有一批cpu空下来，因此如果k点并行不设置为k点数目的除数，会出现空余的现象。 k点并行也一样，如果k点并行设置的太大，那么可能会有多的核数用不到</p><p>实际中应该把带并行和k点并行分开来看</p><p>一个重要的知识点</p><p>k点的并行优点是不需要通讯，因为没有数据的分发，缺点是要耗费内存。内存比较大的系统可以设置k点并行。</p><p>带的并行是把数据分发到不同的带上，这样的优点是耗费的内存少，缺点是不同带间需要通讯。当通讯带宽比较大的时候，可以把带的数目设置大一点，这样即便设置多个带并行通讯效率也不会太差；但是通讯带宽比较小时，不要设置同时并行太多带， 因为会大大增加带的通讯。</p><p>&#x3D;&#x3D;cpu核数从哪里来？&#x3D;&#x3D;</p><p>增加cpu的核数可以从两方面，一个是节点内并行，一个是多节点的并行。</p><p>节点内的并行相比节点间肯定是降低了通讯的时间的，但是有时候很难在一个节点内得到足够多的核心数，所以需要多个节点来串联计算。但是在设置并行参数时需要考虑的是尽量让k点和带的计算不要跨节点，比如给一个带分配50个核，但是一个节点只有48个核心，那么就需要去别的节点借来两个核心，由于节点间有通讯，这样会大大降低计算速度。不同节点的cpu核心串联时是依次串联的，因此可以先用第一个节点的，再用后面的。</p><p>也就是尽量保持节点间的独立性。</p><p>&#x3D;&#x3D;vasp中的并行参数&#x3D;&#x3D;</p><p>vasp中用KPAR来控制k点的并行，也就是一次计算多少个k点</p><p>KPAR默认为1，也就是一个k点用1个核心，同时计算cpus个k点。</p><p>vasp中用NPAR来控制带的并行，也就是每个k点同时计算多少条带  </p><p>NPAR默认值为核的数量，比如有48核，NPAR默认为48，也就是同时计算48个带，每个带用1个核心计算，这一个核心计算完这一系列带再计算其他的带，其他的k点。</p><p>如果只设置NPAR，那么默认KPAR为1，NCORE&#x3D;cpus&#x2F;NPAR</p><p>带并行会把数据按照带来分发，这样需要增加不同带之间的通讯，当通讯带宽比较大的时候，可以把带的数目设置大一点，但是通讯带宽比较小时，不要设置同时并行太多带， 因为会大大增加带的通讯。</p><p>vasp中用NCORE来控制计算一个带的核心的数量（等同于NPAR的效果。  cpus&#x2F;NCORE&#x3D;NPAR)</p><p>NCORE 默认值为1 (与NPAR的默认值为所有的核数相对应，NCORE*NPAR的默认值为总核数)</p><p>&#x3D;&#x3D;KPAR×NPAR×NCORE &#x3D; cpus&#x3D;&#x3D;</p><p>设置技巧</p><blockquote><p>KPAR控制k点并行，这个参数应该设置为k点的除数，（不一定是k点本身的数目，这样就是同时算一个带的所有k点）</p><p>节点内并行要快于节点间的并行，因此尽量保证计算过程中一个节点计算整数条带，比如设置NCORE的值为一个节点的cpu核数，或者它的除数，这样保证一条带只在一个节点上计算</p><p> The best value NCORE depends somewhat on the number of atoms in the unit cell. Values around 4 are usually ideal for 100 atoms in the unit cell. For very large unit cells (more than 400 atoms) values around 12-16 are often optimal. If you run extensive simulations for similar systems, make your own tests.</p><p>让KPAR、NPAR、NCORE三个数比较相近</p><h3 id="小体系并行"><a href="#小体系并行" class="headerlink" title="小体系并行"></a>小体系并行</h3><p>小体系的特点是原子数少, K点较多, 能带少. 因此KPAR应尽可能设大, NPAR可设为1.</p><p>在中等规模的系统(20-100 个原子)中，情况会有所不同。此时，计算的不可约k 点的数量很少（5-50），而电子能带的数量会很大(&gt;100).</p><ul><li>尽可能将 k 点并行化驱动到最大值（KPAR 尽可能大）。这里的限制因素是实际的 k 点数和可用的内存量。后者是因为更高的 KPAR 值会导致更高的内存需求。[<a href="https://link.zhihu.com/?target=https://dannyvanpoucke.be/2016/12/%23_ftn2">2]</a></li><li>使用 Gamma 版本的 VASP 仅用于 Γ 点计算。它显着降低了内存使用量（3.7Gb→ 2.8Gb&#x2F;core 用于 512 原子金刚石系统）并提高了计算效率，有时甚至提高了 2 倍。</li><li>NPAR 并行化可用于减少高 KPAR 计算的内存负载，但就计算效率而言, 增加 KPAR 优于增加 NPAR。</li><li>如果只有 NPAR 并行化可用，由于 k 点太少，并且使用大型系统，NPAR 并行化也很重要。</li></ul><p><strong>K 点并行很重要！如果要大量计算类似结构, 如长时间的MD等, 应该在计算前简单测算选取最优的KPAR&#x2F;NPAR(NCORE)参数.</strong></p><p>NCORE 与 NPAR 只 能指定一个有效</p><p>NCORE &#x3D; 8 下的运行时间经常处于最优值，且基本处于 [4,16] 空间范围内。</p></blockquote><p><img src="/./../%E5%9B%BE%E7%89%87/image-20231214094205234.png" alt="image-20231214094205234"></p><h1 id="1-关于K点"><a href="#1-关于K点" class="headerlink" title="1. 关于K点"></a>1. 关于K点</h1><p>K-points里面的设置就是总共插入了多少个点，但是会由于对称性进行约化，得到的是不可约k点。比如 333出来14个k点，是因为约化了</p><p><a href="http://bbs.keinsci.com/thread-13066-1-1.html">http://bbs.keinsci.com/thread-13066-1-1.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/397873103?utm_id=0">https://zhuanlan.zhihu.com/p/397873103?utm_id=0</a></p><h1 id="关于测试K点和kSPACING"><a href="#关于测试K点和kSPACING" class="headerlink" title="关于测试K点和kSPACING"></a>关于测试K点和kSPACING</h1><p>&#x3D;&#x3D;需要保证能量差小于1mev&#x2F;atom&#x3D;&#x3D;  </p><p>&#x3D;&#x3D;k点没有想象中那么大，ENCUT没有想象中那么小&#x3D;&#x3D;</p><p>先测ENCUT再测KSPACING</p><p>**金刚石测试结果(8 atoms) **PBE54</p><p>KSPACING &#x3D; 0.1</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20240109150611877.png" alt="image-20240109150611877"></p><p>KSPACING &#x3D; 0.2</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20240109151749175.png" alt="image-20240109151749175"></p><p>C的ENCUT&#x3D;400 eV  用900才可以（注意是*100） KSPACING&#x3D;0.1 2920 k点  KSPACING&#x3D;0.2 365k点已经够了 </p><p>PAW_PBE 0.2 (material project中使用的)</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20240109160358474.png" alt="image-20240109160358474"></p><p>石墨测试(16atoms)</p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20240109150705858.png" alt="image-20240109150705858"></p><p>石墨的ENCUT需要用800 eV  ，但是KSPACING可以用0.2</p><h1 id="3-计算报错"><a href="#3-计算报错" class="headerlink" title="3.计算报错"></a>3.计算报错</h1><h4 id="1-试试ISYM-0"><a href="#1-试试ISYM-0" class="headerlink" title="1.试试ISYM &#x3D; 0"></a>1.试试ISYM &#x3D; 0</h4><ol><li><p><strong>internal ERROR RSPHER:running out of buffer</strong><br><strong>Abort(1) on node 15 (rank 15 in comm 0): application called MPI_Abort(MPI_COMM_WORLD, 1) - process 15</strong><br> <strong>原因：buffer传输不够</strong></p><blockquote><p><strong>解决方法：<a href="https://www.vasp.at/forum/viewtopic.php?t=2806&p=2809">https://www.vasp.at/forum/viewtopic.php?t=2806&amp;p=2809</a></strong><br><strong>​                  改nonlr.F，重新编译vasp</strong><br><strong>​                   search for the following lines in nonlr.F</strong><br><strong>IF (IRMAX &gt; NONLR_S%IRMAX) THEN</strong><br><strong>! IRMAX is the maximum global number, could be improved !!!!</strong><br>*<em>NONLR_S%IRMAX &#x3D;IRMAX <em>1.1<br>LREALLOCATE&#x3D;.TRUE.<br>ENDIF<br>IF( IRALLOC &gt; NONLR_S%IRALLOC) THEN<br>! more safety on parallel machines increase by 20 %<br>NONLR_S%IRALLOC &#x3D;IRALLOC</em>1.2</em>*<br><strong>LREALLOCATE&#x3D;.TRUE.</strong><br><strong>ENDIF</strong><br><strong>and change</strong><br><strong>NONLR_S%IRALLOC &#x3D;IRALLOC<em>1.1 to<br>NONLR_S%IRALLOC &#x3D;IRALLOC</em>1.2</strong><br><strong>and</strong><br><strong>NONLR_S%IRALLOC &#x3D;IRALLOC<em>1.2 to<br>NONLR_S%IRALLOC &#x3D;IRALLOC</em>1.3</strong></p></blockquote></li><li><p><strong>报错 Error EDDDAV: Call to ZHEGV failed. Returncode &#x3D;</strong></p></li></ol><blockquote><p>**1.NPAR **</p><p><strong>2.赝势</strong></p><p>**3.ALGO  **</p><p><strong>参见 <a href="http://www.error.wiki/Error_EDDDAV:_Call_to_ZHEGV_failed%EF%BC%88%E5%9C%A8BN%E5%92%8CNSmSiO%E8%87%AA%E6%B4%BD%E4%B8%AD%E9%81%87%E5%88%B0%E8%BF%87%EF%BC%89">http://www.error.wiki/Error_EDDDAV:_Call_to_ZHEGV_failed（在BN和NSmSiO自洽中遇到过）</a></strong></p></blockquote><ol start="3"><li><strong>报错 ERROR FEXCP: supplied Exchange-correletion table is too small, maximal index :</strong></li></ol><blockquote><p><strong>编译器和vasp版本的冲突（编译的时候使用的是intel2018,使用时用intel2020会出现这样的问题），可能是POTCAR与vasp版本不兼容</strong><br><strong>vasp5.4-intel2020 vasp6.1-intel2018</strong><br><strong>一定要注意运行时使用的编译器版本和编译时使用的编译器版本相同（尤其是自己编译的）</strong></p></blockquote><ol start="4"><li><p><strong>ERROR FEXCP: supplied Exchange-correletion table</strong></p><p>​    <strong>is too small, maximal index :        3885</strong></p><blockquote><p><strong>对称性的问题，设置ISYM &#x3D; 0</strong></p></blockquote></li><li><p><strong>Sub-Space-Matrix is not hermitian</strong></p></li></ol><p>​      我排查的问题是使用的节点太多了，减少使用的节点后可以运行</p><ol start="6"><li><p>报错 </p></li><li><p>HNFORM: ERROR: k-point generating vectors and reciprocal lattice   are incommensurate.</p><p>设置ISYM &#x3D; 0</p></li></ol><h2 id="5-自洽不收敛"><a href="#5-自洽不收敛" class="headerlink" title="5.自洽不收敛"></a>5.自洽不收敛</h2><p>换电子算法</p><h1 id="4-计算脚本"><a href="#4-计算脚本" class="headerlink" title="4.计算脚本"></a>4.计算脚本</h1><h2 id="1-变压优化"><a href="#1-变压优化" class="headerlink" title="1.变压优化"></a><strong>1.变压优化</strong></h2><pre><code class="shell">for p in 100 200 300 #for i in $(seq 300 50 700)docat &gt; INCAR &lt;&lt; lizhaohenshua#cat 命令 查看文件的内容、连接文件、创建一个或多个文件和重定向输出到终端或文件 cat &gt;test;cat a b &gt; c; cat a; #cat 后跟输入之后进行标准输出#&lt;&lt;EOF是定界标识符 终结字符串必须写在行首 &gt;是重写 &gt;&gt;是追加    SYSTEM=Li   PREC = Accurate   ENCUT = 600   EDIFF = 1e-6   IBRION = 2   ISIF = 3   NSW = 200   ISMEAR = 0   SIGMA =0.05   POTIM = 0.2   KSPACING = 0.18   EDIFFG = -0.001lizhaohenshuaimpirun -np 48 vasp路径 &gt; vasp.log 2&gt;&amp;1``cp CONTCAR CONTCAR_$pcp OUTCAR OUTCAR _$pdone</code></pre><h2 id="2-提取能量值"><a href="#2-提取能量值" class="headerlink" title="2.提取能量值"></a><strong>2.提取能量值</strong></h2><pre><code class="shell">for i in 100 200 300 400 500 600 700 800 900 1000doecho -n $i &gt;&gt; energy.dat  #-n 不换行）done</code></pre><ul><li>-n 不要在最后自动换行     </li><li>-e 若字符串中出现以下字符，则特别加以处理，而不会将它当成一般文本 </li><li>\b 删除前一个字符；</li><li>\c 最后不加上换行符号</li><li>\f 换行但光标仍旧停留在原来的位置</li><li>\n 换行且光标移至行首</li><li>\r 光标移至行首，但不换行</li></ul><pre><code class="shell">awk &#39;&#123;print&#125;&#39; infor.txt  #awk会在文件的每一行上按顺序地执行print命令，执行的结果被输出到标准输出 awk &#39;&#123;print $1&#125;&#39; infor.txt 输出第一列) grep -n #显示匹配行的行号</code></pre><h2 id="3-KPOINTS"><a href="#3-KPOINTS" class="headerlink" title="3.KPOINTS"></a><strong>3.KPOINTS</strong></h2><pre><code class="shell">Automatic generation 0Monkhorst-pack  6 6 6   0 0 0</code></pre><h1 id="5-tips"><a href="#5-tips" class="headerlink" title="**5.tips **"></a>**5.tips **</h1><ul><li><p><strong><code>OUTCAR</code>中的能量是晶格结构的能量，而OSZICAR中的能量E包括热浴和晶格结构的能量，<code>OZICAR</code>中的F是<code>OUTCAR</code>中的能量。按照经验来看，热浴的能量一直不平衡，但是系统的能量是平衡的。</strong></p></li><li><p><strong><code>KPOINTS</code>中，相同晶格常数应具有相同的k点密度，否则无法运行</strong></p></li><li><p><code>**vasp.log ! vasp.log! vasp.log!</code></p></li><li><p><strong>编译vasp：参考<a href="http://hmli.ustc.edu.cn/doc/app/vasp.5.4.1-vtst.htm">http://hmli.ustc.edu.cn/doc/app/vasp.5.4.1-vtst.htm</a></strong></p></li><li><p><a href="https://blog.csdn.net/zesuzesuzesu/article/details/120232558">VASP 6.1.0 + VTST + intel新OneAPI 安装编译_vasp vtst onapi-CSDN博客</a></p></li><li><p><a href="https://www.vasp.at/wiki/index.php/Installing_VASP.6.X.X">Installing VASP.6.X.X - VASP Wiki</a>  可以多核并行来编译</p><ul><li><strong>vasp的文件在桌面&#x2F;vasp&#x2F;vasp编译文件夹中</strong></li><li><strong>source &#x2F;work&#x2F;env&#x2F;intel2020</strong> </li><li><strong>把makefile.include 复制到目录</strong></li><li><strong>make all</strong></li></ul></li><li><p>*<em>加背景电荷 <code>NELECT= POTCAR</code> 中(<code>ZVAL of the element</code>) <em>POSCAR中原子个数</em></em></p></li><li><p><strong>vasp <code>ALGO= All</code> 和<code>ALGO = Fast/Normal</code>的运行效果对比</strong>  </p><ul><li><strong>1.All的能量会略高于Fast 但是不多可忽略了</strong></li><li><strong>2.All花费的时间更长  Fast的单个电子步时长会慢慢变短 但是All维持一个时间长度。因此总的花费时间更长</strong></li><li><strong>3.All每个离子步中的电子步数大致相同，但是Fast会随着离子步增加收敛需要的电子步减少</strong></li></ul></li></ul><h1 id="6-编译vasp"><a href="#6-编译vasp" class="headerlink" title="6. 编译vasp"></a>6. 编译vasp</h1><h2 id="1-只编译vasp"><a href="#1-只编译vasp" class="headerlink" title="1.只编译vasp"></a>1.只编译vasp</h2><ol><li><p><strong>把arch里对应的makefile.include复制到arch的上一文件夹</strong></p></li><li><p><strong>source  intel环境</strong></p><p><img src="/./../%E5%9B%BE%E7%89%87/image-20230510143608518.png" alt="image-20230510143608518"></p></li><li><p><strong>在makefile的文件夹下 make</strong></p></li></ol><h2 id="2-把vtst的neb方法编译进vasp"><a href="#2-把vtst的neb方法编译进vasp" class="headerlink" title="2.把vtst的neb方法编译进vasp"></a>2.把vtst的neb方法编译进vasp</h2><blockquote><p><strong>首先查看官方教程 <a href="http://toeory.cm.utexas.edu/vtsttools/">vtst安装</a><strong>，</strong>官方网站给出了具体需要复制、修改哪些行</strong></p></blockquote><ol><li><p><strong>将vtstcode文件夹的子文件夹对应版本中的所有.F文件复制到vasp的src文件夹</strong></p></li><li><p><strong>将</strong></p><pre><code>bfgs.o dynmat.o instanton.o lbfgs.o sd.o cg.o dimer.o bbm.o \fire.o lanczos.o neb.o qm.o opt.o</code></pre><p><strong>加入到vasp的src&#x2F;.objects文件中，具体位置在chain.o之前。&#x3D;&#x3D;一共有两个chain.o，都要复制上&#x3D;&#x3D;</strong></p><p><strong><img src="/./../%E5%9B%BE%E7%89%87/image-20230510144526781.png" alt="image-20230510144526781"></strong></p></li><li><p><strong>修改main.F</strong></p></li></ol><p><strong><img src="/./../%E5%9B%BE%E7%89%87/image-20230510144647525.png" alt="image-20230510144647525"></strong></p><ol start="4"><li><strong>source intel环境</strong></li><li><strong>复制对应版本的makefile.include</strong></li><li><strong>make</strong></li></ol><blockquote><p><strong>原始版 教程</strong></p></blockquote><p><img src="/./../%E5%9B%BE%E7%89%87/b2c49b21b20e2461934680c97d683e7.jpg" alt="b2c49b21b20e2461934680c97d683e7"></p><h1 id="7-使用MS技巧"><a href="#7-使用MS技巧" class="headerlink" title="7. 使用MS技巧"></a>7. 使用MS技巧</h1><ol><li><p>如何去除原子周期性，这样删除一个原子不会删除所有等价位置的原子</p><p>build -symmetry-make p1</p></li><li><p>在做吸附时，如果发现复制一个分子上去会出现很多分子，这是由于主体结构包括对称性导致的，需要把主体结构make p1 然后再复制就会只出现一个分子</p></li><li><p>报错</p></li></ol><p><img src="/./../%E5%9B%BE%E7%89%87/110501y8ajy28r019eai10.jpg" alt="img"></p><p>原因：有道词典划词翻译？ 关掉有道就好使了</p><h1 id="8-linux命令"><a href="#8-linux命令" class="headerlink" title="8.linux命令"></a>8.linux命令</h1><p>free 查看内存信息</p><p>scontrol show node 查看内存信息</p><p>lscpu 查看cpu型号和基准频率等等</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;1-计算方法、流程与输入文件&quot;&gt;&lt;a href=&quot;#1-计算方法、流程与输入文件&quot; class=&quot;headerlink&quot; title=&quot;1.计算方法、流程与输入文件&quot;&gt;&lt;/a&gt;1.计算方法、流程与输入文件&lt;/h1&gt;&lt;h2 id=&quot;1-结构</summary>
      
    
    
    
    <category term="模拟方法" scheme="http://example.com/categories/%E6%A8%A1%E6%8B%9F%E6%96%B9%E6%B3%95/"/>
    
    
  </entry>
  
</feed>
